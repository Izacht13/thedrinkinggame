{"version":3,"names":[],"mappings":"","sources":["src/main.js"],"sourcesContent":["require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nrequire(\"./angular-pages/app\");\n\n\n//# sourceURL=F:/nodeTemplate/src/main.js\n},{\"./angular-pages/app\":136}],2:[function(require,module,exports){\n\"use strict\";\n(function(Q, W, t) {\n  'use strict';\n  function R(b) {\n    return function() {\n      var a = arguments[0],\n          c;\n      c = \"[\" + (b ? b + \":\" : \"\") + a + \"] http://errors.angularjs.org/1.3.15/\" + (b ? b + \"/\" : \"\") + a;\n      for (a = 1; a < arguments.length; a++) {\n        c = c + (1 == a ? \"?\" : \"&\") + \"p\" + (a - 1) + \"=\";\n        var d = encodeURIComponent,\n            e;\n        e = arguments[a];\n        e = \"function\" == typeof e ? e.toString().replace(/ \\{[\\s\\S]*$/, \"\") : \"undefined\" == typeof e ? \"undefined\" : \"string\" != typeof e ? JSON.stringify(e) : e;\n        c += d(e);\n      }\n      return Error(c);\n    };\n  }\n  function Sa(b) {\n    if (null == b || Ta(b))\n      return !1;\n    var a = b.length;\n    return b.nodeType === qa && a ? !0 : C(b) || H(b) || 0 === a || \"number\" === typeof a && 0 < a && a - 1 in b;\n  }\n  function r(b, a, c) {\n    var d,\n        e;\n    if (b)\n      if (G(b))\n        for (d in b)\n          \"prototype\" == d || \"length\" == d || \"name\" == d || b.hasOwnProperty && !b.hasOwnProperty(d) || a.call(c, b[d], d, b);\n      else if (H(b) || Sa(b)) {\n        var f = \"object\" !== typeof b;\n        d = 0;\n        for (e = b.length; d < e; d++)\n          (f || d in b) && a.call(c, b[d], d, b);\n      } else if (b.forEach && b.forEach !== r)\n        b.forEach(a, c, b);\n      else\n        for (d in b)\n          b.hasOwnProperty(d) && a.call(c, b[d], d, b);\n    return b;\n  }\n  function Ed(b, a, c) {\n    for (var d = Object.keys(b).sort(),\n        e = 0; e < d.length; e++)\n      a.call(c, b[d[e]], d[e]);\n    return d;\n  }\n  function mc(b) {\n    return function(a, c) {\n      b(c, a);\n    };\n  }\n  function Fd() {\n    return ++ob;\n  }\n  function nc(b, a) {\n    a ? b.$$hashKey = a : delete b.$$hashKey;\n  }\n  function w(b) {\n    for (var a = b.$$hashKey,\n        c = 1,\n        d = arguments.length; c < d; c++) {\n      var e = arguments[c];\n      if (e)\n        for (var f = Object.keys(e),\n            g = 0,\n            h = f.length; g < h; g++) {\n          var l = f[g];\n          b[l] = e[l];\n        }\n    }\n    nc(b, a);\n    return b;\n  }\n  function aa(b) {\n    return parseInt(b, 10);\n  }\n  function Ob(b, a) {\n    return w(Object.create(b), a);\n  }\n  function E() {}\n  function ra(b) {\n    return b;\n  }\n  function ea(b) {\n    return function() {\n      return b;\n    };\n  }\n  function x(b) {\n    return \"undefined\" === typeof b;\n  }\n  function y(b) {\n    return \"undefined\" !== typeof b;\n  }\n  function J(b) {\n    return null !== b && \"object\" === typeof b;\n  }\n  function C(b) {\n    return \"string\" === typeof b;\n  }\n  function Y(b) {\n    return \"number\" === typeof b;\n  }\n  function ga(b) {\n    return \"[object Date]\" === Ca.call(b);\n  }\n  function G(b) {\n    return \"function\" === typeof b;\n  }\n  function Ua(b) {\n    return \"[object RegExp]\" === Ca.call(b);\n  }\n  function Ta(b) {\n    return b && b.window === b;\n  }\n  function Va(b) {\n    return b && b.$evalAsync && b.$watch;\n  }\n  function Wa(b) {\n    return \"boolean\" === typeof b;\n  }\n  function oc(b) {\n    return !(!b || !(b.nodeName || b.prop && b.attr && b.find));\n  }\n  function Gd(b) {\n    var a = {};\n    b = b.split(\",\");\n    var c;\n    for (c = 0; c < b.length; c++)\n      a[b[c]] = !0;\n    return a;\n  }\n  function va(b) {\n    return z(b.nodeName || b[0] && b[0].nodeName);\n  }\n  function Xa(b, a) {\n    var c = b.indexOf(a);\n    0 <= c && b.splice(c, 1);\n    return a;\n  }\n  function Da(b, a, c, d) {\n    if (Ta(b) || Va(b))\n      throw Ja(\"cpws\");\n    if (a) {\n      if (b === a)\n        throw Ja(\"cpi\");\n      c = c || [];\n      d = d || [];\n      if (J(b)) {\n        var e = c.indexOf(b);\n        if (-1 !== e)\n          return d[e];\n        c.push(b);\n        d.push(a);\n      }\n      if (H(b))\n        for (var f = a.length = 0; f < b.length; f++)\n          e = Da(b[f], null, c, d), J(b[f]) && (c.push(b[f]), d.push(e)), a.push(e);\n      else {\n        var g = a.$$hashKey;\n        H(a) ? a.length = 0 : r(a, function(b, c) {\n          delete a[c];\n        });\n        for (f in b)\n          b.hasOwnProperty(f) && (e = Da(b[f], null, c, d), J(b[f]) && (c.push(b[f]), d.push(e)), a[f] = e);\n        nc(a, g);\n      }\n    } else if (a = b)\n      H(b) ? a = Da(b, [], c, d) : ga(b) ? a = new Date(b.getTime()) : Ua(b) ? (a = new RegExp(b.source, b.toString().match(/[^\\/]*$/)[0]), a.lastIndex = b.lastIndex) : J(b) && (e = Object.create(Object.getPrototypeOf(b)), a = Da(b, e, c, d));\n    return a;\n  }\n  function sa(b, a) {\n    if (H(b)) {\n      a = a || [];\n      for (var c = 0,\n          d = b.length; c < d; c++)\n        a[c] = b[c];\n    } else if (J(b))\n      for (c in a = a || {}, b)\n        if (\"$\" !== c.charAt(0) || \"$\" !== c.charAt(1))\n          a[c] = b[c];\n    return a || b;\n  }\n  function ha(b, a) {\n    if (b === a)\n      return !0;\n    if (null === b || null === a)\n      return !1;\n    if (b !== b && a !== a)\n      return !0;\n    var c = typeof b,\n        d;\n    if (c == typeof a && \"object\" == c)\n      if (H(b)) {\n        if (!H(a))\n          return !1;\n        if ((c = b.length) == a.length) {\n          for (d = 0; d < c; d++)\n            if (!ha(b[d], a[d]))\n              return !1;\n          return !0;\n        }\n      } else {\n        if (ga(b))\n          return ga(a) ? ha(b.getTime(), a.getTime()) : !1;\n        if (Ua(b))\n          return Ua(a) ? b.toString() == a.toString() : !1;\n        if (Va(b) || Va(a) || Ta(b) || Ta(a) || H(a) || ga(a) || Ua(a))\n          return !1;\n        c = {};\n        for (d in b)\n          if (\"$\" !== d.charAt(0) && !G(b[d])) {\n            if (!ha(b[d], a[d]))\n              return !1;\n            c[d] = !0;\n          }\n        for (d in a)\n          if (!c.hasOwnProperty(d) && \"$\" !== d.charAt(0) && a[d] !== t && !G(a[d]))\n            return !1;\n        return !0;\n      }\n    return !1;\n  }\n  function Ya(b, a, c) {\n    return b.concat(Za.call(a, c));\n  }\n  function pc(b, a) {\n    var c = 2 < arguments.length ? Za.call(arguments, 2) : [];\n    return !G(a) || a instanceof RegExp ? a : c.length ? function() {\n      return arguments.length ? a.apply(b, Ya(c, arguments, 0)) : a.apply(b, c);\n    } : function() {\n      return arguments.length ? a.apply(b, arguments) : a.call(b);\n    };\n  }\n  function Hd(b, a) {\n    var c = a;\n    \"string\" === typeof b && \"$\" === b.charAt(0) && \"$\" === b.charAt(1) ? c = t : Ta(a) ? c = \"$WINDOW\" : a && W === a ? c = \"$DOCUMENT\" : Va(a) && (c = \"$SCOPE\");\n    return c;\n  }\n  function $a(b, a) {\n    if (\"undefined\" === typeof b)\n      return t;\n    Y(a) || (a = a ? 2 : null);\n    return JSON.stringify(b, Hd, a);\n  }\n  function qc(b) {\n    return C(b) ? JSON.parse(b) : b;\n  }\n  function wa(b) {\n    b = A(b).clone();\n    try {\n      b.empty();\n    } catch (a) {}\n    var c = A(\"<div>\").append(b).html();\n    try {\n      return b[0].nodeType === pb ? z(c) : c.match(/^(<[^>]+>)/)[1].replace(/^<([\\w\\-]+)/, function(a, b) {\n        return \"<\" + z(b);\n      });\n    } catch (d) {\n      return z(c);\n    }\n  }\n  function rc(b) {\n    try {\n      return decodeURIComponent(b);\n    } catch (a) {}\n  }\n  function sc(b) {\n    var a = {},\n        c,\n        d;\n    r((b || \"\").split(\"&\"), function(b) {\n      b && (c = b.replace(/\\+/g, \"%20\").split(\"=\"), d = rc(c[0]), y(d) && (b = y(c[1]) ? rc(c[1]) : !0, tc.call(a, d) ? H(a[d]) ? a[d].push(b) : a[d] = [a[d], b] : a[d] = b));\n    });\n    return a;\n  }\n  function Pb(b) {\n    var a = [];\n    r(b, function(b, d) {\n      H(b) ? r(b, function(b) {\n        a.push(Ea(d, !0) + (!0 === b ? \"\" : \"=\" + Ea(b, !0)));\n      }) : a.push(Ea(d, !0) + (!0 === b ? \"\" : \"=\" + Ea(b, !0)));\n    });\n    return a.length ? a.join(\"&\") : \"\";\n  }\n  function qb(b) {\n    return Ea(b, !0).replace(/%26/gi, \"&\").replace(/%3D/gi, \"=\").replace(/%2B/gi, \"+\");\n  }\n  function Ea(b, a) {\n    return encodeURIComponent(b).replace(/%40/gi, \"@\").replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%3B/gi, \";\").replace(/%20/g, a ? \"%20\" : \"+\");\n  }\n  function Id(b, a) {\n    var c,\n        d,\n        e = rb.length;\n    b = A(b);\n    for (d = 0; d < e; ++d)\n      if (c = rb[d] + a, C(c = b.attr(c)))\n        return c;\n    return null;\n  }\n  function Jd(b, a) {\n    var c,\n        d,\n        e = {};\n    r(rb, function(a) {\n      a += \"app\";\n      !c && b.hasAttribute && b.hasAttribute(a) && (c = b, d = b.getAttribute(a));\n    });\n    r(rb, function(a) {\n      a += \"app\";\n      var e;\n      !c && (e = b.querySelector(\"[\" + a.replace(\":\", \"\\\\:\") + \"]\")) && (c = e, d = e.getAttribute(a));\n    });\n    c && (e.strictDi = null !== Id(c, \"strict-di\"), a(c, d ? [d] : [], e));\n  }\n  function uc(b, a, c) {\n    J(c) || (c = {});\n    c = w({strictDi: !1}, c);\n    var d = function() {\n      b = A(b);\n      if (b.injector()) {\n        var d = b[0] === W ? \"document\" : wa(b);\n        throw Ja(\"btstrpd\", d.replace(/</, \"&lt;\").replace(/>/, \"&gt;\"));\n      }\n      a = a || [];\n      a.unshift([\"$provide\", function(a) {\n        a.value(\"$rootElement\", b);\n      }]);\n      c.debugInfoEnabled && a.push([\"$compileProvider\", function(a) {\n        a.debugInfoEnabled(!0);\n      }]);\n      a.unshift(\"ng\");\n      d = ab(a, c.strictDi);\n      d.invoke([\"$rootScope\", \"$rootElement\", \"$compile\", \"$injector\", function(a, b, c, d) {\n        a.$apply(function() {\n          b.data(\"$injector\", d);\n          c(b)(a);\n        });\n      }]);\n      return d;\n    },\n        e = /^NG_ENABLE_DEBUG_INFO!/,\n        f = /^NG_DEFER_BOOTSTRAP!/;\n    Q && e.test(Q.name) && (c.debugInfoEnabled = !0, Q.name = Q.name.replace(e, \"\"));\n    if (Q && !f.test(Q.name))\n      return d();\n    Q.name = Q.name.replace(f, \"\");\n    ca.resumeBootstrap = function(b) {\n      r(b, function(b) {\n        a.push(b);\n      });\n      return d();\n    };\n    G(ca.resumeDeferredBootstrap) && ca.resumeDeferredBootstrap();\n  }\n  function Kd() {\n    Q.name = \"NG_ENABLE_DEBUG_INFO!\" + Q.name;\n    Q.location.reload();\n  }\n  function Ld(b) {\n    b = ca.element(b).injector();\n    if (!b)\n      throw Ja(\"test\");\n    return b.get(\"$$testability\");\n  }\n  function vc(b, a) {\n    a = a || \"_\";\n    return b.replace(Md, function(b, d) {\n      return (d ? a : \"\") + b.toLowerCase();\n    });\n  }\n  function Nd() {\n    var b;\n    wc || ((ta = Q.jQuery) && ta.fn.on ? (A = ta, w(ta.fn, {\n      scope: Ka.scope,\n      isolateScope: Ka.isolateScope,\n      controller: Ka.controller,\n      injector: Ka.injector,\n      inheritedData: Ka.inheritedData\n    }), b = ta.cleanData, ta.cleanData = function(a) {\n      var c;\n      if (Qb)\n        Qb = !1;\n      else\n        for (var d = 0,\n            e; null != (e = a[d]); d++)\n          (c = ta._data(e, \"events\")) && c.$destroy && ta(e).triggerHandler(\"$destroy\");\n      b(a);\n    }) : A = T, ca.element = A, wc = !0);\n  }\n  function Rb(b, a, c) {\n    if (!b)\n      throw Ja(\"areq\", a || \"?\", c || \"required\");\n    return b;\n  }\n  function sb(b, a, c) {\n    c && H(b) && (b = b[b.length - 1]);\n    Rb(G(b), a, \"not a function, got \" + (b && \"object\" === typeof b ? b.constructor.name || \"Object\" : typeof b));\n    return b;\n  }\n  function La(b, a) {\n    if (\"hasOwnProperty\" === b)\n      throw Ja(\"badname\", a);\n  }\n  function xc(b, a, c) {\n    if (!a)\n      return b;\n    a = a.split(\".\");\n    for (var d,\n        e = b,\n        f = a.length,\n        g = 0; g < f; g++)\n      d = a[g], b && (b = (e = b)[d]);\n    return !c && G(b) ? pc(e, b) : b;\n  }\n  function tb(b) {\n    var a = b[0];\n    b = b[b.length - 1];\n    var c = [a];\n    do {\n      a = a.nextSibling;\n      if (!a)\n        break;\n      c.push(a);\n    } while (a !== b);\n    return A(c);\n  }\n  function ia() {\n    return Object.create(null);\n  }\n  function Od(b) {\n    function a(a, b, c) {\n      return a[b] || (a[b] = c());\n    }\n    var c = R(\"$injector\"),\n        d = R(\"ng\");\n    b = a(b, \"angular\", Object);\n    b.$$minErr = b.$$minErr || R;\n    return a(b, \"module\", function() {\n      var b = {};\n      return function(f, g, h) {\n        if (\"hasOwnProperty\" === f)\n          throw d(\"badname\", \"module\");\n        g && b.hasOwnProperty(f) && (b[f] = null);\n        return a(b, f, function() {\n          function a(c, d, e, f) {\n            f || (f = b);\n            return function() {\n              f[e || \"push\"]([c, d, arguments]);\n              return u;\n            };\n          }\n          if (!g)\n            throw c(\"nomod\", f);\n          var b = [],\n              d = [],\n              e = [],\n              q = a(\"$injector\", \"invoke\", \"push\", d),\n              u = {\n                _invokeQueue: b,\n                _configBlocks: d,\n                _runBlocks: e,\n                requires: g,\n                name: f,\n                provider: a(\"$provide\", \"provider\"),\n                factory: a(\"$provide\", \"factory\"),\n                service: a(\"$provide\", \"service\"),\n                value: a(\"$provide\", \"value\"),\n                constant: a(\"$provide\", \"constant\", \"unshift\"),\n                animation: a(\"$animateProvider\", \"register\"),\n                filter: a(\"$filterProvider\", \"register\"),\n                controller: a(\"$controllerProvider\", \"register\"),\n                directive: a(\"$compileProvider\", \"directive\"),\n                config: q,\n                run: function(a) {\n                  e.push(a);\n                  return this;\n                }\n              };\n          h && q(h);\n          return u;\n        });\n      };\n    });\n  }\n  function Pd(b) {\n    w(b, {\n      bootstrap: uc,\n      copy: Da,\n      extend: w,\n      equals: ha,\n      element: A,\n      forEach: r,\n      injector: ab,\n      noop: E,\n      bind: pc,\n      toJson: $a,\n      fromJson: qc,\n      identity: ra,\n      isUndefined: x,\n      isDefined: y,\n      isString: C,\n      isFunction: G,\n      isObject: J,\n      isNumber: Y,\n      isElement: oc,\n      isArray: H,\n      version: Qd,\n      isDate: ga,\n      lowercase: z,\n      uppercase: ub,\n      callbacks: {counter: 0},\n      getTestability: Ld,\n      $$minErr: R,\n      $$csp: bb,\n      reloadWithDebugInfo: Kd\n    });\n    cb = Od(Q);\n    try {\n      cb(\"ngLocale\");\n    } catch (a) {\n      cb(\"ngLocale\", []).provider(\"$locale\", Rd);\n    }\n    cb(\"ng\", [\"ngLocale\"], [\"$provide\", function(a) {\n      a.provider({$$sanitizeUri: Sd});\n      a.provider(\"$compile\", yc).directive({\n        a: Td,\n        input: zc,\n        textarea: zc,\n        form: Ud,\n        script: Vd,\n        select: Wd,\n        style: Xd,\n        option: Yd,\n        ngBind: Zd,\n        ngBindHtml: $d,\n        ngBindTemplate: ae,\n        ngClass: be,\n        ngClassEven: ce,\n        ngClassOdd: de,\n        ngCloak: ee,\n        ngController: fe,\n        ngForm: ge,\n        ngHide: he,\n        ngIf: ie,\n        ngInclude: je,\n        ngInit: ke,\n        ngNonBindable: le,\n        ngPluralize: me,\n        ngRepeat: ne,\n        ngShow: oe,\n        ngStyle: pe,\n        ngSwitch: qe,\n        ngSwitchWhen: re,\n        ngSwitchDefault: se,\n        ngOptions: te,\n        ngTransclude: ue,\n        ngModel: ve,\n        ngList: we,\n        ngChange: xe,\n        pattern: Ac,\n        ngPattern: Ac,\n        required: Bc,\n        ngRequired: Bc,\n        minlength: Cc,\n        ngMinlength: Cc,\n        maxlength: Dc,\n        ngMaxlength: Dc,\n        ngValue: ye,\n        ngModelOptions: ze\n      }).directive({ngInclude: Ae}).directive(vb).directive(Ec);\n      a.provider({\n        $anchorScroll: Be,\n        $animate: Ce,\n        $browser: De,\n        $cacheFactory: Ee,\n        $controller: Fe,\n        $document: Ge,\n        $exceptionHandler: He,\n        $filter: Fc,\n        $interpolate: Ie,\n        $interval: Je,\n        $http: Ke,\n        $httpBackend: Le,\n        $location: Me,\n        $log: Ne,\n        $parse: Oe,\n        $rootScope: Pe,\n        $q: Qe,\n        $$q: Re,\n        $sce: Se,\n        $sceDelegate: Te,\n        $sniffer: Ue,\n        $templateCache: Ve,\n        $templateRequest: We,\n        $$testability: Xe,\n        $timeout: Ye,\n        $window: Ze,\n        $$rAF: $e,\n        $$asyncCallback: af,\n        $$jqLite: bf\n      });\n    }]);\n  }\n  function db(b) {\n    return b.replace(cf, function(a, b, d, e) {\n      return e ? d.toUpperCase() : d;\n    }).replace(df, \"Moz$1\");\n  }\n  function Gc(b) {\n    b = b.nodeType;\n    return b === qa || !b || 9 === b;\n  }\n  function Hc(b, a) {\n    var c,\n        d,\n        e = a.createDocumentFragment(),\n        f = [];\n    if (Sb.test(b)) {\n      c = c || e.appendChild(a.createElement(\"div\"));\n      d = (ef.exec(b) || [\"\", \"\"])[1].toLowerCase();\n      d = ja[d] || ja._default;\n      c.innerHTML = d[1] + b.replace(ff, \"<$1></$2>\") + d[2];\n      for (d = d[0]; d--; )\n        c = c.lastChild;\n      f = Ya(f, c.childNodes);\n      c = e.firstChild;\n      c.textContent = \"\";\n    } else\n      f.push(a.createTextNode(b));\n    e.textContent = \"\";\n    e.innerHTML = \"\";\n    r(f, function(a) {\n      e.appendChild(a);\n    });\n    return e;\n  }\n  function T(b) {\n    if (b instanceof T)\n      return b;\n    var a;\n    C(b) && (b = N(b), a = !0);\n    if (!(this instanceof T)) {\n      if (a && \"<\" != b.charAt(0))\n        throw Tb(\"nosel\");\n      return new T(b);\n    }\n    if (a) {\n      a = W;\n      var c;\n      b = (c = gf.exec(b)) ? [a.createElement(c[1])] : (c = Hc(b, a)) ? c.childNodes : [];\n    }\n    Ic(this, b);\n  }\n  function Ub(b) {\n    return b.cloneNode(!0);\n  }\n  function wb(b, a) {\n    a || xb(b);\n    if (b.querySelectorAll)\n      for (var c = b.querySelectorAll(\"*\"),\n          d = 0,\n          e = c.length; d < e; d++)\n        xb(c[d]);\n  }\n  function Jc(b, a, c, d) {\n    if (y(d))\n      throw Tb(\"offargs\");\n    var e = (d = yb(b)) && d.events,\n        f = d && d.handle;\n    if (f)\n      if (a)\n        r(a.split(\" \"), function(a) {\n          if (y(c)) {\n            var d = e[a];\n            Xa(d || [], c);\n            if (d && 0 < d.length)\n              return;\n          }\n          b.removeEventListener(a, f, !1);\n          delete e[a];\n        });\n      else\n        for (a in e)\n          \"$destroy\" !== a && b.removeEventListener(a, f, !1), delete e[a];\n  }\n  function xb(b, a) {\n    var c = b.ng339,\n        d = c && zb[c];\n    d && (a ? delete d.data[a] : (d.handle && (d.events.$destroy && d.handle({}, \"$destroy\"), Jc(b)), delete zb[c], b.ng339 = t));\n  }\n  function yb(b, a) {\n    var c = b.ng339,\n        c = c && zb[c];\n    a && !c && (b.ng339 = c = ++hf, c = zb[c] = {\n      events: {},\n      data: {},\n      handle: t\n    });\n    return c;\n  }\n  function Vb(b, a, c) {\n    if (Gc(b)) {\n      var d = y(c),\n          e = !d && a && !J(a),\n          f = !a;\n      b = (b = yb(b, !e)) && b.data;\n      if (d)\n        b[a] = c;\n      else {\n        if (f)\n          return b;\n        if (e)\n          return b && b[a];\n        w(b, a);\n      }\n    }\n  }\n  function Ab(b, a) {\n    return b.getAttribute ? -1 < (\" \" + (b.getAttribute(\"class\") || \"\") + \" \").replace(/[\\n\\t]/g, \" \").indexOf(\" \" + a + \" \") : !1;\n  }\n  function Bb(b, a) {\n    a && b.setAttribute && r(a.split(\" \"), function(a) {\n      b.setAttribute(\"class\", N((\" \" + (b.getAttribute(\"class\") || \"\") + \" \").replace(/[\\n\\t]/g, \" \").replace(\" \" + N(a) + \" \", \" \")));\n    });\n  }\n  function Cb(b, a) {\n    if (a && b.setAttribute) {\n      var c = (\" \" + (b.getAttribute(\"class\") || \"\") + \" \").replace(/[\\n\\t]/g, \" \");\n      r(a.split(\" \"), function(a) {\n        a = N(a);\n        -1 === c.indexOf(\" \" + a + \" \") && (c += a + \" \");\n      });\n      b.setAttribute(\"class\", N(c));\n    }\n  }\n  function Ic(b, a) {\n    if (a)\n      if (a.nodeType)\n        b[b.length++] = a;\n      else {\n        var c = a.length;\n        if (\"number\" === typeof c && a.window !== a) {\n          if (c)\n            for (var d = 0; d < c; d++)\n              b[b.length++] = a[d];\n        } else\n          b[b.length++] = a;\n      }\n  }\n  function Kc(b, a) {\n    return Db(b, \"$\" + (a || \"ngController\") + \"Controller\");\n  }\n  function Db(b, a, c) {\n    9 == b.nodeType && (b = b.documentElement);\n    for (a = H(a) ? a : [a]; b; ) {\n      for (var d = 0,\n          e = a.length; d < e; d++)\n        if ((c = A.data(b, a[d])) !== t)\n          return c;\n      b = b.parentNode || 11 === b.nodeType && b.host;\n    }\n  }\n  function Lc(b) {\n    for (wb(b, !0); b.firstChild; )\n      b.removeChild(b.firstChild);\n  }\n  function Mc(b, a) {\n    a || wb(b);\n    var c = b.parentNode;\n    c && c.removeChild(b);\n  }\n  function jf(b, a) {\n    a = a || Q;\n    if (\"complete\" === a.document.readyState)\n      a.setTimeout(b);\n    else\n      A(a).on(\"load\", b);\n  }\n  function Nc(b, a) {\n    var c = Eb[a.toLowerCase()];\n    return c && Oc[va(b)] && c;\n  }\n  function kf(b, a) {\n    var c = b.nodeName;\n    return (\"INPUT\" === c || \"TEXTAREA\" === c) && Pc[a];\n  }\n  function lf(b, a) {\n    var c = function(c, e) {\n      c.isDefaultPrevented = function() {\n        return c.defaultPrevented;\n      };\n      var f = a[e || c.type],\n          g = f ? f.length : 0;\n      if (g) {\n        if (x(c.immediatePropagationStopped)) {\n          var h = c.stopImmediatePropagation;\n          c.stopImmediatePropagation = function() {\n            c.immediatePropagationStopped = !0;\n            c.stopPropagation && c.stopPropagation();\n            h && h.call(c);\n          };\n        }\n        c.isImmediatePropagationStopped = function() {\n          return !0 === c.immediatePropagationStopped;\n        };\n        1 < g && (f = sa(f));\n        for (var l = 0; l < g; l++)\n          c.isImmediatePropagationStopped() || f[l].call(b, c);\n      }\n    };\n    c.elem = b;\n    return c;\n  }\n  function bf() {\n    this.$get = function() {\n      return w(T, {\n        hasClass: function(b, a) {\n          b.attr && (b = b[0]);\n          return Ab(b, a);\n        },\n        addClass: function(b, a) {\n          b.attr && (b = b[0]);\n          return Cb(b, a);\n        },\n        removeClass: function(b, a) {\n          b.attr && (b = b[0]);\n          return Bb(b, a);\n        }\n      });\n    };\n  }\n  function Ma(b, a) {\n    var c = b && b.$$hashKey;\n    if (c)\n      return \"function\" === typeof c && (c = b.$$hashKey()), c;\n    c = typeof b;\n    return c = \"function\" == c || \"object\" == c && null !== b ? b.$$hashKey = c + \":\" + (a || Fd)() : c + \":\" + b;\n  }\n  function eb(b, a) {\n    if (a) {\n      var c = 0;\n      this.nextUid = function() {\n        return ++c;\n      };\n    }\n    r(b, this.put, this);\n  }\n  function mf(b) {\n    return (b = b.toString().replace(Qc, \"\").match(Rc)) ? \"function(\" + (b[1] || \"\").replace(/[\\s\\r\\n]+/, \" \") + \")\" : \"fn\";\n  }\n  function ab(b, a) {\n    function c(a) {\n      return function(b, c) {\n        if (J(b))\n          r(b, mc(a));\n        else\n          return a(b, c);\n      };\n    }\n    function d(a, b) {\n      La(a, \"service\");\n      if (G(b) || H(b))\n        b = q.instantiate(b);\n      if (!b.$get)\n        throw Fa(\"pget\", a);\n      return p[a + \"Provider\"] = b;\n    }\n    function e(a, b) {\n      return function() {\n        var c = s.invoke(b, this);\n        if (x(c))\n          throw Fa(\"undef\", a);\n        return c;\n      };\n    }\n    function f(a, b, c) {\n      return d(a, {$get: !1 !== c ? e(a, b) : b});\n    }\n    function g(a) {\n      var b = [],\n          c;\n      r(a, function(a) {\n        function d(a) {\n          var b,\n              c;\n          b = 0;\n          for (c = a.length; b < c; b++) {\n            var e = a[b],\n                f = q.get(e[0]);\n            f[e[1]].apply(f, e[2]);\n          }\n        }\n        if (!n.get(a)) {\n          n.put(a, !0);\n          try {\n            C(a) ? (c = cb(a), b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), d(c._configBlocks)) : G(a) ? b.push(q.invoke(a)) : H(a) ? b.push(q.invoke(a)) : sb(a, \"module\");\n          } catch (e) {\n            throw H(a) && (a = a[a.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + \"\\n\" + e.stack), Fa(\"modulerr\", a, e.stack || e.message || e);\n          }\n        }\n      });\n      return b;\n    }\n    function h(b, c) {\n      function d(a, e) {\n        if (b.hasOwnProperty(a)) {\n          if (b[a] === l)\n            throw Fa(\"cdep\", a + \" <- \" + k.join(\" <- \"));\n          return b[a];\n        }\n        try {\n          return k.unshift(a), b[a] = l, b[a] = c(a, e);\n        } catch (f) {\n          throw b[a] === l && delete b[a], f;\n        } finally {\n          k.shift();\n        }\n      }\n      function e(b, c, f, g) {\n        \"string\" === typeof f && (g = f, f = null);\n        var k = [],\n            h = ab.$$annotate(b, a, g),\n            l,\n            q,\n            p;\n        q = 0;\n        for (l = h.length; q < l; q++) {\n          p = h[q];\n          if (\"string\" !== typeof p)\n            throw Fa(\"itkn\", p);\n          k.push(f && f.hasOwnProperty(p) ? f[p] : d(p, g));\n        }\n        H(b) && (b = b[l]);\n        return b.apply(c, k);\n      }\n      return {\n        invoke: e,\n        instantiate: function(a, b, c) {\n          var d = Object.create((H(a) ? a[a.length - 1] : a).prototype || null);\n          a = e(a, d, b, c);\n          return J(a) || G(a) ? a : d;\n        },\n        get: d,\n        annotate: ab.$$annotate,\n        has: function(a) {\n          return p.hasOwnProperty(a + \"Provider\") || b.hasOwnProperty(a);\n        }\n      };\n    }\n    a = !0 === a;\n    var l = {},\n        k = [],\n        n = new eb([], !0),\n        p = {$provide: {\n            provider: c(d),\n            factory: c(f),\n            service: c(function(a, b) {\n              return f(a, [\"$injector\", function(a) {\n                return a.instantiate(b);\n              }]);\n            }),\n            value: c(function(a, b) {\n              return f(a, ea(b), !1);\n            }),\n            constant: c(function(a, b) {\n              La(a, \"constant\");\n              p[a] = b;\n              u[a] = b;\n            }),\n            decorator: function(a, b) {\n              var c = q.get(a + \"Provider\"),\n                  d = c.$get;\n              c.$get = function() {\n                var a = s.invoke(d, c);\n                return s.invoke(b, null, {$delegate: a});\n              };\n            }\n          }},\n        q = p.$injector = h(p, function(a, b) {\n          ca.isString(b) && k.push(b);\n          throw Fa(\"unpr\", k.join(\" <- \"));\n        }),\n        u = {},\n        s = u.$injector = h(u, function(a, b) {\n          var c = q.get(a + \"Provider\", b);\n          return s.invoke(c.$get, c, t, a);\n        });\n    r(g(b), function(a) {\n      s.invoke(a || E);\n    });\n    return s;\n  }\n  function Be() {\n    var b = !0;\n    this.disableAutoScrolling = function() {\n      b = !1;\n    };\n    this.$get = [\"$window\", \"$location\", \"$rootScope\", function(a, c, d) {\n      function e(a) {\n        var b = null;\n        Array.prototype.some.call(a, function(a) {\n          if (\"a\" === va(a))\n            return b = a, !0;\n        });\n        return b;\n      }\n      function f(b) {\n        if (b) {\n          b.scrollIntoView();\n          var c;\n          c = g.yOffset;\n          G(c) ? c = c() : oc(c) ? (c = c[0], c = \"fixed\" !== a.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Y(c) || (c = 0);\n          c && (b = b.getBoundingClientRect().top, a.scrollBy(0, b - c));\n        } else\n          a.scrollTo(0, 0);\n      }\n      function g() {\n        var a = c.hash(),\n            b;\n        a ? (b = h.getElementById(a)) ? f(b) : (b = e(h.getElementsByName(a))) ? f(b) : \"top\" === a && f(null) : f(null);\n      }\n      var h = a.document;\n      b && d.$watch(function() {\n        return c.hash();\n      }, function(a, b) {\n        a === b && \"\" === a || jf(function() {\n          d.$evalAsync(g);\n        });\n      });\n      return g;\n    }];\n  }\n  function af() {\n    this.$get = [\"$$rAF\", \"$timeout\", function(b, a) {\n      return b.supported ? function(a) {\n        return b(a);\n      } : function(b) {\n        return a(b, 0, !1);\n      };\n    }];\n  }\n  function nf(b, a, c, d) {\n    function e(a) {\n      try {\n        a.apply(null, Za.call(arguments, 1));\n      } finally {\n        if (m--, 0 === m)\n          for (; F.length; )\n            try {\n              F.pop()();\n            } catch (b) {\n              c.error(b);\n            }\n      }\n    }\n    function f(a, b) {\n      (function da() {\n        r(Z, function(a) {\n          a();\n        });\n        L = b(da, a);\n      })();\n    }\n    function g() {\n      h();\n      l();\n    }\n    function h() {\n      a: {\n        try {\n          B = u.state;\n          break a;\n        } catch (a) {}\n        B = void 0;\n      }\n      B = x(B) ? null : B;\n      ha(B, O) && (B = O);\n      O = B;\n    }\n    function l() {\n      if (D !== n.url() || I !== B)\n        D = n.url(), I = B, r(X, function(a) {\n          a(n.url(), B);\n        });\n    }\n    function k(a) {\n      try {\n        return decodeURIComponent(a);\n      } catch (b) {\n        return a;\n      }\n    }\n    var n = this,\n        p = a[0],\n        q = b.location,\n        u = b.history,\n        s = b.setTimeout,\n        M = b.clearTimeout,\n        v = {};\n    n.isMock = !1;\n    var m = 0,\n        F = [];\n    n.$$completeOutstandingRequest = e;\n    n.$$incOutstandingRequestCount = function() {\n      m++;\n    };\n    n.notifyWhenNoOutstandingRequests = function(a) {\n      r(Z, function(a) {\n        a();\n      });\n      0 === m ? a() : F.push(a);\n    };\n    var Z = [],\n        L;\n    n.addPollFn = function(a) {\n      x(L) && f(100, s);\n      Z.push(a);\n      return a;\n    };\n    var B,\n        I,\n        D = q.href,\n        S = a.find(\"base\"),\n        P = null;\n    h();\n    I = B;\n    n.url = function(a, c, e) {\n      x(e) && (e = null);\n      q !== b.location && (q = b.location);\n      u !== b.history && (u = b.history);\n      if (a) {\n        var f = I === e;\n        if (D === a && (!d.history || f))\n          return n;\n        var g = D && Ga(D) === Ga(a);\n        D = a;\n        I = e;\n        !d.history || g && f ? (g || (P = a), c ? q.replace(a) : g ? (c = q, e = a.indexOf(\"#\"), a = -1 === e ? \"\" : a.substr(e + 1), c.hash = a) : q.href = a) : (u[c ? \"replaceState\" : \"pushState\"](e, \"\", a), h(), I = B);\n        return n;\n      }\n      return P || q.href.replace(/%27/g, \"'\");\n    };\n    n.state = function() {\n      return B;\n    };\n    var X = [],\n        ba = !1,\n        O = null;\n    n.onUrlChange = function(a) {\n      if (!ba) {\n        if (d.history)\n          A(b).on(\"popstate\", g);\n        A(b).on(\"hashchange\", g);\n        ba = !0;\n      }\n      X.push(a);\n      return a;\n    };\n    n.$$checkUrlChange = l;\n    n.baseHref = function() {\n      var a = S.attr(\"href\");\n      return a ? a.replace(/^(https?\\:)?\\/\\/[^\\/]*/, \"\") : \"\";\n    };\n    var fa = {},\n        y = \"\",\n        ka = n.baseHref();\n    n.cookies = function(a, b) {\n      var d,\n          e,\n          f,\n          g;\n      if (a)\n        b === t ? p.cookie = encodeURIComponent(a) + \"=;path=\" + ka + \";expires=Thu, 01 Jan 1970 00:00:00 GMT\" : C(b) && (d = (p.cookie = encodeURIComponent(a) + \"=\" + encodeURIComponent(b) + \";path=\" + ka).length + 1, 4096 < d && c.warn(\"Cookie '\" + a + \"' possibly not set or overflowed because it was too large (\" + d + \" > 4096 bytes)!\"));\n      else {\n        if (p.cookie !== y)\n          for (y = p.cookie, d = y.split(\"; \"), fa = {}, f = 0; f < d.length; f++)\n            e = d[f], g = e.indexOf(\"=\"), 0 < g && (a = k(e.substring(0, g)), fa[a] === t && (fa[a] = k(e.substring(g + 1))));\n        return fa;\n      }\n    };\n    n.defer = function(a, b) {\n      var c;\n      m++;\n      c = s(function() {\n        delete v[c];\n        e(a);\n      }, b || 0);\n      v[c] = !0;\n      return c;\n    };\n    n.defer.cancel = function(a) {\n      return v[a] ? (delete v[a], M(a), e(E), !0) : !1;\n    };\n  }\n  function De() {\n    this.$get = [\"$window\", \"$log\", \"$sniffer\", \"$document\", function(b, a, c, d) {\n      return new nf(b, d, a, c);\n    }];\n  }\n  function Ee() {\n    this.$get = function() {\n      function b(b, d) {\n        function e(a) {\n          a != p && (q ? q == a && (q = a.n) : q = a, f(a.n, a.p), f(a, p), p = a, p.n = null);\n        }\n        function f(a, b) {\n          a != b && (a && (a.p = b), b && (b.n = a));\n        }\n        if (b in a)\n          throw R(\"$cacheFactory\")(\"iid\", b);\n        var g = 0,\n            h = w({}, d, {id: b}),\n            l = {},\n            k = d && d.capacity || Number.MAX_VALUE,\n            n = {},\n            p = null,\n            q = null;\n        return a[b] = {\n          put: function(a, b) {\n            if (k < Number.MAX_VALUE) {\n              var c = n[a] || (n[a] = {key: a});\n              e(c);\n            }\n            if (!x(b))\n              return a in l || g++, l[a] = b, g > k && this.remove(q.key), b;\n          },\n          get: function(a) {\n            if (k < Number.MAX_VALUE) {\n              var b = n[a];\n              if (!b)\n                return;\n              e(b);\n            }\n            return l[a];\n          },\n          remove: function(a) {\n            if (k < Number.MAX_VALUE) {\n              var b = n[a];\n              if (!b)\n                return;\n              b == p && (p = b.p);\n              b == q && (q = b.n);\n              f(b.n, b.p);\n              delete n[a];\n            }\n            delete l[a];\n            g--;\n          },\n          removeAll: function() {\n            l = {};\n            g = 0;\n            n = {};\n            p = q = null;\n          },\n          destroy: function() {\n            n = h = l = null;\n            delete a[b];\n          },\n          info: function() {\n            return w({}, h, {size: g});\n          }\n        };\n      }\n      var a = {};\n      b.info = function() {\n        var b = {};\n        r(a, function(a, e) {\n          b[e] = a.info();\n        });\n        return b;\n      };\n      b.get = function(b) {\n        return a[b];\n      };\n      return b;\n    };\n  }\n  function Ve() {\n    this.$get = [\"$cacheFactory\", function(b) {\n      return b(\"templates\");\n    }];\n  }\n  function yc(b, a) {\n    function c(a, b) {\n      var c = /^\\s*([@&]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/,\n          d = {};\n      r(a, function(a, e) {\n        var f = a.match(c);\n        if (!f)\n          throw la(\"iscp\", b, e, a);\n        d[e] = {\n          mode: f[1][0],\n          collection: \"*\" === f[2],\n          optional: \"?\" === f[3],\n          attrName: f[4] || e\n        };\n      });\n      return d;\n    }\n    var d = {},\n        e = /^\\s*directive\\:\\s*([\\w\\-]+)\\s+(.*)$/,\n        f = /(([\\w\\-]+)(?:\\:([^;]+))?;?)/,\n        g = Gd(\"ngSrc,ngSrcset,src,srcset\"),\n        h = /^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/,\n        l = /^(on[a-z]+|formaction)$/;\n    this.directive = function p(a, e) {\n      La(a, \"directive\");\n      C(a) ? (Rb(e, \"directiveFactory\"), d.hasOwnProperty(a) || (d[a] = [], b.factory(a + \"Directive\", [\"$injector\", \"$exceptionHandler\", function(b, e) {\n        var f = [];\n        r(d[a], function(d, g) {\n          try {\n            var h = b.invoke(d);\n            G(h) ? h = {compile: ea(h)} : !h.compile && h.link && (h.compile = ea(h.link));\n            h.priority = h.priority || 0;\n            h.index = g;\n            h.name = h.name || a;\n            h.require = h.require || h.controller && h.name;\n            h.restrict = h.restrict || \"EA\";\n            J(h.scope) && (h.$$isolateBindings = c(h.scope, h.name));\n            f.push(h);\n          } catch (k) {\n            e(k);\n          }\n        });\n        return f;\n      }])), d[a].push(e)) : r(a, mc(p));\n      return this;\n    };\n    this.aHrefSanitizationWhitelist = function(b) {\n      return y(b) ? (a.aHrefSanitizationWhitelist(b), this) : a.aHrefSanitizationWhitelist();\n    };\n    this.imgSrcSanitizationWhitelist = function(b) {\n      return y(b) ? (a.imgSrcSanitizationWhitelist(b), this) : a.imgSrcSanitizationWhitelist();\n    };\n    var k = !0;\n    this.debugInfoEnabled = function(a) {\n      return y(a) ? (k = a, this) : k;\n    };\n    this.$get = [\"$injector\", \"$interpolate\", \"$exceptionHandler\", \"$templateRequest\", \"$parse\", \"$controller\", \"$rootScope\", \"$document\", \"$sce\", \"$animate\", \"$$sanitizeUri\", function(a, b, c, s, M, v, m, F, Z, L, B) {\n      function I(a, b) {\n        try {\n          a.addClass(b);\n        } catch (c) {}\n      }\n      function D(a, b, c, d, e) {\n        a instanceof A || (a = A(a));\n        r(a, function(b, c) {\n          b.nodeType == pb && b.nodeValue.match(/\\S+/) && (a[c] = A(b).wrap(\"<span></span>\").parent()[0]);\n        });\n        var f = S(a, b, a, c, d, e);\n        D.$$addScopeClass(a);\n        var g = null;\n        return function(b, c, d) {\n          Rb(b, \"scope\");\n          d = d || {};\n          var e = d.parentBoundTranscludeFn,\n              h = d.transcludeControllers;\n          d = d.futureParentElement;\n          e && e.$$boundTransclude && (e = e.$$boundTransclude);\n          g || (g = (d = d && d[0]) ? \"foreignobject\" !== va(d) && d.toString().match(/SVG/) ? \"svg\" : \"html\" : \"html\");\n          d = \"html\" !== g ? A(Xb(g, A(\"<div>\").append(a).html())) : c ? Ka.clone.call(a) : a;\n          if (h)\n            for (var k in h)\n              d.data(\"$\" + k + \"Controller\", h[k].instance);\n          D.$$addScopeInfo(d, b);\n          c && c(d, b);\n          f && f(b, d, d, e);\n          return d;\n        };\n      }\n      function S(a, b, c, d, e, f) {\n        function g(a, c, d, e) {\n          var f,\n              k,\n              l,\n              q,\n              p,\n              s,\n              M;\n          if (m)\n            for (M = Array(c.length), q = 0; q < h.length; q += 3)\n              f = h[q], M[f] = c[f];\n          else\n            M = c;\n          q = 0;\n          for (p = h.length; q < p; )\n            k = M[h[q++]], c = h[q++], f = h[q++], c ? (c.scope ? (l = a.$new(), D.$$addScopeInfo(A(k), l)) : l = a, s = c.transcludeOnThisElement ? P(a, c.transclude, e, c.elementTranscludeOnThisElement) : !c.templateOnThisElement && e ? e : !e && b ? P(a, b) : null, c(f, l, k, d, s)) : f && f(a, k.childNodes, t, e);\n        }\n        for (var h = [],\n            k,\n            l,\n            q,\n            p,\n            m,\n            s = 0; s < a.length; s++) {\n          k = new Yb;\n          l = X(a[s], [], k, 0 === s ? d : t, e);\n          (f = l.length ? fa(l, a[s], k, b, c, null, [], [], f) : null) && f.scope && D.$$addScopeClass(k.$$element);\n          k = f && f.terminal || !(q = a[s].childNodes) || !q.length ? null : S(q, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b);\n          if (f || k)\n            h.push(s, f, k), p = !0, m = m || f;\n          f = null;\n        }\n        return p ? g : null;\n      }\n      function P(a, b, c, d) {\n        return function(d, e, f, g, h) {\n          d || (d = a.$new(!1, h), d.$$transcluded = !0);\n          return b(d, e, {\n            parentBoundTranscludeFn: c,\n            transcludeControllers: f,\n            futureParentElement: g\n          });\n        };\n      }\n      function X(a, b, c, d, g) {\n        var h = c.$attr,\n            k;\n        switch (a.nodeType) {\n          case qa:\n            ka(b, xa(va(a)), \"E\", d, g);\n            for (var l,\n                q,\n                p,\n                m = a.attributes,\n                s = 0,\n                M = m && m.length; s < M; s++) {\n              var u = !1,\n                  L = !1;\n              l = m[s];\n              k = l.name;\n              q = N(l.value);\n              l = xa(k);\n              if (p = U.test(l))\n                k = k.replace(Sc, \"\").substr(8).replace(/_(.)/g, function(a, b) {\n                  return b.toUpperCase();\n                });\n              var B = l.replace(/(Start|End)$/, \"\");\n              x(B) && l === B + \"Start\" && (u = k, L = k.substr(0, k.length - 5) + \"end\", k = k.substr(0, k.length - 6));\n              l = xa(k.toLowerCase());\n              h[l] = k;\n              if (p || !c.hasOwnProperty(l))\n                c[l] = q, Nc(a, l) && (c[l] = !0);\n              Oa(a, b, q, l, p);\n              ka(b, l, \"A\", d, g, u, L);\n            }\n            a = a.className;\n            J(a) && (a = a.animVal);\n            if (C(a) && \"\" !== a)\n              for (; k = f.exec(a); )\n                l = xa(k[2]), ka(b, l, \"C\", d, g) && (c[l] = N(k[3])), a = a.substr(k.index + k[0].length);\n            break;\n          case pb:\n            za(b, a.nodeValue);\n            break;\n          case 8:\n            try {\n              if (k = e.exec(a.nodeValue))\n                l = xa(k[1]), ka(b, l, \"M\", d, g) && (c[l] = N(k[2]));\n            } catch (v) {}\n        }\n        b.sort(da);\n        return b;\n      }\n      function ba(a, b, c) {\n        var d = [],\n            e = 0;\n        if (b && a.hasAttribute && a.hasAttribute(b)) {\n          do {\n            if (!a)\n              throw la(\"uterdir\", b, c);\n            a.nodeType == qa && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--);\n            d.push(a);\n            a = a.nextSibling;\n          } while (0 < e);\n        } else\n          d.push(a);\n        return A(d);\n      }\n      function O(a, b, c) {\n        return function(d, e, f, g, h) {\n          e = ba(e[0], b, c);\n          return a(d, e, f, g, h);\n        };\n      }\n      function fa(a, d, e, f, g, k, l, p, m) {\n        function s(a, b, c, d) {\n          if (a) {\n            c && (a = O(a, c, d));\n            a.require = K.require;\n            a.directiveName = da;\n            if (P === K || K.$$isolateScope)\n              a = Y(a, {isolateScope: !0});\n            l.push(a);\n          }\n          if (b) {\n            c && (b = O(b, c, d));\n            b.require = K.require;\n            b.directiveName = da;\n            if (P === K || K.$$isolateScope)\n              b = Y(b, {isolateScope: !0});\n            p.push(b);\n          }\n        }\n        function L(a, b, c, d) {\n          var e,\n              f = \"data\",\n              g = !1,\n              k = c,\n              l;\n          if (C(b)) {\n            l = b.match(h);\n            b = b.substring(l[0].length);\n            l[3] && (l[1] ? l[3] = null : l[1] = l[3]);\n            \"^\" === l[1] ? f = \"inheritedData\" : \"^^\" === l[1] && (f = \"inheritedData\", k = c.parent());\n            \"?\" === l[2] && (g = !0);\n            e = null;\n            d && \"data\" === f && (e = d[b]) && (e = e.instance);\n            e = e || k[f](\"$\" + b + \"Controller\");\n            if (!e && !g)\n              throw la(\"ctreq\", b, a);\n            return e || null;\n          }\n          H(b) && (e = [], r(b, function(b) {\n            e.push(L(a, b, c, d));\n          }));\n          return e;\n        }\n        function B(a, c, f, g, h) {\n          function k(a, b, c) {\n            var d;\n            Va(a) || (c = b, b = a, a = t);\n            E && (d = F);\n            c || (c = E ? X.parent() : X);\n            return h(a, b, d, c, Wb);\n          }\n          var m,\n              s,\n              u,\n              I,\n              F,\n              gb,\n              X,\n              O;\n          d === f ? (O = e, X = e.$$element) : (X = A(f), O = new Yb(X, e));\n          P && (I = c.$new(!0));\n          h && (gb = k, gb.$$boundTransclude = h);\n          S && (Z = {}, F = {}, r(S, function(a) {\n            var b = {\n              $scope: a === P || a.$$isolateScope ? I : c,\n              $element: X,\n              $attrs: O,\n              $transclude: gb\n            };\n            u = a.controller;\n            \"@\" == u && (u = O[a.name]);\n            b = v(u, b, !0, a.controllerAs);\n            F[a.name] = b;\n            E || X.data(\"$\" + a.name + \"Controller\", b.instance);\n            Z[a.name] = b;\n          }));\n          if (P) {\n            D.$$addScopeInfo(X, I, !0, !(ma && (ma === P || ma === P.$$originalDirective)));\n            D.$$addScopeClass(X, !0);\n            g = Z && Z[P.name];\n            var ba = I;\n            g && g.identifier && !0 === P.bindToController && (ba = g.instance);\n            r(I.$$isolateBindings = P.$$isolateBindings, function(a, d) {\n              var e = a.attrName,\n                  f = a.optional,\n                  g,\n                  h,\n                  k,\n                  l;\n              switch (a.mode) {\n                case \"@\":\n                  O.$observe(e, function(a) {\n                    ba[d] = a;\n                  });\n                  O.$$observers[e].$$scope = c;\n                  O[e] && (ba[d] = b(O[e])(c));\n                  break;\n                case \"=\":\n                  if (f && !O[e])\n                    break;\n                  h = M(O[e]);\n                  l = h.literal ? ha : function(a, b) {\n                    return a === b || a !== a && b !== b;\n                  };\n                  k = h.assign || function() {\n                    g = ba[d] = h(c);\n                    throw la(\"nonassign\", O[e], P.name);\n                  };\n                  g = ba[d] = h(c);\n                  f = function(a) {\n                    l(a, ba[d]) || (l(a, g) ? k(c, a = ba[d]) : ba[d] = a);\n                    return g = a;\n                  };\n                  f.$stateful = !0;\n                  f = a.collection ? c.$watchCollection(O[e], f) : c.$watch(M(O[e], f), null, h.literal);\n                  I.$on(\"$destroy\", f);\n                  break;\n                case \"&\":\n                  h = M(O[e]), ba[d] = function(a) {\n                    return h(c, a);\n                  };\n              }\n            });\n          }\n          Z && (r(Z, function(a) {\n            a();\n          }), Z = null);\n          g = 0;\n          for (m = l.length; g < m; g++)\n            s = l[g], $(s, s.isolateScope ? I : c, X, O, s.require && L(s.directiveName, s.require, X, F), gb);\n          var Wb = c;\n          P && (P.template || null === P.templateUrl) && (Wb = I);\n          a && a(Wb, f.childNodes, t, h);\n          for (g = p.length - 1; 0 <= g; g--)\n            s = p[g], $(s, s.isolateScope ? I : c, X, O, s.require && L(s.directiveName, s.require, X, F), gb);\n        }\n        m = m || {};\n        for (var I = -Number.MAX_VALUE,\n            F,\n            S = m.controllerDirectives,\n            Z,\n            P = m.newIsolateScopeDirective,\n            ma = m.templateDirective,\n            fa = m.nonTlbTranscludeDirective,\n            ka = !1,\n            x = !1,\n            E = m.hasElementTranscludeDirective,\n            w = e.$$element = A(d),\n            K,\n            da,\n            V,\n            fb = f,\n            za,\n            z = 0,\n            Q = a.length; z < Q; z++) {\n          K = a[z];\n          var Oa = K.$$start,\n              U = K.$$end;\n          Oa && (w = ba(d, Oa, U));\n          V = t;\n          if (I > K.priority)\n            break;\n          if (V = K.scope)\n            K.templateUrl || (J(V) ? (Na(\"new/isolated scope\", P || F, K, w), P = K) : Na(\"new/isolated scope\", P, K, w)), F = F || K;\n          da = K.name;\n          !K.templateUrl && K.controller && (V = K.controller, S = S || {}, Na(\"'\" + da + \"' controller\", S[da], K, w), S[da] = K);\n          if (V = K.transclude)\n            ka = !0, K.$$tlb || (Na(\"transclusion\", fa, K, w), fa = K), \"element\" == V ? (E = !0, I = K.priority, V = w, w = e.$$element = A(W.createComment(\" \" + da + \": \" + e[da] + \" \")), d = w[0], T(g, Za.call(V, 0), d), fb = D(V, f, I, k && k.name, {nonTlbTranscludeDirective: fa})) : (V = A(Ub(d)).contents(), w.empty(), fb = D(V, f));\n          if (K.template)\n            if (x = !0, Na(\"template\", ma, K, w), ma = K, V = G(K.template) ? K.template(w, e) : K.template, V = Tc(V), K.replace) {\n              k = K;\n              V = Sb.test(V) ? Uc(Xb(K.templateNamespace, N(V))) : [];\n              d = V[0];\n              if (1 != V.length || d.nodeType !== qa)\n                throw la(\"tplrt\", da, \"\");\n              T(g, w, d);\n              Q = {$attr: {}};\n              V = X(d, [], Q);\n              var aa = a.splice(z + 1, a.length - (z + 1));\n              P && y(V);\n              a = a.concat(V).concat(aa);\n              R(e, Q);\n              Q = a.length;\n            } else\n              w.html(V);\n          if (K.templateUrl)\n            x = !0, Na(\"template\", ma, K, w), ma = K, K.replace && (k = K), B = of(a.splice(z, a.length - z), w, e, g, ka && fb, l, p, {\n              controllerDirectives: S,\n              newIsolateScopeDirective: P,\n              templateDirective: ma,\n              nonTlbTranscludeDirective: fa\n            }), Q = a.length;\n          else if (K.compile)\n            try {\n              za = K.compile(w, e, fb), G(za) ? s(null, za, Oa, U) : za && s(za.pre, za.post, Oa, U);\n            } catch (pf) {\n              c(pf, wa(w));\n            }\n          K.terminal && (B.terminal = !0, I = Math.max(I, K.priority));\n        }\n        B.scope = F && !0 === F.scope;\n        B.transcludeOnThisElement = ka;\n        B.elementTranscludeOnThisElement = E;\n        B.templateOnThisElement = x;\n        B.transclude = fb;\n        m.hasElementTranscludeDirective = E;\n        return B;\n      }\n      function y(a) {\n        for (var b = 0,\n            c = a.length; b < c; b++)\n          a[b] = Ob(a[b], {$$isolateScope: !0});\n      }\n      function ka(b, e, f, g, h, k, l) {\n        if (e === h)\n          return null;\n        h = null;\n        if (d.hasOwnProperty(e)) {\n          var q;\n          e = a.get(e + \"Directive\");\n          for (var m = 0,\n              s = e.length; m < s; m++)\n            try {\n              q = e[m], (g === t || g > q.priority) && -1 != q.restrict.indexOf(f) && (k && (q = Ob(q, {\n                $$start: k,\n                $$end: l\n              })), b.push(q), h = q);\n            } catch (M) {\n              c(M);\n            }\n        }\n        return h;\n      }\n      function x(b) {\n        if (d.hasOwnProperty(b))\n          for (var c = a.get(b + \"Directive\"),\n              e = 0,\n              f = c.length; e < f; e++)\n            if (b = c[e], b.multiElement)\n              return !0;\n        return !1;\n      }\n      function R(a, b) {\n        var c = b.$attr,\n            d = a.$attr,\n            e = a.$$element;\n        r(a, function(d, e) {\n          \"$\" != e.charAt(0) && (b[e] && b[e] !== d && (d += (\"style\" === e ? \";\" : \" \") + b[e]), a.$set(e, d, !0, c[e]));\n        });\n        r(b, function(b, f) {\n          \"class\" == f ? (I(e, b), a[\"class\"] = (a[\"class\"] ? a[\"class\"] + \" \" : \"\") + b) : \"style\" == f ? (e.attr(\"style\", e.attr(\"style\") + \";\" + b), a.style = (a.style ? a.style + \";\" : \"\") + b) : \"$\" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, d[f] = c[f]);\n        });\n      }\n      function of(a, b, c, d, e, f, g, h) {\n        var k = [],\n            l,\n            q,\n            p = b[0],\n            m = a.shift(),\n            M = Ob(m, {\n              templateUrl: null,\n              transclude: null,\n              replace: null,\n              $$originalDirective: m\n            }),\n            u = G(m.templateUrl) ? m.templateUrl(b, c) : m.templateUrl,\n            L = m.templateNamespace;\n        b.empty();\n        s(Z.getTrustedResourceUrl(u)).then(function(s) {\n          var B,\n              v;\n          s = Tc(s);\n          if (m.replace) {\n            s = Sb.test(s) ? Uc(Xb(L, N(s))) : [];\n            B = s[0];\n            if (1 != s.length || B.nodeType !== qa)\n              throw la(\"tplrt\", m.name, u);\n            s = {$attr: {}};\n            T(d, b, B);\n            var D = X(B, [], s);\n            J(m.scope) && y(D);\n            a = D.concat(a);\n            R(c, s);\n          } else\n            B = p, b.html(s);\n          a.unshift(M);\n          l = fa(a, B, c, e, b, m, f, g, h);\n          r(d, function(a, c) {\n            a == B && (d[c] = b[0]);\n          });\n          for (q = S(b[0].childNodes, e); k.length; ) {\n            s = k.shift();\n            v = k.shift();\n            var F = k.shift(),\n                O = k.shift(),\n                D = b[0];\n            if (!s.$$destroyed) {\n              if (v !== p) {\n                var Z = v.className;\n                h.hasElementTranscludeDirective && m.replace || (D = Ub(B));\n                T(F, A(v), D);\n                I(A(D), Z);\n              }\n              v = l.transcludeOnThisElement ? P(s, l.transclude, O) : O;\n              l(q, s, D, d, v);\n            }\n          }\n          k = null;\n        });\n        return function(a, b, c, d, e) {\n          a = e;\n          b.$$destroyed || (k ? k.push(b, c, d, a) : (l.transcludeOnThisElement && (a = P(b, l.transclude, e)), l(q, b, c, d, a)));\n        };\n      }\n      function da(a, b) {\n        var c = b.priority - a.priority;\n        return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;\n      }\n      function Na(a, b, c, d) {\n        if (b)\n          throw la(\"multidir\", b.name, c.name, a, wa(d));\n      }\n      function za(a, c) {\n        var d = b(c, !0);\n        d && a.push({\n          priority: 0,\n          compile: function(a) {\n            a = a.parent();\n            var b = !!a.length;\n            b && D.$$addBindingClass(a);\n            return function(a, c) {\n              var e = c.parent();\n              b || D.$$addBindingClass(e);\n              D.$$addBindingInfo(e, d.expressions);\n              a.$watch(d, function(a) {\n                c[0].nodeValue = a;\n              });\n            };\n          }\n        });\n      }\n      function Xb(a, b) {\n        a = z(a || \"html\");\n        switch (a) {\n          case \"svg\":\n          case \"math\":\n            var c = W.createElement(\"div\");\n            c.innerHTML = \"<\" + a + \">\" + b + \"</\" + a + \">\";\n            return c.childNodes[0].childNodes;\n          default:\n            return b;\n        }\n      }\n      function Q(a, b) {\n        if (\"srcdoc\" == b)\n          return Z.HTML;\n        var c = va(a);\n        if (\"xlinkHref\" == b || \"form\" == c && \"action\" == b || \"img\" != c && (\"src\" == b || \"ngSrc\" == b))\n          return Z.RESOURCE_URL;\n      }\n      function Oa(a, c, d, e, f) {\n        var h = Q(a, e);\n        f = g[e] || f;\n        var k = b(d, !0, h, f);\n        if (k) {\n          if (\"multiple\" === e && \"select\" === va(a))\n            throw la(\"selmulti\", wa(a));\n          c.push({\n            priority: 100,\n            compile: function() {\n              return {pre: function(a, c, g) {\n                  c = g.$$observers || (g.$$observers = {});\n                  if (l.test(e))\n                    throw la(\"nodomevents\");\n                  var m = g[e];\n                  m !== d && (k = m && b(m, !0, h, f), d = m);\n                  k && (g[e] = k(a), (c[e] || (c[e] = [])).$$inter = !0, (g.$$observers && g.$$observers[e].$$scope || a).$watch(k, function(a, b) {\n                    \"class\" === e && a != b ? g.$updateClass(a, b) : g.$set(e, a);\n                  }));\n                }};\n            }\n          });\n        }\n      }\n      function T(a, b, c) {\n        var d = b[0],\n            e = b.length,\n            f = d.parentNode,\n            g,\n            h;\n        if (a)\n          for (g = 0, h = a.length; g < h; g++)\n            if (a[g] == d) {\n              a[g++] = c;\n              h = g + e - 1;\n              for (var k = a.length; g < k; g++, h++)\n                h < k ? a[g] = a[h] : delete a[g];\n              a.length -= e - 1;\n              a.context === d && (a.context = c);\n              break;\n            }\n        f && f.replaceChild(c, d);\n        a = W.createDocumentFragment();\n        a.appendChild(d);\n        A(c).data(A(d).data());\n        ta ? (Qb = !0, ta.cleanData([d])) : delete A.cache[d[A.expando]];\n        d = 1;\n        for (e = b.length; d < e; d++)\n          f = b[d], A(f).remove(), a.appendChild(f), delete b[d];\n        b[0] = c;\n        b.length = 1;\n      }\n      function Y(a, b) {\n        return w(function() {\n          return a.apply(null, arguments);\n        }, a, b);\n      }\n      function $(a, b, d, e, f, g) {\n        try {\n          a(b, d, e, f, g);\n        } catch (h) {\n          c(h, wa(d));\n        }\n      }\n      var Yb = function(a, b) {\n        if (b) {\n          var c = Object.keys(b),\n              d,\n              e,\n              f;\n          d = 0;\n          for (e = c.length; d < e; d++)\n            f = c[d], this[f] = b[f];\n        } else\n          this.$attr = {};\n        this.$$element = a;\n      };\n      Yb.prototype = {\n        $normalize: xa,\n        $addClass: function(a) {\n          a && 0 < a.length && L.addClass(this.$$element, a);\n        },\n        $removeClass: function(a) {\n          a && 0 < a.length && L.removeClass(this.$$element, a);\n        },\n        $updateClass: function(a, b) {\n          var c = Vc(a, b);\n          c && c.length && L.addClass(this.$$element, c);\n          (c = Vc(b, a)) && c.length && L.removeClass(this.$$element, c);\n        },\n        $set: function(a, b, d, e) {\n          var f = this.$$element[0],\n              g = Nc(f, a),\n              h = kf(f, a),\n              f = a;\n          g ? (this.$$element.prop(a, b), e = g) : h && (this[h] = b, f = h);\n          this[a] = b;\n          e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = vc(a, \"-\"));\n          g = va(this.$$element);\n          if (\"a\" === g && \"href\" === a || \"img\" === g && \"src\" === a)\n            this[a] = b = B(b, \"src\" === a);\n          else if (\"img\" === g && \"srcset\" === a) {\n            for (var g = \"\",\n                h = N(b),\n                k = /(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/,\n                k = /\\s/.test(h) ? k : /(,)/,\n                h = h.split(k),\n                k = Math.floor(h.length / 2),\n                l = 0; l < k; l++)\n              var q = 2 * l,\n                  g = g + B(N(h[q]), !0),\n                  g = g + (\" \" + N(h[q + 1]));\n            h = N(h[2 * l]).split(/\\s/);\n            g += B(N(h[0]), !0);\n            2 === h.length && (g += \" \" + N(h[1]));\n            this[a] = b = g;\n          }\n          !1 !== d && (null === b || b === t ? this.$$element.removeAttr(e) : this.$$element.attr(e, b));\n          (a = this.$$observers) && r(a[f], function(a) {\n            try {\n              a(b);\n            } catch (d) {\n              c(d);\n            }\n          });\n        },\n        $observe: function(a, b) {\n          var c = this,\n              d = c.$$observers || (c.$$observers = ia()),\n              e = d[a] || (d[a] = []);\n          e.push(b);\n          m.$evalAsync(function() {\n            !e.$$inter && c.hasOwnProperty(a) && b(c[a]);\n          });\n          return function() {\n            Xa(e, b);\n          };\n        }\n      };\n      var V = b.startSymbol(),\n          ma = b.endSymbol(),\n          Tc = \"{{\" == V || \"}}\" == ma ? ra : function(a) {\n            return a.replace(/\\{\\{/g, V).replace(/}}/g, ma);\n          },\n          U = /^ngAttr[A-Z]/;\n      D.$$addBindingInfo = k ? function(a, b) {\n        var c = a.data(\"$binding\") || [];\n        H(b) ? c = c.concat(b) : c.push(b);\n        a.data(\"$binding\", c);\n      } : E;\n      D.$$addBindingClass = k ? function(a) {\n        I(a, \"ng-binding\");\n      } : E;\n      D.$$addScopeInfo = k ? function(a, b, c, d) {\n        a.data(c ? d ? \"$isolateScopeNoTemplate\" : \"$isolateScope\" : \"$scope\", b);\n      } : E;\n      D.$$addScopeClass = k ? function(a, b) {\n        I(a, b ? \"ng-isolate-scope\" : \"ng-scope\");\n      } : E;\n      return D;\n    }];\n  }\n  function xa(b) {\n    return db(b.replace(Sc, \"\"));\n  }\n  function Vc(b, a) {\n    var c = \"\",\n        d = b.split(/\\s+/),\n        e = a.split(/\\s+/),\n        f = 0;\n    a: for (; f < d.length; f++) {\n      for (var g = d[f],\n          h = 0; h < e.length; h++)\n        if (g == e[h])\n          continue a;\n      c += (0 < c.length ? \" \" : \"\") + g;\n    }\n    return c;\n  }\n  function Uc(b) {\n    b = A(b);\n    var a = b.length;\n    if (1 >= a)\n      return b;\n    for (; a--; )\n      8 === b[a].nodeType && qf.call(b, a, 1);\n    return b;\n  }\n  function Fe() {\n    var b = {},\n        a = !1,\n        c = /^(\\S+)(\\s+as\\s+(\\w+))?$/;\n    this.register = function(a, c) {\n      La(a, \"controller\");\n      J(a) ? w(b, a) : b[a] = c;\n    };\n    this.allowGlobals = function() {\n      a = !0;\n    };\n    this.$get = [\"$injector\", \"$window\", function(d, e) {\n      function f(a, b, c, d) {\n        if (!a || !J(a.$scope))\n          throw R(\"$controller\")(\"noscp\", d, b);\n        a.$scope[b] = c;\n      }\n      return function(g, h, l, k) {\n        var n,\n            p,\n            q;\n        l = !0 === l;\n        k && C(k) && (q = k);\n        if (C(g)) {\n          k = g.match(c);\n          if (!k)\n            throw rf(\"ctrlfmt\", g);\n          p = k[1];\n          q = q || k[3];\n          g = b.hasOwnProperty(p) ? b[p] : xc(h.$scope, p, !0) || (a ? xc(e, p, !0) : t);\n          sb(g, p, !0);\n        }\n        if (l)\n          return l = (H(g) ? g[g.length - 1] : g).prototype, n = Object.create(l || null), q && f(h, q, n, p || g.name), w(function() {\n            d.invoke(g, n, h, p);\n            return n;\n          }, {\n            instance: n,\n            identifier: q\n          });\n        n = d.instantiate(g, h, p);\n        q && f(h, q, n, p || g.name);\n        return n;\n      };\n    }];\n  }\n  function Ge() {\n    this.$get = [\"$window\", function(b) {\n      return A(b.document);\n    }];\n  }\n  function He() {\n    this.$get = [\"$log\", function(b) {\n      return function(a, c) {\n        b.error.apply(b, arguments);\n      };\n    }];\n  }\n  function Zb(b, a) {\n    if (C(b)) {\n      var c = b.replace(sf, \"\").trim();\n      if (c) {\n        var d = a(\"Content-Type\");\n        (d = d && 0 === d.indexOf(Wc)) || (d = (d = c.match(tf)) && uf[d[0]].test(c));\n        d && (b = qc(c));\n      }\n    }\n    return b;\n  }\n  function Xc(b) {\n    var a = ia(),\n        c,\n        d,\n        e;\n    if (!b)\n      return a;\n    r(b.split(\"\\n\"), function(b) {\n      e = b.indexOf(\":\");\n      c = z(N(b.substr(0, e)));\n      d = N(b.substr(e + 1));\n      c && (a[c] = a[c] ? a[c] + \", \" + d : d);\n    });\n    return a;\n  }\n  function Yc(b) {\n    var a = J(b) ? b : t;\n    return function(c) {\n      a || (a = Xc(b));\n      return c ? (c = a[z(c)], void 0 === c && (c = null), c) : a;\n    };\n  }\n  function Zc(b, a, c, d) {\n    if (G(d))\n      return d(b, a, c);\n    r(d, function(d) {\n      b = d(b, a, c);\n    });\n    return b;\n  }\n  function Ke() {\n    var b = this.defaults = {\n      transformResponse: [Zb],\n      transformRequest: [function(a) {\n        return J(a) && \"[object File]\" !== Ca.call(a) && \"[object Blob]\" !== Ca.call(a) && \"[object FormData]\" !== Ca.call(a) ? $a(a) : a;\n      }],\n      headers: {\n        common: {Accept: \"application/json, text/plain, */*\"},\n        post: sa($b),\n        put: sa($b),\n        patch: sa($b)\n      },\n      xsrfCookieName: \"XSRF-TOKEN\",\n      xsrfHeaderName: \"X-XSRF-TOKEN\"\n    },\n        a = !1;\n    this.useApplyAsync = function(b) {\n      return y(b) ? (a = !!b, this) : a;\n    };\n    var c = this.interceptors = [];\n    this.$get = [\"$httpBackend\", \"$browser\", \"$cacheFactory\", \"$rootScope\", \"$q\", \"$injector\", function(d, e, f, g, h, l) {\n      function k(a) {\n        function c(a) {\n          var b = w({}, a);\n          b.data = a.data ? Zc(a.data, a.headers, a.status, e.transformResponse) : a.data;\n          a = a.status;\n          return 200 <= a && 300 > a ? b : h.reject(b);\n        }\n        function d(a) {\n          var b,\n              c = {};\n          r(a, function(a, d) {\n            G(a) ? (b = a(), null != b && (c[d] = b)) : c[d] = a;\n          });\n          return c;\n        }\n        if (!ca.isObject(a))\n          throw R(\"$http\")(\"badreq\", a);\n        var e = w({\n          method: \"get\",\n          transformRequest: b.transformRequest,\n          transformResponse: b.transformResponse\n        }, a);\n        e.headers = function(a) {\n          var c = b.headers,\n              e = w({}, a.headers),\n              f,\n              g,\n              c = w({}, c.common, c[z(a.method)]);\n          a: for (f in c) {\n            a = z(f);\n            for (g in e)\n              if (z(g) === a)\n                continue a;\n            e[f] = c[f];\n          }\n          return d(e);\n        }(a);\n        e.method = ub(e.method);\n        var f = [function(a) {\n          var d = a.headers,\n              e = Zc(a.data, Yc(d), t, a.transformRequest);\n          x(e) && r(d, function(a, b) {\n            \"content-type\" === z(b) && delete d[b];\n          });\n          x(a.withCredentials) && !x(b.withCredentials) && (a.withCredentials = b.withCredentials);\n          return n(a, e).then(c, c);\n        }, t],\n            g = h.when(e);\n        for (r(u, function(a) {\n          (a.request || a.requestError) && f.unshift(a.request, a.requestError);\n          (a.response || a.responseError) && f.push(a.response, a.responseError);\n        }); f.length; ) {\n          a = f.shift();\n          var k = f.shift(),\n              g = g.then(a, k);\n        }\n        g.success = function(a) {\n          g.then(function(b) {\n            a(b.data, b.status, b.headers, e);\n          });\n          return g;\n        };\n        g.error = function(a) {\n          g.then(null, function(b) {\n            a(b.data, b.status, b.headers, e);\n          });\n          return g;\n        };\n        return g;\n      }\n      function n(c, f) {\n        function l(b, c, d, e) {\n          function f() {\n            m(c, b, d, e);\n          }\n          I && (200 <= b && 300 > b ? I.put(P, [b, c, Xc(d), e]) : I.remove(P));\n          a ? g.$applyAsync(f) : (f(), g.$$phase || g.$apply());\n        }\n        function m(a, b, d, e) {\n          b = Math.max(b, 0);\n          (200 <= b && 300 > b ? L.resolve : L.reject)({\n            data: a,\n            status: b,\n            headers: Yc(d),\n            config: c,\n            statusText: e\n          });\n        }\n        function n(a) {\n          m(a.data, a.status, sa(a.headers()), a.statusText);\n        }\n        function u() {\n          var a = k.pendingRequests.indexOf(c);\n          -1 !== a && k.pendingRequests.splice(a, 1);\n        }\n        var L = h.defer(),\n            B = L.promise,\n            I,\n            D,\n            S = c.headers,\n            P = p(c.url, c.params);\n        k.pendingRequests.push(c);\n        B.then(u, u);\n        !c.cache && !b.cache || !1 === c.cache || \"GET\" !== c.method && \"JSONP\" !== c.method || (I = J(c.cache) ? c.cache : J(b.cache) ? b.cache : q);\n        I && (D = I.get(P), y(D) ? D && G(D.then) ? D.then(n, n) : H(D) ? m(D[1], D[0], sa(D[2]), D[3]) : m(D, 200, {}, \"OK\") : I.put(P, B));\n        x(D) && ((D = $c(c.url) ? e.cookies()[c.xsrfCookieName || b.xsrfCookieName] : t) && (S[c.xsrfHeaderName || b.xsrfHeaderName] = D), d(c.method, P, f, l, S, c.timeout, c.withCredentials, c.responseType));\n        return B;\n      }\n      function p(a, b) {\n        if (!b)\n          return a;\n        var c = [];\n        Ed(b, function(a, b) {\n          null === a || x(a) || (H(a) || (a = [a]), r(a, function(a) {\n            J(a) && (a = ga(a) ? a.toISOString() : $a(a));\n            c.push(Ea(b) + \"=\" + Ea(a));\n          }));\n        });\n        0 < c.length && (a += (-1 == a.indexOf(\"?\") ? \"?\" : \"&\") + c.join(\"&\"));\n        return a;\n      }\n      var q = f(\"$http\"),\n          u = [];\n      r(c, function(a) {\n        u.unshift(C(a) ? l.get(a) : l.invoke(a));\n      });\n      k.pendingRequests = [];\n      (function(a) {\n        r(arguments, function(a) {\n          k[a] = function(b, c) {\n            return k(w(c || {}, {\n              method: a,\n              url: b\n            }));\n          };\n        });\n      })(\"get\", \"delete\", \"head\", \"jsonp\");\n      (function(a) {\n        r(arguments, function(a) {\n          k[a] = function(b, c, d) {\n            return k(w(d || {}, {\n              method: a,\n              url: b,\n              data: c\n            }));\n          };\n        });\n      })(\"post\", \"put\", \"patch\");\n      k.defaults = b;\n      return k;\n    }];\n  }\n  function vf() {\n    return new Q.XMLHttpRequest;\n  }\n  function Le() {\n    this.$get = [\"$browser\", \"$window\", \"$document\", function(b, a, c) {\n      return wf(b, vf, b.defer, a.angular.callbacks, c[0]);\n    }];\n  }\n  function wf(b, a, c, d, e) {\n    function f(a, b, c) {\n      var f = e.createElement(\"script\"),\n          n = null;\n      f.type = \"text/javascript\";\n      f.src = a;\n      f.async = !0;\n      n = function(a) {\n        f.removeEventListener(\"load\", n, !1);\n        f.removeEventListener(\"error\", n, !1);\n        e.body.removeChild(f);\n        f = null;\n        var g = -1,\n            u = \"unknown\";\n        a && (\"load\" !== a.type || d[b].called || (a = {type: \"error\"}), u = a.type, g = \"error\" === a.type ? 404 : 200);\n        c && c(g, u);\n      };\n      f.addEventListener(\"load\", n, !1);\n      f.addEventListener(\"error\", n, !1);\n      e.body.appendChild(f);\n      return n;\n    }\n    return function(e, h, l, k, n, p, q, u) {\n      function s() {\n        m && m();\n        F && F.abort();\n      }\n      function M(a, d, e, f, g) {\n        L !== t && c.cancel(L);\n        m = F = null;\n        a(d, e, f, g);\n        b.$$completeOutstandingRequest(E);\n      }\n      b.$$incOutstandingRequestCount();\n      h = h || b.url();\n      if (\"jsonp\" == z(e)) {\n        var v = \"_\" + (d.counter++).toString(36);\n        d[v] = function(a) {\n          d[v].data = a;\n          d[v].called = !0;\n        };\n        var m = f(h.replace(\"JSON_CALLBACK\", \"angular.callbacks.\" + v), v, function(a, b) {\n          M(k, a, d[v].data, \"\", b);\n          d[v] = E;\n        });\n      } else {\n        var F = a();\n        F.open(e, h, !0);\n        r(n, function(a, b) {\n          y(a) && F.setRequestHeader(b, a);\n        });\n        F.onload = function() {\n          var a = F.statusText || \"\",\n              b = \"response\" in F ? F.response : F.responseText,\n              c = 1223 === F.status ? 204 : F.status;\n          0 === c && (c = b ? 200 : \"file\" == Aa(h).protocol ? 404 : 0);\n          M(k, c, b, F.getAllResponseHeaders(), a);\n        };\n        e = function() {\n          M(k, -1, null, null, \"\");\n        };\n        F.onerror = e;\n        F.onabort = e;\n        q && (F.withCredentials = !0);\n        if (u)\n          try {\n            F.responseType = u;\n          } catch (Z) {\n            if (\"json\" !== u)\n              throw Z;\n          }\n        F.send(l || null);\n      }\n      if (0 < p)\n        var L = c(s, p);\n      else\n        p && G(p.then) && p.then(s);\n    };\n  }\n  function Ie() {\n    var b = \"{{\",\n        a = \"}}\";\n    this.startSymbol = function(a) {\n      return a ? (b = a, this) : b;\n    };\n    this.endSymbol = function(b) {\n      return b ? (a = b, this) : a;\n    };\n    this.$get = [\"$parse\", \"$exceptionHandler\", \"$sce\", function(c, d, e) {\n      function f(a) {\n        return \"\\\\\\\\\\\\\" + a;\n      }\n      function g(f, g, u, s) {\n        function M(c) {\n          return c.replace(k, b).replace(n, a);\n        }\n        function v(a) {\n          try {\n            var b = a;\n            a = u ? e.getTrusted(u, b) : e.valueOf(b);\n            var c;\n            if (s && !y(a))\n              c = a;\n            else if (null == a)\n              c = \"\";\n            else {\n              switch (typeof a) {\n                case \"string\":\n                  break;\n                case \"number\":\n                  a = \"\" + a;\n                  break;\n                default:\n                  a = $a(a);\n              }\n              c = a;\n            }\n            return c;\n          } catch (g) {\n            c = ac(\"interr\", f, g.toString()), d(c);\n          }\n        }\n        s = !!s;\n        for (var m,\n            F,\n            r = 0,\n            L = [],\n            B = [],\n            I = f.length,\n            D = [],\n            S = []; r < I; )\n          if (-1 != (m = f.indexOf(b, r)) && -1 != (F = f.indexOf(a, m + h)))\n            r !== m && D.push(M(f.substring(r, m))), r = f.substring(m + h, F), L.push(r), B.push(c(r, v)), r = F + l, S.push(D.length), D.push(\"\");\n          else {\n            r !== I && D.push(M(f.substring(r)));\n            break;\n          }\n        if (u && 1 < D.length)\n          throw ac(\"noconcat\", f);\n        if (!g || L.length) {\n          var P = function(a) {\n            for (var b = 0,\n                c = L.length; b < c; b++) {\n              if (s && x(a[b]))\n                return;\n              D[S[b]] = a[b];\n            }\n            return D.join(\"\");\n          };\n          return w(function(a) {\n            var b = 0,\n                c = L.length,\n                e = Array(c);\n            try {\n              for (; b < c; b++)\n                e[b] = B[b](a);\n              return P(e);\n            } catch (g) {\n              a = ac(\"interr\", f, g.toString()), d(a);\n            }\n          }, {\n            exp: f,\n            expressions: L,\n            $$watchDelegate: function(a, b, c) {\n              var d;\n              return a.$watchGroup(B, function(c, e) {\n                var f = P(c);\n                G(b) && b.call(this, f, c !== e ? d : f, a);\n                d = f;\n              }, c);\n            }\n          });\n        }\n      }\n      var h = b.length,\n          l = a.length,\n          k = new RegExp(b.replace(/./g, f), \"g\"),\n          n = new RegExp(a.replace(/./g, f), \"g\");\n      g.startSymbol = function() {\n        return b;\n      };\n      g.endSymbol = function() {\n        return a;\n      };\n      return g;\n    }];\n  }\n  function Je() {\n    this.$get = [\"$rootScope\", \"$window\", \"$q\", \"$$q\", function(b, a, c, d) {\n      function e(e, h, l, k) {\n        var n = a.setInterval,\n            p = a.clearInterval,\n            q = 0,\n            u = y(k) && !k,\n            s = (u ? d : c).defer(),\n            M = s.promise;\n        l = y(l) ? l : 0;\n        M.then(null, null, e);\n        M.$$intervalId = n(function() {\n          s.notify(q++);\n          0 < l && q >= l && (s.resolve(q), p(M.$$intervalId), delete f[M.$$intervalId]);\n          u || b.$apply();\n        }, h);\n        f[M.$$intervalId] = s;\n        return M;\n      }\n      var f = {};\n      e.cancel = function(b) {\n        return b && b.$$intervalId in f ? (f[b.$$intervalId].reject(\"canceled\"), a.clearInterval(b.$$intervalId), delete f[b.$$intervalId], !0) : !1;\n      };\n      return e;\n    }];\n  }\n  function Rd() {\n    this.$get = function() {\n      return {\n        id: \"en-us\",\n        NUMBER_FORMATS: {\n          DECIMAL_SEP: \".\",\n          GROUP_SEP: \",\",\n          PATTERNS: [{\n            minInt: 1,\n            minFrac: 0,\n            maxFrac: 3,\n            posPre: \"\",\n            posSuf: \"\",\n            negPre: \"-\",\n            negSuf: \"\",\n            gSize: 3,\n            lgSize: 3\n          }, {\n            minInt: 1,\n            minFrac: 2,\n            maxFrac: 2,\n            posPre: \"\\u00a4\",\n            posSuf: \"\",\n            negPre: \"(\\u00a4\",\n            negSuf: \")\",\n            gSize: 3,\n            lgSize: 3\n          }],\n          CURRENCY_SYM: \"$\"\n        },\n        DATETIME_FORMATS: {\n          MONTH: \"January February March April May June July August September October November December\".split(\" \"),\n          SHORTMONTH: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n          DAY: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          SHORTDAY: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),\n          AMPMS: [\"AM\", \"PM\"],\n          medium: \"MMM d, y h:mm:ss a\",\n          \"short\": \"M/d/yy h:mm a\",\n          fullDate: \"EEEE, MMMM d, y\",\n          longDate: \"MMMM d, y\",\n          mediumDate: \"MMM d, y\",\n          shortDate: \"M/d/yy\",\n          mediumTime: \"h:mm:ss a\",\n          shortTime: \"h:mm a\",\n          ERANAMES: [\"Before Christ\", \"Anno Domini\"],\n          ERAS: [\"BC\", \"AD\"]\n        },\n        pluralCat: function(b) {\n          return 1 === b ? \"one\" : \"other\";\n        }\n      };\n    };\n  }\n  function bc(b) {\n    b = b.split(\"/\");\n    for (var a = b.length; a--; )\n      b[a] = qb(b[a]);\n    return b.join(\"/\");\n  }\n  function ad(b, a) {\n    var c = Aa(b);\n    a.$$protocol = c.protocol;\n    a.$$host = c.hostname;\n    a.$$port = aa(c.port) || xf[c.protocol] || null;\n  }\n  function bd(b, a) {\n    var c = \"/\" !== b.charAt(0);\n    c && (b = \"/\" + b);\n    var d = Aa(b);\n    a.$$path = decodeURIComponent(c && \"/\" === d.pathname.charAt(0) ? d.pathname.substring(1) : d.pathname);\n    a.$$search = sc(d.search);\n    a.$$hash = decodeURIComponent(d.hash);\n    a.$$path && \"/\" != a.$$path.charAt(0) && (a.$$path = \"/\" + a.$$path);\n  }\n  function ya(b, a) {\n    if (0 === a.indexOf(b))\n      return a.substr(b.length);\n  }\n  function Ga(b) {\n    var a = b.indexOf(\"#\");\n    return -1 == a ? b : b.substr(0, a);\n  }\n  function Fb(b) {\n    return b.replace(/(#.+)|#$/, \"$1\");\n  }\n  function cc(b) {\n    return b.substr(0, Ga(b).lastIndexOf(\"/\") + 1);\n  }\n  function dc(b, a) {\n    this.$$html5 = !0;\n    a = a || \"\";\n    var c = cc(b);\n    ad(b, this);\n    this.$$parse = function(a) {\n      var b = ya(c, a);\n      if (!C(b))\n        throw Gb(\"ipthprfx\", a, c);\n      bd(b, this);\n      this.$$path || (this.$$path = \"/\");\n      this.$$compose();\n    };\n    this.$$compose = function() {\n      var a = Pb(this.$$search),\n          b = this.$$hash ? \"#\" + qb(this.$$hash) : \"\";\n      this.$$url = bc(this.$$path) + (a ? \"?\" + a : \"\") + b;\n      this.$$absUrl = c + this.$$url.substr(1);\n    };\n    this.$$parseLinkUrl = function(d, e) {\n      if (e && \"#\" === e[0])\n        return this.hash(e.slice(1)), !0;\n      var f,\n          g;\n      (f = ya(b, d)) !== t ? (g = f, g = (f = ya(a, f)) !== t ? c + (ya(\"/\", f) || f) : b + g) : (f = ya(c, d)) !== t ? g = c + f : c == d + \"/\" && (g = c);\n      g && this.$$parse(g);\n      return !!g;\n    };\n  }\n  function ec(b, a) {\n    var c = cc(b);\n    ad(b, this);\n    this.$$parse = function(d) {\n      d = ya(b, d) || ya(c, d);\n      var e;\n      \"#\" === d.charAt(0) ? (e = ya(a, d), x(e) && (e = d)) : e = this.$$html5 ? d : \"\";\n      bd(e, this);\n      d = this.$$path;\n      var f = /^\\/[A-Z]:(\\/.*)/;\n      0 === e.indexOf(b) && (e = e.replace(b, \"\"));\n      f.exec(e) || (d = (e = f.exec(d)) ? e[1] : d);\n      this.$$path = d;\n      this.$$compose();\n    };\n    this.$$compose = function() {\n      var c = Pb(this.$$search),\n          e = this.$$hash ? \"#\" + qb(this.$$hash) : \"\";\n      this.$$url = bc(this.$$path) + (c ? \"?\" + c : \"\") + e;\n      this.$$absUrl = b + (this.$$url ? a + this.$$url : \"\");\n    };\n    this.$$parseLinkUrl = function(a, c) {\n      return Ga(b) == Ga(a) ? (this.$$parse(a), !0) : !1;\n    };\n  }\n  function cd(b, a) {\n    this.$$html5 = !0;\n    ec.apply(this, arguments);\n    var c = cc(b);\n    this.$$parseLinkUrl = function(d, e) {\n      if (e && \"#\" === e[0])\n        return this.hash(e.slice(1)), !0;\n      var f,\n          g;\n      b == Ga(d) ? f = d : (g = ya(c, d)) ? f = b + a + g : c === d + \"/\" && (f = c);\n      f && this.$$parse(f);\n      return !!f;\n    };\n    this.$$compose = function() {\n      var c = Pb(this.$$search),\n          e = this.$$hash ? \"#\" + qb(this.$$hash) : \"\";\n      this.$$url = bc(this.$$path) + (c ? \"?\" + c : \"\") + e;\n      this.$$absUrl = b + a + this.$$url;\n    };\n  }\n  function Hb(b) {\n    return function() {\n      return this[b];\n    };\n  }\n  function dd(b, a) {\n    return function(c) {\n      if (x(c))\n        return this[b];\n      this[b] = a(c);\n      this.$$compose();\n      return this;\n    };\n  }\n  function Me() {\n    var b = \"\",\n        a = {\n          enabled: !1,\n          requireBase: !0,\n          rewriteLinks: !0\n        };\n    this.hashPrefix = function(a) {\n      return y(a) ? (b = a, this) : b;\n    };\n    this.html5Mode = function(b) {\n      return Wa(b) ? (a.enabled = b, this) : J(b) ? (Wa(b.enabled) && (a.enabled = b.enabled), Wa(b.requireBase) && (a.requireBase = b.requireBase), Wa(b.rewriteLinks) && (a.rewriteLinks = b.rewriteLinks), this) : a;\n    };\n    this.$get = [\"$rootScope\", \"$browser\", \"$sniffer\", \"$rootElement\", \"$window\", function(c, d, e, f, g) {\n      function h(a, b, c) {\n        var e = k.url(),\n            f = k.$$state;\n        try {\n          d.url(a, b, c), k.$$state = d.state();\n        } catch (g) {\n          throw k.url(e), k.$$state = f, g;\n        }\n      }\n      function l(a, b) {\n        c.$broadcast(\"$locationChangeSuccess\", k.absUrl(), a, k.$$state, b);\n      }\n      var k,\n          n;\n      n = d.baseHref();\n      var p = d.url(),\n          q;\n      if (a.enabled) {\n        if (!n && a.requireBase)\n          throw Gb(\"nobase\");\n        q = p.substring(0, p.indexOf(\"/\", p.indexOf(\"//\") + 2)) + (n || \"/\");\n        n = e.history ? dc : cd;\n      } else\n        q = Ga(p), n = ec;\n      k = new n(q, \"#\" + b);\n      k.$$parseLinkUrl(p, p);\n      k.$$state = d.state();\n      var u = /^\\s*(javascript|mailto):/i;\n      f.on(\"click\", function(b) {\n        if (a.rewriteLinks && !b.ctrlKey && !b.metaKey && !b.shiftKey && 2 != b.which && 2 != b.button) {\n          for (var e = A(b.target); \"a\" !== va(e[0]); )\n            if (e[0] === f[0] || !(e = e.parent())[0])\n              return;\n          var h = e.prop(\"href\"),\n              l = e.attr(\"href\") || e.attr(\"xlink:href\");\n          J(h) && \"[object SVGAnimatedString]\" === h.toString() && (h = Aa(h.animVal).href);\n          u.test(h) || !h || e.attr(\"target\") || b.isDefaultPrevented() || !k.$$parseLinkUrl(h, l) || (b.preventDefault(), k.absUrl() != d.url() && (c.$apply(), g.angular[\"ff-684208-preventDefault\"] = !0));\n        }\n      });\n      Fb(k.absUrl()) != Fb(p) && d.url(k.absUrl(), !0);\n      var s = !0;\n      d.onUrlChange(function(a, b) {\n        c.$evalAsync(function() {\n          var d = k.absUrl(),\n              e = k.$$state,\n              f;\n          k.$$parse(a);\n          k.$$state = b;\n          f = c.$broadcast(\"$locationChangeStart\", a, d, b, e).defaultPrevented;\n          k.absUrl() === a && (f ? (k.$$parse(d), k.$$state = e, h(d, !1, e)) : (s = !1, l(d, e)));\n        });\n        c.$$phase || c.$digest();\n      });\n      c.$watch(function() {\n        var a = Fb(d.url()),\n            b = Fb(k.absUrl()),\n            f = d.state(),\n            g = k.$$replace,\n            q = a !== b || k.$$html5 && e.history && f !== k.$$state;\n        if (s || q)\n          s = !1, c.$evalAsync(function() {\n            var b = k.absUrl(),\n                d = c.$broadcast(\"$locationChangeStart\", b, a, k.$$state, f).defaultPrevented;\n            k.absUrl() === b && (d ? (k.$$parse(a), k.$$state = f) : (q && h(b, g, f === k.$$state ? null : k.$$state), l(a, f)));\n          });\n        k.$$replace = !1;\n      });\n      return k;\n    }];\n  }\n  function Ne() {\n    var b = !0,\n        a = this;\n    this.debugEnabled = function(a) {\n      return y(a) ? (b = a, this) : b;\n    };\n    this.$get = [\"$window\", function(c) {\n      function d(a) {\n        a instanceof Error && (a.stack ? a = a.message && -1 === a.stack.indexOf(a.message) ? \"Error: \" + a.message + \"\\n\" + a.stack : a.stack : a.sourceURL && (a = a.message + \"\\n\" + a.sourceURL + \":\" + a.line));\n        return a;\n      }\n      function e(a) {\n        var b = c.console || {},\n            e = b[a] || b.log || E;\n        a = !1;\n        try {\n          a = !!e.apply;\n        } catch (l) {}\n        return a ? function() {\n          var a = [];\n          r(arguments, function(b) {\n            a.push(d(b));\n          });\n          return e.apply(b, a);\n        } : function(a, b) {\n          e(a, null == b ? \"\" : b);\n        };\n      }\n      return {\n        log: e(\"log\"),\n        info: e(\"info\"),\n        warn: e(\"warn\"),\n        error: e(\"error\"),\n        debug: function() {\n          var c = e(\"debug\");\n          return function() {\n            b && c.apply(a, arguments);\n          };\n        }()\n      };\n    }];\n  }\n  function ua(b, a) {\n    if (\"__defineGetter__\" === b || \"__defineSetter__\" === b || \"__lookupGetter__\" === b || \"__lookupSetter__\" === b || \"__proto__\" === b)\n      throw na(\"isecfld\", a);\n    return b;\n  }\n  function oa(b, a) {\n    if (b) {\n      if (b.constructor === b)\n        throw na(\"isecfn\", a);\n      if (b.window === b)\n        throw na(\"isecwindow\", a);\n      if (b.children && (b.nodeName || b.prop && b.attr && b.find))\n        throw na(\"isecdom\", a);\n      if (b === Object)\n        throw na(\"isecobj\", a);\n    }\n    return b;\n  }\n  function fc(b) {\n    return b.constant;\n  }\n  function hb(b, a, c, d, e) {\n    oa(b, e);\n    oa(a, e);\n    c = c.split(\".\");\n    for (var f,\n        g = 0; 1 < c.length; g++) {\n      f = ua(c.shift(), e);\n      var h = 0 === g && a && a[f] || b[f];\n      h || (h = {}, b[f] = h);\n      b = oa(h, e);\n    }\n    f = ua(c.shift(), e);\n    oa(b[f], e);\n    return b[f] = d;\n  }\n  function Pa(b) {\n    return \"constructor\" == b;\n  }\n  function ed(b, a, c, d, e, f, g) {\n    ua(b, f);\n    ua(a, f);\n    ua(c, f);\n    ua(d, f);\n    ua(e, f);\n    var h = function(a) {\n      return oa(a, f);\n    },\n        l = g || Pa(b) ? h : ra,\n        k = g || Pa(a) ? h : ra,\n        n = g || Pa(c) ? h : ra,\n        p = g || Pa(d) ? h : ra,\n        q = g || Pa(e) ? h : ra;\n    return function(f, g) {\n      var h = g && g.hasOwnProperty(b) ? g : f;\n      if (null == h)\n        return h;\n      h = l(h[b]);\n      if (!a)\n        return h;\n      if (null == h)\n        return t;\n      h = k(h[a]);\n      if (!c)\n        return h;\n      if (null == h)\n        return t;\n      h = n(h[c]);\n      if (!d)\n        return h;\n      if (null == h)\n        return t;\n      h = p(h[d]);\n      return e ? null == h ? t : h = q(h[e]) : h;\n    };\n  }\n  function yf(b, a) {\n    return function(c, d) {\n      return b(c, d, oa, a);\n    };\n  }\n  function zf(b, a, c) {\n    var d = a.expensiveChecks,\n        e = d ? Af : Bf,\n        f = e[b];\n    if (f)\n      return f;\n    var g = b.split(\".\"),\n        h = g.length;\n    if (a.csp)\n      f = 6 > h ? ed(g[0], g[1], g[2], g[3], g[4], c, d) : function(a, b) {\n        var e = 0,\n            f;\n        do\n          f = ed(g[e++], g[e++], g[e++], g[e++], g[e++], c, d)(a, b), b = t, a = f;\n while (e < h);\n        return f;\n      };\n    else {\n      var l = \"\";\n      d && (l += \"s = eso(s, fe);\\nl = eso(l, fe);\\n\");\n      var k = d;\n      r(g, function(a, b) {\n        ua(a, c);\n        var e = (b ? \"s\" : '((l&&l.hasOwnProperty(\"' + a + '\"))?l:s)') + \".\" + a;\n        if (d || Pa(a))\n          e = \"eso(\" + e + \", fe)\", k = !0;\n        l += \"if(s == null) return undefined;\\ns=\" + e + \";\\n\";\n      });\n      l += \"return s;\";\n      a = new Function(\"s\", \"l\", \"eso\", \"fe\", l);\n      a.toString = ea(l);\n      k && (a = yf(a, c));\n      f = a;\n    }\n    f.sharedGetter = !0;\n    f.assign = function(a, c, d) {\n      return hb(a, d, b, c, b);\n    };\n    return e[b] = f;\n  }\n  function gc(b) {\n    return G(b.valueOf) ? b.valueOf() : Cf.call(b);\n  }\n  function Oe() {\n    var b = ia(),\n        a = ia();\n    this.$get = [\"$filter\", \"$sniffer\", function(c, d) {\n      function e(a) {\n        var b = a;\n        a.sharedGetter && (b = function(b, c) {\n          return a(b, c);\n        }, b.literal = a.literal, b.constant = a.constant, b.assign = a.assign);\n        return b;\n      }\n      function f(a, b) {\n        for (var c = 0,\n            d = a.length; c < d; c++) {\n          var e = a[c];\n          e.constant || (e.inputs ? f(e.inputs, b) : -1 === b.indexOf(e) && b.push(e));\n        }\n        return b;\n      }\n      function g(a, b) {\n        return null == a || null == b ? a === b : \"object\" === typeof a && (a = gc(a), \"object\" === typeof a) ? !1 : a === b || a !== a && b !== b;\n      }\n      function h(a, b, c, d) {\n        var e = d.$$inputs || (d.$$inputs = f(d.inputs, [])),\n            h;\n        if (1 === e.length) {\n          var k = g,\n              e = e[0];\n          return a.$watch(function(a) {\n            var b = e(a);\n            g(b, k) || (h = d(a), k = b && gc(b));\n            return h;\n          }, b, c);\n        }\n        for (var l = [],\n            q = 0,\n            p = e.length; q < p; q++)\n          l[q] = g;\n        return a.$watch(function(a) {\n          for (var b = !1,\n              c = 0,\n              f = e.length; c < f; c++) {\n            var k = e[c](a);\n            if (b || (b = !g(k, l[c])))\n              l[c] = k && gc(k);\n          }\n          b && (h = d(a));\n          return h;\n        }, b, c);\n      }\n      function l(a, b, c, d) {\n        var e,\n            f;\n        return e = a.$watch(function(a) {\n          return d(a);\n        }, function(a, c, d) {\n          f = a;\n          G(b) && b.apply(this, arguments);\n          y(a) && d.$$postDigest(function() {\n            y(f) && e();\n          });\n        }, c);\n      }\n      function k(a, b, c, d) {\n        function e(a) {\n          var b = !0;\n          r(a, function(a) {\n            y(a) || (b = !1);\n          });\n          return b;\n        }\n        var f,\n            g;\n        return f = a.$watch(function(a) {\n          return d(a);\n        }, function(a, c, d) {\n          g = a;\n          G(b) && b.call(this, a, c, d);\n          e(a) && d.$$postDigest(function() {\n            e(g) && f();\n          });\n        }, c);\n      }\n      function n(a, b, c, d) {\n        var e;\n        return e = a.$watch(function(a) {\n          return d(a);\n        }, function(a, c, d) {\n          G(b) && b.apply(this, arguments);\n          e();\n        }, c);\n      }\n      function p(a, b) {\n        if (!b)\n          return a;\n        var c = a.$$watchDelegate,\n            c = c !== k && c !== l ? function(c, d) {\n              var e = a(c, d);\n              return b(e, c, d);\n            } : function(c, d) {\n              var e = a(c, d),\n                  f = b(e, c, d);\n              return y(e) ? f : e;\n            };\n        a.$$watchDelegate && a.$$watchDelegate !== h ? c.$$watchDelegate = a.$$watchDelegate : b.$stateful || (c.$$watchDelegate = h, c.inputs = [a]);\n        return c;\n      }\n      var q = {\n        csp: d.csp,\n        expensiveChecks: !1\n      },\n          u = {\n            csp: d.csp,\n            expensiveChecks: !0\n          };\n      return function(d, f, g) {\n        var m,\n            r,\n            t;\n        switch (typeof d) {\n          case \"string\":\n            t = d = d.trim();\n            var L = g ? a : b;\n            m = L[t];\n            m || (\":\" === d.charAt(0) && \":\" === d.charAt(1) && (r = !0, d = d.substring(2)), g = g ? u : q, m = new hc(g), m = (new ib(m, c, g)).parse(d), m.constant ? m.$$watchDelegate = n : r ? (m = e(m), m.$$watchDelegate = m.literal ? k : l) : m.inputs && (m.$$watchDelegate = h), L[t] = m);\n            return p(m, f);\n          case \"function\":\n            return p(d, f);\n          default:\n            return p(E, f);\n        }\n      };\n    }];\n  }\n  function Qe() {\n    this.$get = [\"$rootScope\", \"$exceptionHandler\", function(b, a) {\n      return fd(function(a) {\n        b.$evalAsync(a);\n      }, a);\n    }];\n  }\n  function Re() {\n    this.$get = [\"$browser\", \"$exceptionHandler\", function(b, a) {\n      return fd(function(a) {\n        b.defer(a);\n      }, a);\n    }];\n  }\n  function fd(b, a) {\n    function c(a, b, c) {\n      function d(b) {\n        return function(c) {\n          e || (e = !0, b.call(a, c));\n        };\n      }\n      var e = !1;\n      return [d(b), d(c)];\n    }\n    function d() {\n      this.$$state = {status: 0};\n    }\n    function e(a, b) {\n      return function(c) {\n        b.call(a, c);\n      };\n    }\n    function f(c) {\n      !c.processScheduled && c.pending && (c.processScheduled = !0, b(function() {\n        var b,\n            d,\n            e;\n        e = c.pending;\n        c.processScheduled = !1;\n        c.pending = t;\n        for (var f = 0,\n            g = e.length; f < g; ++f) {\n          d = e[f][0];\n          b = e[f][c.status];\n          try {\n            G(b) ? d.resolve(b(c.value)) : 1 === c.status ? d.resolve(c.value) : d.reject(c.value);\n          } catch (h) {\n            d.reject(h), a(h);\n          }\n        }\n      }));\n    }\n    function g() {\n      this.promise = new d;\n      this.resolve = e(this, this.resolve);\n      this.reject = e(this, this.reject);\n      this.notify = e(this, this.notify);\n    }\n    var h = R(\"$q\", TypeError);\n    d.prototype = {\n      then: function(a, b, c) {\n        var d = new g;\n        this.$$state.pending = this.$$state.pending || [];\n        this.$$state.pending.push([d, a, b, c]);\n        0 < this.$$state.status && f(this.$$state);\n        return d.promise;\n      },\n      \"catch\": function(a) {\n        return this.then(null, a);\n      },\n      \"finally\": function(a, b) {\n        return this.then(function(b) {\n          return k(b, !0, a);\n        }, function(b) {\n          return k(b, !1, a);\n        }, b);\n      }\n    };\n    g.prototype = {\n      resolve: function(a) {\n        this.promise.$$state.status || (a === this.promise ? this.$$reject(h(\"qcycle\", a)) : this.$$resolve(a));\n      },\n      $$resolve: function(b) {\n        var d,\n            e;\n        e = c(this, this.$$resolve, this.$$reject);\n        try {\n          if (J(b) || G(b))\n            d = b && b.then;\n          G(d) ? (this.promise.$$state.status = -1, d.call(b, e[0], e[1], this.notify)) : (this.promise.$$state.value = b, this.promise.$$state.status = 1, f(this.promise.$$state));\n        } catch (g) {\n          e[1](g), a(g);\n        }\n      },\n      reject: function(a) {\n        this.promise.$$state.status || this.$$reject(a);\n      },\n      $$reject: function(a) {\n        this.promise.$$state.value = a;\n        this.promise.$$state.status = 2;\n        f(this.promise.$$state);\n      },\n      notify: function(c) {\n        var d = this.promise.$$state.pending;\n        0 >= this.promise.$$state.status && d && d.length && b(function() {\n          for (var b,\n              e,\n              f = 0,\n              g = d.length; f < g; f++) {\n            e = d[f][0];\n            b = d[f][3];\n            try {\n              e.notify(G(b) ? b(c) : c);\n            } catch (h) {\n              a(h);\n            }\n          }\n        });\n      }\n    };\n    var l = function(a, b) {\n      var c = new g;\n      b ? c.resolve(a) : c.reject(a);\n      return c.promise;\n    },\n        k = function(a, b, c) {\n          var d = null;\n          try {\n            G(c) && (d = c());\n          } catch (e) {\n            return l(e, !1);\n          }\n          return d && G(d.then) ? d.then(function() {\n            return l(a, b);\n          }, function(a) {\n            return l(a, !1);\n          }) : l(a, b);\n        },\n        n = function(a, b, c, d) {\n          var e = new g;\n          e.resolve(a);\n          return e.promise.then(b, c, d);\n        },\n        p = function u(a) {\n          if (!G(a))\n            throw h(\"norslvr\", a);\n          if (!(this instanceof u))\n            return new u(a);\n          var b = new g;\n          a(function(a) {\n            b.resolve(a);\n          }, function(a) {\n            b.reject(a);\n          });\n          return b.promise;\n        };\n    p.defer = function() {\n      return new g;\n    };\n    p.reject = function(a) {\n      var b = new g;\n      b.reject(a);\n      return b.promise;\n    };\n    p.when = n;\n    p.all = function(a) {\n      var b = new g,\n          c = 0,\n          d = H(a) ? [] : {};\n      r(a, function(a, e) {\n        c++;\n        n(a).then(function(a) {\n          d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d));\n        }, function(a) {\n          d.hasOwnProperty(e) || b.reject(a);\n        });\n      });\n      0 === c && b.resolve(d);\n      return b.promise;\n    };\n    return p;\n  }\n  function $e() {\n    this.$get = [\"$window\", \"$timeout\", function(b, a) {\n      var c = b.requestAnimationFrame || b.webkitRequestAnimationFrame,\n          d = b.cancelAnimationFrame || b.webkitCancelAnimationFrame || b.webkitCancelRequestAnimationFrame,\n          e = !!c,\n          f = e ? function(a) {\n            var b = c(a);\n            return function() {\n              d(b);\n            };\n          } : function(b) {\n            var c = a(b, 16.66, !1);\n            return function() {\n              a.cancel(c);\n            };\n          };\n      f.supported = e;\n      return f;\n    }];\n  }\n  function Pe() {\n    function b(a) {\n      function b() {\n        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;\n        this.$$listeners = {};\n        this.$$listenerCount = {};\n        this.$$watchersCount = 0;\n        this.$id = ++ob;\n        this.$$ChildScope = null;\n      }\n      b.prototype = a;\n      return b;\n    }\n    var a = 10,\n        c = R(\"$rootScope\"),\n        d = null,\n        e = null;\n    this.digestTtl = function(b) {\n      arguments.length && (a = b);\n      return a;\n    };\n    this.$get = [\"$injector\", \"$exceptionHandler\", \"$parse\", \"$browser\", function(f, g, h, l) {\n      function k(a) {\n        a.currentScope.$$destroyed = !0;\n      }\n      function n() {\n        this.$id = ++ob;\n        this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;\n        this.$root = this;\n        this.$$destroyed = !1;\n        this.$$listeners = {};\n        this.$$listenerCount = {};\n        this.$$isolateBindings = null;\n      }\n      function p(a) {\n        if (v.$$phase)\n          throw c(\"inprog\", v.$$phase);\n        v.$$phase = a;\n      }\n      function q(a, b, c) {\n        do\n          a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c];\n while (a = a.$parent);\n      }\n      function u() {}\n      function s() {\n        for (; t.length; )\n          try {\n            t.shift()();\n          } catch (a) {\n            g(a);\n          }\n        e = null;\n      }\n      function M() {\n        null === e && (e = l.defer(function() {\n          v.$apply(s);\n        }));\n      }\n      n.prototype = {\n        constructor: n,\n        $new: function(a, c) {\n          var d;\n          c = c || this;\n          a ? (d = new n, d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = b(this)), d = new this.$$ChildScope);\n          d.$parent = c;\n          d.$$prevSibling = c.$$childTail;\n          c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d;\n          (a || c != this) && d.$on(\"$destroy\", k);\n          return d;\n        },\n        $watch: function(a, b, c) {\n          var e = h(a);\n          if (e.$$watchDelegate)\n            return e.$$watchDelegate(this, b, c, e);\n          var f = this.$$watchers,\n              g = {\n                fn: b,\n                last: u,\n                get: e,\n                exp: a,\n                eq: !!c\n              };\n          d = null;\n          G(b) || (g.fn = E);\n          f || (f = this.$$watchers = []);\n          f.unshift(g);\n          return function() {\n            Xa(f, g);\n            d = null;\n          };\n        },\n        $watchGroup: function(a, b) {\n          function c() {\n            h = !1;\n            k ? (k = !1, b(e, e, g)) : b(e, d, g);\n          }\n          var d = Array(a.length),\n              e = Array(a.length),\n              f = [],\n              g = this,\n              h = !1,\n              k = !0;\n          if (!a.length) {\n            var l = !0;\n            g.$evalAsync(function() {\n              l && b(e, e, g);\n            });\n            return function() {\n              l = !1;\n            };\n          }\n          if (1 === a.length)\n            return this.$watch(a[0], function(a, c, f) {\n              e[0] = a;\n              d[0] = c;\n              b(e, a === c ? e : d, f);\n            });\n          r(a, function(a, b) {\n            var k = g.$watch(a, function(a, f) {\n              e[b] = a;\n              d[b] = f;\n              h || (h = !0, g.$evalAsync(c));\n            });\n            f.push(k);\n          });\n          return function() {\n            for (; f.length; )\n              f.shift()();\n          };\n        },\n        $watchCollection: function(a, b) {\n          function c(a) {\n            e = a;\n            var b,\n                d,\n                g,\n                h;\n            if (!x(e)) {\n              if (J(e))\n                if (Sa(e))\n                  for (f !== p && (f = p, u = f.length = 0, l++), a = e.length, u !== a && (l++, f.length = u = a), b = 0; b < a; b++)\n                    h = f[b], g = e[b], d = h !== h && g !== g, d || h === g || (l++, f[b] = g);\n                else {\n                  f !== n && (f = n = {}, u = 0, l++);\n                  a = 0;\n                  for (b in e)\n                    e.hasOwnProperty(b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, d || h === g || (l++, f[b] = g)) : (u++, f[b] = g, l++));\n                  if (u > a)\n                    for (b in l++, f)\n                      e.hasOwnProperty(b) || (u--, delete f[b]);\n                }\n              else\n                f !== e && (f = e, l++);\n              return l;\n            }\n          }\n          c.$stateful = !0;\n          var d = this,\n              e,\n              f,\n              g,\n              k = 1 < b.length,\n              l = 0,\n              q = h(a, c),\n              p = [],\n              n = {},\n              m = !0,\n              u = 0;\n          return this.$watch(q, function() {\n            m ? (m = !1, b(e, e, d)) : b(e, g, d);\n            if (k)\n              if (J(e))\n                if (Sa(e)) {\n                  g = Array(e.length);\n                  for (var a = 0; a < e.length; a++)\n                    g[a] = e[a];\n                } else\n                  for (a in g = {}, e)\n                    tc.call(e, a) && (g[a] = e[a]);\n              else\n                g = e;\n          });\n        },\n        $digest: function() {\n          var b,\n              f,\n              h,\n              k,\n              q,\n              n,\n              r = a,\n              t,\n              O = [],\n              M,\n              y;\n          p(\"$digest\");\n          l.$$checkUrlChange();\n          this === v && null !== e && (l.defer.cancel(e), s());\n          d = null;\n          do {\n            n = !1;\n            for (t = this; m.length; ) {\n              try {\n                y = m.shift(), y.scope.$eval(y.expression, y.locals);\n              } catch (w) {\n                g(w);\n              }\n              d = null;\n            }\n            a: do {\n              if (k = t.$$watchers)\n                for (q = k.length; q--; )\n                  try {\n                    if (b = k[q])\n                      if ((f = b.get(t)) !== (h = b.last) && !(b.eq ? ha(f, h) : \"number\" === typeof f && \"number\" === typeof h && isNaN(f) && isNaN(h)))\n                        n = !0, d = b, b.last = b.eq ? Da(f, null) : f, b.fn(f, h === u ? f : h, t), 5 > r && (M = 4 - r, O[M] || (O[M] = []), O[M].push({\n                          msg: G(b.exp) ? \"fn: \" + (b.exp.name || b.exp.toString()) : b.exp,\n                          newVal: f,\n                          oldVal: h\n                        }));\n                      else if (b === d) {\n                        n = !1;\n                        break a;\n                      }\n                  } catch (A) {\n                    g(A);\n                  }\n              if (!(k = t.$$childHead || t !== this && t.$$nextSibling))\n                for (; t !== this && !(k = t.$$nextSibling); )\n                  t = t.$parent;\n            } while (t = k);\n            if ((n || m.length) && !r--)\n              throw v.$$phase = null, c(\"infdig\", a, O);\n          } while (n || m.length);\n          for (v.$$phase = null; F.length; )\n            try {\n              F.shift()();\n            } catch (x) {\n              g(x);\n            }\n        },\n        $destroy: function() {\n          if (!this.$$destroyed) {\n            var a = this.$parent;\n            this.$broadcast(\"$destroy\");\n            this.$$destroyed = !0;\n            if (this !== v) {\n              for (var b in this.$$listenerCount)\n                q(this, this.$$listenerCount[b], b);\n              a.$$childHead == this && (a.$$childHead = this.$$nextSibling);\n              a.$$childTail == this && (a.$$childTail = this.$$prevSibling);\n              this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling);\n              this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling);\n              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = E;\n              this.$on = this.$watch = this.$watchGroup = function() {\n                return E;\n              };\n              this.$$listeners = {};\n              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;\n            }\n          }\n        },\n        $eval: function(a, b) {\n          return h(a)(this, b);\n        },\n        $evalAsync: function(a, b) {\n          v.$$phase || m.length || l.defer(function() {\n            m.length && v.$digest();\n          });\n          m.push({\n            scope: this,\n            expression: a,\n            locals: b\n          });\n        },\n        $$postDigest: function(a) {\n          F.push(a);\n        },\n        $apply: function(a) {\n          try {\n            return p(\"$apply\"), this.$eval(a);\n          } catch (b) {\n            g(b);\n          } finally {\n            v.$$phase = null;\n            try {\n              v.$digest();\n            } catch (c) {\n              throw g(c), c;\n            }\n          }\n        },\n        $applyAsync: function(a) {\n          function b() {\n            c.$eval(a);\n          }\n          var c = this;\n          a && t.push(b);\n          M();\n        },\n        $on: function(a, b) {\n          var c = this.$$listeners[a];\n          c || (this.$$listeners[a] = c = []);\n          c.push(b);\n          var d = this;\n          do\n            d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++;\n while (d = d.$parent);\n          var e = this;\n          return function() {\n            var d = c.indexOf(b);\n            -1 !== d && (c[d] = null, q(e, 1, a));\n          };\n        },\n        $emit: function(a, b) {\n          var c = [],\n              d,\n              e = this,\n              f = !1,\n              h = {\n                name: a,\n                targetScope: e,\n                stopPropagation: function() {\n                  f = !0;\n                },\n                preventDefault: function() {\n                  h.defaultPrevented = !0;\n                },\n                defaultPrevented: !1\n              },\n              k = Ya([h], arguments, 1),\n              l,\n              q;\n          do {\n            d = e.$$listeners[a] || c;\n            h.currentScope = e;\n            l = 0;\n            for (q = d.length; l < q; l++)\n              if (d[l])\n                try {\n                  d[l].apply(null, k);\n                } catch (p) {\n                  g(p);\n                }\n              else\n                d.splice(l, 1), l--, q--;\n            if (f)\n              return h.currentScope = null, h;\n            e = e.$parent;\n          } while (e);\n          h.currentScope = null;\n          return h;\n        },\n        $broadcast: function(a, b) {\n          var c = this,\n              d = this,\n              e = {\n                name: a,\n                targetScope: this,\n                preventDefault: function() {\n                  e.defaultPrevented = !0;\n                },\n                defaultPrevented: !1\n              };\n          if (!this.$$listenerCount[a])\n            return e;\n          for (var f = Ya([e], arguments, 1),\n              h,\n              l; c = d; ) {\n            e.currentScope = c;\n            d = c.$$listeners[a] || [];\n            h = 0;\n            for (l = d.length; h < l; h++)\n              if (d[h])\n                try {\n                  d[h].apply(null, f);\n                } catch (k) {\n                  g(k);\n                }\n              else\n                d.splice(h, 1), h--, l--;\n            if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling))\n              for (; c !== this && !(d = c.$$nextSibling); )\n                c = c.$parent;\n          }\n          e.currentScope = null;\n          return e;\n        }\n      };\n      var v = new n,\n          m = v.$$asyncQueue = [],\n          F = v.$$postDigestQueue = [],\n          t = v.$$applyAsyncQueue = [];\n      return v;\n    }];\n  }\n  function Sd() {\n    var b = /^\\s*(https?|ftp|mailto|tel|file):/,\n        a = /^\\s*((https?|ftp|file|blob):|data:image\\/)/;\n    this.aHrefSanitizationWhitelist = function(a) {\n      return y(a) ? (b = a, this) : b;\n    };\n    this.imgSrcSanitizationWhitelist = function(b) {\n      return y(b) ? (a = b, this) : a;\n    };\n    this.$get = function() {\n      return function(c, d) {\n        var e = d ? a : b,\n            f;\n        f = Aa(c).href;\n        return \"\" === f || f.match(e) ? c : \"unsafe:\" + f;\n      };\n    };\n  }\n  function Df(b) {\n    if (\"self\" === b)\n      return b;\n    if (C(b)) {\n      if (-1 < b.indexOf(\"***\"))\n        throw Ba(\"iwcard\", b);\n      b = gd(b).replace(\"\\\\*\\\\*\", \".*\").replace(\"\\\\*\", \"[^:/.?&;]*\");\n      return new RegExp(\"^\" + b + \"$\");\n    }\n    if (Ua(b))\n      return new RegExp(\"^\" + b.source + \"$\");\n    throw Ba(\"imatcher\");\n  }\n  function hd(b) {\n    var a = [];\n    y(b) && r(b, function(b) {\n      a.push(Df(b));\n    });\n    return a;\n  }\n  function Te() {\n    this.SCE_CONTEXTS = pa;\n    var b = [\"self\"],\n        a = [];\n    this.resourceUrlWhitelist = function(a) {\n      arguments.length && (b = hd(a));\n      return b;\n    };\n    this.resourceUrlBlacklist = function(b) {\n      arguments.length && (a = hd(b));\n      return a;\n    };\n    this.$get = [\"$injector\", function(c) {\n      function d(a, b) {\n        return \"self\" === a ? $c(b) : !!a.exec(b.href);\n      }\n      function e(a) {\n        var b = function(a) {\n          this.$$unwrapTrustedValue = function() {\n            return a;\n          };\n        };\n        a && (b.prototype = new a);\n        b.prototype.valueOf = function() {\n          return this.$$unwrapTrustedValue();\n        };\n        b.prototype.toString = function() {\n          return this.$$unwrapTrustedValue().toString();\n        };\n        return b;\n      }\n      var f = function(a) {\n        throw Ba(\"unsafe\");\n      };\n      c.has(\"$sanitize\") && (f = c.get(\"$sanitize\"));\n      var g = e(),\n          h = {};\n      h[pa.HTML] = e(g);\n      h[pa.CSS] = e(g);\n      h[pa.URL] = e(g);\n      h[pa.JS] = e(g);\n      h[pa.RESOURCE_URL] = e(h[pa.URL]);\n      return {\n        trustAs: function(a, b) {\n          var c = h.hasOwnProperty(a) ? h[a] : null;\n          if (!c)\n            throw Ba(\"icontext\", a, b);\n          if (null === b || b === t || \"\" === b)\n            return b;\n          if (\"string\" !== typeof b)\n            throw Ba(\"itype\", a);\n          return new c(b);\n        },\n        getTrusted: function(c, e) {\n          if (null === e || e === t || \"\" === e)\n            return e;\n          var g = h.hasOwnProperty(c) ? h[c] : null;\n          if (g && e instanceof g)\n            return e.$$unwrapTrustedValue();\n          if (c === pa.RESOURCE_URL) {\n            var g = Aa(e.toString()),\n                p,\n                q,\n                u = !1;\n            p = 0;\n            for (q = b.length; p < q; p++)\n              if (d(b[p], g)) {\n                u = !0;\n                break;\n              }\n            if (u)\n              for (p = 0, q = a.length; p < q; p++)\n                if (d(a[p], g)) {\n                  u = !1;\n                  break;\n                }\n            if (u)\n              return e;\n            throw Ba(\"insecurl\", e.toString());\n          }\n          if (c === pa.HTML)\n            return f(e);\n          throw Ba(\"unsafe\");\n        },\n        valueOf: function(a) {\n          return a instanceof g ? a.$$unwrapTrustedValue() : a;\n        }\n      };\n    }];\n  }\n  function Se() {\n    var b = !0;\n    this.enabled = function(a) {\n      arguments.length && (b = !!a);\n      return b;\n    };\n    this.$get = [\"$parse\", \"$sceDelegate\", function(a, c) {\n      if (b && 8 > Qa)\n        throw Ba(\"iequirks\");\n      var d = sa(pa);\n      d.isEnabled = function() {\n        return b;\n      };\n      d.trustAs = c.trustAs;\n      d.getTrusted = c.getTrusted;\n      d.valueOf = c.valueOf;\n      b || (d.trustAs = d.getTrusted = function(a, b) {\n        return b;\n      }, d.valueOf = ra);\n      d.parseAs = function(b, c) {\n        var e = a(c);\n        return e.literal && e.constant ? e : a(c, function(a) {\n          return d.getTrusted(b, a);\n        });\n      };\n      var e = d.parseAs,\n          f = d.getTrusted,\n          g = d.trustAs;\n      r(pa, function(a, b) {\n        var c = z(b);\n        d[db(\"parse_as_\" + c)] = function(b) {\n          return e(a, b);\n        };\n        d[db(\"get_trusted_\" + c)] = function(b) {\n          return f(a, b);\n        };\n        d[db(\"trust_as_\" + c)] = function(b) {\n          return g(a, b);\n        };\n      });\n      return d;\n    }];\n  }\n  function Ue() {\n    this.$get = [\"$window\", \"$document\", function(b, a) {\n      var c = {},\n          d = aa((/android (\\d+)/.exec(z((b.navigator || {}).userAgent)) || [])[1]),\n          e = /Boxee/i.test((b.navigator || {}).userAgent),\n          f = a[0] || {},\n          g,\n          h = /^(Moz|webkit|ms)(?=[A-Z])/,\n          l = f.body && f.body.style,\n          k = !1,\n          n = !1;\n      if (l) {\n        for (var p in l)\n          if (k = h.exec(p)) {\n            g = k[0];\n            g = g.substr(0, 1).toUpperCase() + g.substr(1);\n            break;\n          }\n        g || (g = \"WebkitOpacity\" in l && \"webkit\");\n        k = !!(\"transition\" in l || g + \"Transition\" in l);\n        n = !!(\"animation\" in l || g + \"Animation\" in l);\n        !d || k && n || (k = C(f.body.style.webkitTransition), n = C(f.body.style.webkitAnimation));\n      }\n      return {\n        history: !(!b.history || !b.history.pushState || 4 > d || e),\n        hasEvent: function(a) {\n          if (\"input\" === a && 11 >= Qa)\n            return !1;\n          if (x(c[a])) {\n            var b = f.createElement(\"div\");\n            c[a] = \"on\" + a in b;\n          }\n          return c[a];\n        },\n        csp: bb(),\n        vendorPrefix: g,\n        transitions: k,\n        animations: n,\n        android: d\n      };\n    }];\n  }\n  function We() {\n    this.$get = [\"$templateCache\", \"$http\", \"$q\", function(b, a, c) {\n      function d(e, f) {\n        d.totalPendingRequests++;\n        var g = a.defaults && a.defaults.transformResponse;\n        H(g) ? g = g.filter(function(a) {\n          return a !== Zb;\n        }) : g === Zb && (g = null);\n        return a.get(e, {\n          cache: b,\n          transformResponse: g\n        })[\"finally\"](function() {\n          d.totalPendingRequests--;\n        }).then(function(a) {\n          return a.data;\n        }, function(a) {\n          if (!f)\n            throw la(\"tpload\", e);\n          return c.reject(a);\n        });\n      }\n      d.totalPendingRequests = 0;\n      return d;\n    }];\n  }\n  function Xe() {\n    this.$get = [\"$rootScope\", \"$browser\", \"$location\", function(b, a, c) {\n      return {\n        findBindings: function(a, b, c) {\n          a = a.getElementsByClassName(\"ng-binding\");\n          var g = [];\n          r(a, function(a) {\n            var d = ca.element(a).data(\"$binding\");\n            d && r(d, function(d) {\n              c ? (new RegExp(\"(^|\\\\s)\" + gd(b) + \"(\\\\s|\\\\||$)\")).test(d) && g.push(a) : -1 != d.indexOf(b) && g.push(a);\n            });\n          });\n          return g;\n        },\n        findModels: function(a, b, c) {\n          for (var g = [\"ng-\", \"data-ng-\", \"ng\\\\:\"],\n              h = 0; h < g.length; ++h) {\n            var l = a.querySelectorAll(\"[\" + g[h] + \"model\" + (c ? \"=\" : \"*=\") + '\"' + b + '\"]');\n            if (l.length)\n              return l;\n          }\n        },\n        getLocation: function() {\n          return c.url();\n        },\n        setLocation: function(a) {\n          a !== c.url() && (c.url(a), b.$digest());\n        },\n        whenStable: function(b) {\n          a.notifyWhenNoOutstandingRequests(b);\n        }\n      };\n    }];\n  }\n  function Ye() {\n    this.$get = [\"$rootScope\", \"$browser\", \"$q\", \"$$q\", \"$exceptionHandler\", function(b, a, c, d, e) {\n      function f(f, l, k) {\n        var n = y(k) && !k,\n            p = (n ? d : c).defer(),\n            q = p.promise;\n        l = a.defer(function() {\n          try {\n            p.resolve(f());\n          } catch (a) {\n            p.reject(a), e(a);\n          } finally {\n            delete g[q.$$timeoutId];\n          }\n          n || b.$apply();\n        }, l);\n        q.$$timeoutId = l;\n        g[l] = p;\n        return q;\n      }\n      var g = {};\n      f.cancel = function(b) {\n        return b && b.$$timeoutId in g ? (g[b.$$timeoutId].reject(\"canceled\"), delete g[b.$$timeoutId], a.defer.cancel(b.$$timeoutId)) : !1;\n      };\n      return f;\n    }];\n  }\n  function Aa(b) {\n    Qa && ($.setAttribute(\"href\", b), b = $.href);\n    $.setAttribute(\"href\", b);\n    return {\n      href: $.href,\n      protocol: $.protocol ? $.protocol.replace(/:$/, \"\") : \"\",\n      host: $.host,\n      search: $.search ? $.search.replace(/^\\?/, \"\") : \"\",\n      hash: $.hash ? $.hash.replace(/^#/, \"\") : \"\",\n      hostname: $.hostname,\n      port: $.port,\n      pathname: \"/\" === $.pathname.charAt(0) ? $.pathname : \"/\" + $.pathname\n    };\n  }\n  function $c(b) {\n    b = C(b) ? Aa(b) : b;\n    return b.protocol === id.protocol && b.host === id.host;\n  }\n  function Ze() {\n    this.$get = ea(Q);\n  }\n  function Fc(b) {\n    function a(c, d) {\n      if (J(c)) {\n        var e = {};\n        r(c, function(b, c) {\n          e[c] = a(c, b);\n        });\n        return e;\n      }\n      return b.factory(c + \"Filter\", d);\n    }\n    this.register = a;\n    this.$get = [\"$injector\", function(a) {\n      return function(b) {\n        return a.get(b + \"Filter\");\n      };\n    }];\n    a(\"currency\", jd);\n    a(\"date\", kd);\n    a(\"filter\", Ef);\n    a(\"json\", Ff);\n    a(\"limitTo\", Gf);\n    a(\"lowercase\", Hf);\n    a(\"number\", ld);\n    a(\"orderBy\", md);\n    a(\"uppercase\", If);\n  }\n  function Ef() {\n    return function(b, a, c) {\n      if (!H(b))\n        return b;\n      var d;\n      switch (typeof a) {\n        case \"function\":\n          break;\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          d = !0;\n        case \"object\":\n          a = Jf(a, c, d);\n          break;\n        default:\n          return b;\n      }\n      return b.filter(a);\n    };\n  }\n  function Jf(b, a, c) {\n    var d = J(b) && \"$\" in b;\n    !0 === a ? a = ha : G(a) || (a = function(a, b) {\n      if (J(a) || J(b))\n        return !1;\n      a = z(\"\" + a);\n      b = z(\"\" + b);\n      return -1 !== a.indexOf(b);\n    });\n    return function(e) {\n      return d && !J(e) ? Ha(e, b.$, a, !1) : Ha(e, b, a, c);\n    };\n  }\n  function Ha(b, a, c, d, e) {\n    var f = null !== b ? typeof b : \"null\",\n        g = null !== a ? typeof a : \"null\";\n    if (\"string\" === g && \"!\" === a.charAt(0))\n      return !Ha(b, a.substring(1), c, d);\n    if (H(b))\n      return b.some(function(b) {\n        return Ha(b, a, c, d);\n      });\n    switch (f) {\n      case \"object\":\n        var h;\n        if (d) {\n          for (h in b)\n            if (\"$\" !== h.charAt(0) && Ha(b[h], a, c, !0))\n              return !0;\n          return e ? !1 : Ha(b, a, c, !1);\n        }\n        if (\"object\" === g) {\n          for (h in a)\n            if (e = a[h], !G(e) && !x(e) && (f = \"$\" === h, !Ha(f ? b : b[h], e, c, f, f)))\n              return !1;\n          return !0;\n        }\n        return c(b, a);\n      case \"function\":\n        return !1;\n      default:\n        return c(b, a);\n    }\n  }\n  function jd(b) {\n    var a = b.NUMBER_FORMATS;\n    return function(b, d, e) {\n      x(d) && (d = a.CURRENCY_SYM);\n      x(e) && (e = a.PATTERNS[1].maxFrac);\n      return null == b ? b : nd(b, a.PATTERNS[1], a.GROUP_SEP, a.DECIMAL_SEP, e).replace(/\\u00A4/g, d);\n    };\n  }\n  function ld(b) {\n    var a = b.NUMBER_FORMATS;\n    return function(b, d) {\n      return null == b ? b : nd(b, a.PATTERNS[0], a.GROUP_SEP, a.DECIMAL_SEP, d);\n    };\n  }\n  function nd(b, a, c, d, e) {\n    if (!isFinite(b) || J(b))\n      return \"\";\n    var f = 0 > b;\n    b = Math.abs(b);\n    var g = b + \"\",\n        h = \"\",\n        l = [],\n        k = !1;\n    if (-1 !== g.indexOf(\"e\")) {\n      var n = g.match(/([\\d\\.]+)e(-?)(\\d+)/);\n      n && \"-\" == n[2] && n[3] > e + 1 ? b = 0 : (h = g, k = !0);\n    }\n    if (k)\n      0 < e && 1 > b && (h = b.toFixed(e), b = parseFloat(h));\n    else {\n      g = (g.split(od)[1] || \"\").length;\n      x(e) && (e = Math.min(Math.max(a.minFrac, g), a.maxFrac));\n      b = +(Math.round(+(b.toString() + \"e\" + e)).toString() + \"e\" + -e);\n      var g = (\"\" + b).split(od),\n          k = g[0],\n          g = g[1] || \"\",\n          p = 0,\n          q = a.lgSize,\n          u = a.gSize;\n      if (k.length >= q + u)\n        for (p = k.length - q, n = 0; n < p; n++)\n          0 === (p - n) % u && 0 !== n && (h += c), h += k.charAt(n);\n      for (n = p; n < k.length; n++)\n        0 === (k.length - n) % q && 0 !== n && (h += c), h += k.charAt(n);\n      for (; g.length < e; )\n        g += \"0\";\n      e && \"0\" !== e && (h += d + g.substr(0, e));\n    }\n    0 === b && (f = !1);\n    l.push(f ? a.negPre : a.posPre, h, f ? a.negSuf : a.posSuf);\n    return l.join(\"\");\n  }\n  function Ib(b, a, c) {\n    var d = \"\";\n    0 > b && (d = \"-\", b = -b);\n    for (b = \"\" + b; b.length < a; )\n      b = \"0\" + b;\n    c && (b = b.substr(b.length - a));\n    return d + b;\n  }\n  function U(b, a, c, d) {\n    c = c || 0;\n    return function(e) {\n      e = e[\"get\" + b]();\n      if (0 < c || e > -c)\n        e += c;\n      0 === e && -12 == c && (e = 12);\n      return Ib(e, a, d);\n    };\n  }\n  function Jb(b, a) {\n    return function(c, d) {\n      var e = c[\"get\" + b](),\n          f = ub(a ? \"SHORT\" + b : b);\n      return d[f][e];\n    };\n  }\n  function pd(b) {\n    var a = (new Date(b, 0, 1)).getDay();\n    return new Date(b, 0, (4 >= a ? 5 : 12) - a);\n  }\n  function qd(b) {\n    return function(a) {\n      var c = pd(a.getFullYear());\n      a = +new Date(a.getFullYear(), a.getMonth(), a.getDate() + (4 - a.getDay())) - +c;\n      a = 1 + Math.round(a / 6048E5);\n      return Ib(a, b);\n    };\n  }\n  function ic(b, a) {\n    return 0 >= b.getFullYear() ? a.ERAS[0] : a.ERAS[1];\n  }\n  function kd(b) {\n    function a(a) {\n      var b;\n      if (b = a.match(c)) {\n        a = new Date(0);\n        var f = 0,\n            g = 0,\n            h = b[8] ? a.setUTCFullYear : a.setFullYear,\n            l = b[8] ? a.setUTCHours : a.setHours;\n        b[9] && (f = aa(b[9] + b[10]), g = aa(b[9] + b[11]));\n        h.call(a, aa(b[1]), aa(b[2]) - 1, aa(b[3]));\n        f = aa(b[4] || 0) - f;\n        g = aa(b[5] || 0) - g;\n        h = aa(b[6] || 0);\n        b = Math.round(1E3 * parseFloat(\"0.\" + (b[7] || 0)));\n        l.call(a, f, g, h, b);\n      }\n      return a;\n    }\n    var c = /^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;\n    return function(c, e, f) {\n      var g = \"\",\n          h = [],\n          l,\n          k;\n      e = e || \"mediumDate\";\n      e = b.DATETIME_FORMATS[e] || e;\n      C(c) && (c = Kf.test(c) ? aa(c) : a(c));\n      Y(c) && (c = new Date(c));\n      if (!ga(c))\n        return c;\n      for (; e; )\n        (k = Lf.exec(e)) ? (h = Ya(h, k, 1), e = h.pop()) : (h.push(e), e = null);\n      f && \"UTC\" === f && (c = new Date(c.getTime()), c.setMinutes(c.getMinutes() + c.getTimezoneOffset()));\n      r(h, function(a) {\n        l = Mf[a];\n        g += l ? l(c, b.DATETIME_FORMATS) : a.replace(/(^'|'$)/g, \"\").replace(/''/g, \"'\");\n      });\n      return g;\n    };\n  }\n  function Ff() {\n    return function(b, a) {\n      x(a) && (a = 2);\n      return $a(b, a);\n    };\n  }\n  function Gf() {\n    return function(b, a) {\n      Y(b) && (b = b.toString());\n      return H(b) || C(b) ? (a = Infinity === Math.abs(Number(a)) ? Number(a) : aa(a)) ? 0 < a ? b.slice(0, a) : b.slice(a) : C(b) ? \"\" : [] : b;\n    };\n  }\n  function md(b) {\n    return function(a, c, d) {\n      function e(a, b) {\n        return b ? function(b, c) {\n          return a(c, b);\n        } : a;\n      }\n      function f(a) {\n        switch (typeof a) {\n          case \"number\":\n          case \"boolean\":\n          case \"string\":\n            return !0;\n          default:\n            return !1;\n        }\n      }\n      function g(a) {\n        return null === a ? \"null\" : \"function\" === typeof a.valueOf && (a = a.valueOf(), f(a)) || \"function\" === typeof a.toString && (a = a.toString(), f(a)) ? a : \"\";\n      }\n      function h(a, b) {\n        var c = typeof a,\n            d = typeof b;\n        c === d && \"object\" === c && (a = g(a), b = g(b));\n        return c === d ? (\"string\" === c && (a = a.toLowerCase(), b = b.toLowerCase()), a === b ? 0 : a < b ? -1 : 1) : c < d ? -1 : 1;\n      }\n      if (!Sa(a))\n        return a;\n      c = H(c) ? c : [c];\n      0 === c.length && (c = [\"+\"]);\n      c = c.map(function(a) {\n        var c = !1,\n            d = a || ra;\n        if (C(a)) {\n          if (\"+\" == a.charAt(0) || \"-\" == a.charAt(0))\n            c = \"-\" == a.charAt(0), a = a.substring(1);\n          if (\"\" === a)\n            return e(h, c);\n          d = b(a);\n          if (d.constant) {\n            var f = d();\n            return e(function(a, b) {\n              return h(a[f], b[f]);\n            }, c);\n          }\n        }\n        return e(function(a, b) {\n          return h(d(a), d(b));\n        }, c);\n      });\n      return Za.call(a).sort(e(function(a, b) {\n        for (var d = 0; d < c.length; d++) {\n          var e = c[d](a, b);\n          if (0 !== e)\n            return e;\n        }\n        return 0;\n      }, d));\n    };\n  }\n  function Ia(b) {\n    G(b) && (b = {link: b});\n    b.restrict = b.restrict || \"AC\";\n    return ea(b);\n  }\n  function rd(b, a, c, d, e) {\n    var f = this,\n        g = [],\n        h = f.$$parentForm = b.parent().controller(\"form\") || Kb;\n    f.$error = {};\n    f.$$success = {};\n    f.$pending = t;\n    f.$name = e(a.name || a.ngForm || \"\")(c);\n    f.$dirty = !1;\n    f.$pristine = !0;\n    f.$valid = !0;\n    f.$invalid = !1;\n    f.$submitted = !1;\n    h.$addControl(f);\n    f.$rollbackViewValue = function() {\n      r(g, function(a) {\n        a.$rollbackViewValue();\n      });\n    };\n    f.$commitViewValue = function() {\n      r(g, function(a) {\n        a.$commitViewValue();\n      });\n    };\n    f.$addControl = function(a) {\n      La(a.$name, \"input\");\n      g.push(a);\n      a.$name && (f[a.$name] = a);\n    };\n    f.$$renameControl = function(a, b) {\n      var c = a.$name;\n      f[c] === a && delete f[c];\n      f[b] = a;\n      a.$name = b;\n    };\n    f.$removeControl = function(a) {\n      a.$name && f[a.$name] === a && delete f[a.$name];\n      r(f.$pending, function(b, c) {\n        f.$setValidity(c, null, a);\n      });\n      r(f.$error, function(b, c) {\n        f.$setValidity(c, null, a);\n      });\n      r(f.$$success, function(b, c) {\n        f.$setValidity(c, null, a);\n      });\n      Xa(g, a);\n    };\n    sd({\n      ctrl: this,\n      $element: b,\n      set: function(a, b, c) {\n        var d = a[b];\n        d ? -1 === d.indexOf(c) && d.push(c) : a[b] = [c];\n      },\n      unset: function(a, b, c) {\n        var d = a[b];\n        d && (Xa(d, c), 0 === d.length && delete a[b]);\n      },\n      parentForm: h,\n      $animate: d\n    });\n    f.$setDirty = function() {\n      d.removeClass(b, Ra);\n      d.addClass(b, Lb);\n      f.$dirty = !0;\n      f.$pristine = !1;\n      h.$setDirty();\n    };\n    f.$setPristine = function() {\n      d.setClass(b, Ra, Lb + \" ng-submitted\");\n      f.$dirty = !1;\n      f.$pristine = !0;\n      f.$submitted = !1;\n      r(g, function(a) {\n        a.$setPristine();\n      });\n    };\n    f.$setUntouched = function() {\n      r(g, function(a) {\n        a.$setUntouched();\n      });\n    };\n    f.$setSubmitted = function() {\n      d.addClass(b, \"ng-submitted\");\n      f.$submitted = !0;\n      h.$setSubmitted();\n    };\n  }\n  function jc(b) {\n    b.$formatters.push(function(a) {\n      return b.$isEmpty(a) ? a : a.toString();\n    });\n  }\n  function jb(b, a, c, d, e, f) {\n    var g = z(a[0].type);\n    if (!e.android) {\n      var h = !1;\n      a.on(\"compositionstart\", function(a) {\n        h = !0;\n      });\n      a.on(\"compositionend\", function() {\n        h = !1;\n        l();\n      });\n    }\n    var l = function(b) {\n      k && (f.defer.cancel(k), k = null);\n      if (!h) {\n        var e = a.val();\n        b = b && b.type;\n        \"password\" === g || c.ngTrim && \"false\" === c.ngTrim || (e = N(e));\n        (d.$viewValue !== e || \"\" === e && d.$$hasNativeValidators) && d.$setViewValue(e, b);\n      }\n    };\n    if (e.hasEvent(\"input\"))\n      a.on(\"input\", l);\n    else {\n      var k,\n          n = function(a, b, c) {\n            k || (k = f.defer(function() {\n              k = null;\n              b && b.value === c || l(a);\n            }));\n          };\n      a.on(\"keydown\", function(a) {\n        var b = a.keyCode;\n        91 === b || 15 < b && 19 > b || 37 <= b && 40 >= b || n(a, this, this.value);\n      });\n      if (e.hasEvent(\"paste\"))\n        a.on(\"paste cut\", n);\n    }\n    a.on(\"change\", l);\n    d.$render = function() {\n      a.val(d.$isEmpty(d.$viewValue) ? \"\" : d.$viewValue);\n    };\n  }\n  function Mb(b, a) {\n    return function(c, d) {\n      var e,\n          f;\n      if (ga(c))\n        return c;\n      if (C(c)) {\n        '\"' == c.charAt(0) && '\"' == c.charAt(c.length - 1) && (c = c.substring(1, c.length - 1));\n        if (Nf.test(c))\n          return new Date(c);\n        b.lastIndex = 0;\n        if (e = b.exec(c))\n          return e.shift(), f = d ? {\n            yyyy: d.getFullYear(),\n            MM: d.getMonth() + 1,\n            dd: d.getDate(),\n            HH: d.getHours(),\n            mm: d.getMinutes(),\n            ss: d.getSeconds(),\n            sss: d.getMilliseconds() / 1E3\n          } : {\n            yyyy: 1970,\n            MM: 1,\n            dd: 1,\n            HH: 0,\n            mm: 0,\n            ss: 0,\n            sss: 0\n          }, r(e, function(b, c) {\n            c < a.length && (f[a[c]] = +b);\n          }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1E3 * f.sss || 0);\n      }\n      return NaN;\n    };\n  }\n  function kb(b, a, c, d) {\n    return function(e, f, g, h, l, k, n) {\n      function p(a) {\n        return a && !(a.getTime && a.getTime() !== a.getTime());\n      }\n      function q(a) {\n        return y(a) ? ga(a) ? a : c(a) : t;\n      }\n      td(e, f, g, h);\n      jb(e, f, g, h, l, k);\n      var u = h && h.$options && h.$options.timezone,\n          s;\n      h.$$parserName = b;\n      h.$parsers.push(function(b) {\n        return h.$isEmpty(b) ? null : a.test(b) ? (b = c(b, s), \"UTC\" === u && b.setMinutes(b.getMinutes() - b.getTimezoneOffset()), b) : t;\n      });\n      h.$formatters.push(function(a) {\n        if (a && !ga(a))\n          throw Nb(\"datefmt\", a);\n        if (p(a)) {\n          if ((s = a) && \"UTC\" === u) {\n            var b = 6E4 * s.getTimezoneOffset();\n            s = new Date(s.getTime() + b);\n          }\n          return n(\"date\")(a, d, u);\n        }\n        s = null;\n        return \"\";\n      });\n      if (y(g.min) || g.ngMin) {\n        var r;\n        h.$validators.min = function(a) {\n          return !p(a) || x(r) || c(a) >= r;\n        };\n        g.$observe(\"min\", function(a) {\n          r = q(a);\n          h.$validate();\n        });\n      }\n      if (y(g.max) || g.ngMax) {\n        var v;\n        h.$validators.max = function(a) {\n          return !p(a) || x(v) || c(a) <= v;\n        };\n        g.$observe(\"max\", function(a) {\n          v = q(a);\n          h.$validate();\n        });\n      }\n    };\n  }\n  function td(b, a, c, d) {\n    (d.$$hasNativeValidators = J(a[0].validity)) && d.$parsers.push(function(b) {\n      var c = a.prop(\"validity\") || {};\n      return c.badInput && !c.typeMismatch ? t : b;\n    });\n  }\n  function ud(b, a, c, d, e) {\n    if (y(d)) {\n      b = b(d);\n      if (!b.constant)\n        throw R(\"ngModel\")(\"constexpr\", c, d);\n      return b(a);\n    }\n    return e;\n  }\n  function kc(b, a) {\n    b = \"ngClass\" + b;\n    return [\"$animate\", function(c) {\n      function d(a, b) {\n        var c = [],\n            d = 0;\n        a: for (; d < a.length; d++) {\n          for (var e = a[d],\n              n = 0; n < b.length; n++)\n            if (e == b[n])\n              continue a;\n          c.push(e);\n        }\n        return c;\n      }\n      function e(a) {\n        if (!H(a)) {\n          if (C(a))\n            return a.split(\" \");\n          if (J(a)) {\n            var b = [];\n            r(a, function(a, c) {\n              a && (b = b.concat(c.split(\" \")));\n            });\n            return b;\n          }\n        }\n        return a;\n      }\n      return {\n        restrict: \"AC\",\n        link: function(f, g, h) {\n          function l(a, b) {\n            var c = g.data(\"$classCounts\") || {},\n                d = [];\n            r(a, function(a) {\n              if (0 < b || c[a])\n                c[a] = (c[a] || 0) + b, c[a] === +(0 < b) && d.push(a);\n            });\n            g.data(\"$classCounts\", c);\n            return d.join(\" \");\n          }\n          function k(b) {\n            if (!0 === a || f.$index % 2 === a) {\n              var k = e(b || []);\n              if (!n) {\n                var u = l(k, 1);\n                h.$addClass(u);\n              } else if (!ha(b, n)) {\n                var s = e(n),\n                    u = d(k, s),\n                    k = d(s, k),\n                    u = l(u, 1),\n                    k = l(k, -1);\n                u && u.length && c.addClass(g, u);\n                k && k.length && c.removeClass(g, k);\n              }\n            }\n            n = sa(b);\n          }\n          var n;\n          f.$watch(h[b], k, !0);\n          h.$observe(\"class\", function(a) {\n            k(f.$eval(h[b]));\n          });\n          \"ngClass\" !== b && f.$watch(\"$index\", function(c, d) {\n            var g = c & 1;\n            if (g !== (d & 1)) {\n              var k = e(f.$eval(h[b]));\n              g === a ? (g = l(k, 1), h.$addClass(g)) : (g = l(k, -1), h.$removeClass(g));\n            }\n          });\n        }\n      };\n    }];\n  }\n  function sd(b) {\n    function a(a, b) {\n      b && !f[a] ? (k.addClass(e, a), f[a] = !0) : !b && f[a] && (k.removeClass(e, a), f[a] = !1);\n    }\n    function c(b, c) {\n      b = b ? \"-\" + vc(b, \"-\") : \"\";\n      a(lb + b, !0 === c);\n      a(vd + b, !1 === c);\n    }\n    var d = b.ctrl,\n        e = b.$element,\n        f = {},\n        g = b.set,\n        h = b.unset,\n        l = b.parentForm,\n        k = b.$animate;\n    f[vd] = !(f[lb] = e.hasClass(lb));\n    d.$setValidity = function(b, e, f) {\n      e === t ? (d.$pending || (d.$pending = {}), g(d.$pending, b, f)) : (d.$pending && h(d.$pending, b, f), wd(d.$pending) && (d.$pending = t));\n      Wa(e) ? e ? (h(d.$error, b, f), g(d.$$success, b, f)) : (g(d.$error, b, f), h(d.$$success, b, f)) : (h(d.$error, b, f), h(d.$$success, b, f));\n      d.$pending ? (a(xd, !0), d.$valid = d.$invalid = t, c(\"\", null)) : (a(xd, !1), d.$valid = wd(d.$error), d.$invalid = !d.$valid, c(\"\", d.$valid));\n      e = d.$pending && d.$pending[b] ? t : d.$error[b] ? !1 : d.$$success[b] ? !0 : null;\n      c(b, e);\n      l.$setValidity(b, e, d);\n    };\n  }\n  function wd(b) {\n    if (b)\n      for (var a in b)\n        return !1;\n    return !0;\n  }\n  var Of = /^\\/(.+)\\/([a-z]*)$/,\n      z = function(b) {\n        return C(b) ? b.toLowerCase() : b;\n      },\n      tc = Object.prototype.hasOwnProperty,\n      ub = function(b) {\n        return C(b) ? b.toUpperCase() : b;\n      },\n      Qa,\n      A,\n      ta,\n      Za = [].slice,\n      qf = [].splice,\n      Pf = [].push,\n      Ca = Object.prototype.toString,\n      Ja = R(\"ng\"),\n      ca = Q.angular || (Q.angular = {}),\n      cb,\n      ob = 0;\n  Qa = W.documentMode;\n  E.$inject = [];\n  ra.$inject = [];\n  var H = Array.isArray,\n      N = function(b) {\n        return C(b) ? b.trim() : b;\n      },\n      gd = function(b) {\n        return b.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\").replace(/\\x08/g, \"\\\\x08\");\n      },\n      bb = function() {\n        if (y(bb.isActive_))\n          return bb.isActive_;\n        var b = !(!W.querySelector(\"[ng-csp]\") && !W.querySelector(\"[data-ng-csp]\"));\n        if (!b)\n          try {\n            new Function(\"\");\n          } catch (a) {\n            b = !0;\n          }\n        return bb.isActive_ = b;\n      },\n      rb = [\"ng-\", \"data-ng-\", \"ng:\", \"x-ng-\"],\n      Md = /[A-Z]/g,\n      wc = !1,\n      Qb,\n      qa = 1,\n      pb = 3,\n      Qd = {\n        full: \"1.3.15\",\n        major: 1,\n        minor: 3,\n        dot: 15,\n        codeName: \"locality-filtration\"\n      };\n  T.expando = \"ng339\";\n  var zb = T.cache = {},\n      hf = 1;\n  T._data = function(b) {\n    return this.cache[b[this.expando]] || {};\n  };\n  var cf = /([\\:\\-\\_]+(.))/g,\n      df = /^moz([A-Z])/,\n      Qf = {\n        mouseleave: \"mouseout\",\n        mouseenter: \"mouseover\"\n      },\n      Tb = R(\"jqLite\"),\n      gf = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      Sb = /<|&#?\\w+;/,\n      ef = /<([\\w:]+)/,\n      ff = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      ja = {\n        option: [1, '<select multiple=\"multiple\">', \"</select>\"],\n        thead: [1, \"<table>\", \"</table>\"],\n        col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n        tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n        td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n        _default: [0, \"\", \"\"]\n      };\n  ja.optgroup = ja.option;\n  ja.tbody = ja.tfoot = ja.colgroup = ja.caption = ja.thead;\n  ja.th = ja.td;\n  var Ka = T.prototype = {\n    ready: function(b) {\n      function a() {\n        c || (c = !0, b());\n      }\n      var c = !1;\n      \"complete\" === W.readyState ? setTimeout(a) : (this.on(\"DOMContentLoaded\", a), T(Q).on(\"load\", a));\n    },\n    toString: function() {\n      var b = [];\n      r(this, function(a) {\n        b.push(\"\" + a);\n      });\n      return \"[\" + b.join(\", \") + \"]\";\n    },\n    eq: function(b) {\n      return 0 <= b ? A(this[b]) : A(this[this.length + b]);\n    },\n    length: 0,\n    push: Pf,\n    sort: [].sort,\n    splice: [].splice\n  },\n      Eb = {};\n  r(\"multiple selected checked disabled readOnly required open\".split(\" \"), function(b) {\n    Eb[z(b)] = b;\n  });\n  var Oc = {};\n  r(\"input select option textarea button form details\".split(\" \"), function(b) {\n    Oc[b] = !0;\n  });\n  var Pc = {\n    ngMinlength: \"minlength\",\n    ngMaxlength: \"maxlength\",\n    ngMin: \"min\",\n    ngMax: \"max\",\n    ngPattern: \"pattern\"\n  };\n  r({\n    data: Vb,\n    removeData: xb\n  }, function(b, a) {\n    T[a] = b;\n  });\n  r({\n    data: Vb,\n    inheritedData: Db,\n    scope: function(b) {\n      return A.data(b, \"$scope\") || Db(b.parentNode || b, [\"$isolateScope\", \"$scope\"]);\n    },\n    isolateScope: function(b) {\n      return A.data(b, \"$isolateScope\") || A.data(b, \"$isolateScopeNoTemplate\");\n    },\n    controller: Kc,\n    injector: function(b) {\n      return Db(b, \"$injector\");\n    },\n    removeAttr: function(b, a) {\n      b.removeAttribute(a);\n    },\n    hasClass: Ab,\n    css: function(b, a, c) {\n      a = db(a);\n      if (y(c))\n        b.style[a] = c;\n      else\n        return b.style[a];\n    },\n    attr: function(b, a, c) {\n      var d = z(a);\n      if (Eb[d])\n        if (y(c))\n          c ? (b[a] = !0, b.setAttribute(a, d)) : (b[a] = !1, b.removeAttribute(d));\n        else\n          return b[a] || (b.attributes.getNamedItem(a) || E).specified ? d : t;\n      else if (y(c))\n        b.setAttribute(a, c);\n      else if (b.getAttribute)\n        return b = b.getAttribute(a, 2), null === b ? t : b;\n    },\n    prop: function(b, a, c) {\n      if (y(c))\n        b[a] = c;\n      else\n        return b[a];\n    },\n    text: function() {\n      function b(a, b) {\n        if (x(b)) {\n          var d = a.nodeType;\n          return d === qa || d === pb ? a.textContent : \"\";\n        }\n        a.textContent = b;\n      }\n      b.$dv = \"\";\n      return b;\n    }(),\n    val: function(b, a) {\n      if (x(a)) {\n        if (b.multiple && \"select\" === va(b)) {\n          var c = [];\n          r(b.options, function(a) {\n            a.selected && c.push(a.value || a.text);\n          });\n          return 0 === c.length ? null : c;\n        }\n        return b.value;\n      }\n      b.value = a;\n    },\n    html: function(b, a) {\n      if (x(a))\n        return b.innerHTML;\n      wb(b, !0);\n      b.innerHTML = a;\n    },\n    empty: Lc\n  }, function(b, a) {\n    T.prototype[a] = function(a, d) {\n      var e,\n          f,\n          g = this.length;\n      if (b !== Lc && (2 == b.length && b !== Ab && b !== Kc ? a : d) === t) {\n        if (J(a)) {\n          for (e = 0; e < g; e++)\n            if (b === Vb)\n              b(this[e], a);\n            else\n              for (f in a)\n                b(this[e], f, a[f]);\n          return this;\n        }\n        e = b.$dv;\n        g = e === t ? Math.min(g, 1) : g;\n        for (f = 0; f < g; f++) {\n          var h = b(this[f], a, d);\n          e = e ? e + h : h;\n        }\n        return e;\n      }\n      for (e = 0; e < g; e++)\n        b(this[e], a, d);\n      return this;\n    };\n  });\n  r({\n    removeData: xb,\n    on: function a(c, d, e, f) {\n      if (y(f))\n        throw Tb(\"onargs\");\n      if (Gc(c)) {\n        var g = yb(c, !0);\n        f = g.events;\n        var h = g.handle;\n        h || (h = g.handle = lf(c, f));\n        for (var g = 0 <= d.indexOf(\" \") ? d.split(\" \") : [d],\n            l = g.length; l--; ) {\n          d = g[l];\n          var k = f[d];\n          k || (f[d] = [], \"mouseenter\" === d || \"mouseleave\" === d ? a(c, Qf[d], function(a) {\n            var c = a.relatedTarget;\n            c && (c === this || this.contains(c)) || h(a, d);\n          }) : \"$destroy\" !== d && c.addEventListener(d, h, !1), k = f[d]);\n          k.push(e);\n        }\n      }\n    },\n    off: Jc,\n    one: function(a, c, d) {\n      a = A(a);\n      a.on(c, function f() {\n        a.off(c, d);\n        a.off(c, f);\n      });\n      a.on(c, d);\n    },\n    replaceWith: function(a, c) {\n      var d,\n          e = a.parentNode;\n      wb(a);\n      r(new T(c), function(c) {\n        d ? e.insertBefore(c, d.nextSibling) : e.replaceChild(c, a);\n        d = c;\n      });\n    },\n    children: function(a) {\n      var c = [];\n      r(a.childNodes, function(a) {\n        a.nodeType === qa && c.push(a);\n      });\n      return c;\n    },\n    contents: function(a) {\n      return a.contentDocument || a.childNodes || [];\n    },\n    append: function(a, c) {\n      var d = a.nodeType;\n      if (d === qa || 11 === d) {\n        c = new T(c);\n        for (var d = 0,\n            e = c.length; d < e; d++)\n          a.appendChild(c[d]);\n      }\n    },\n    prepend: function(a, c) {\n      if (a.nodeType === qa) {\n        var d = a.firstChild;\n        r(new T(c), function(c) {\n          a.insertBefore(c, d);\n        });\n      }\n    },\n    wrap: function(a, c) {\n      c = A(c).eq(0).clone()[0];\n      var d = a.parentNode;\n      d && d.replaceChild(c, a);\n      c.appendChild(a);\n    },\n    remove: Mc,\n    detach: function(a) {\n      Mc(a, !0);\n    },\n    after: function(a, c) {\n      var d = a,\n          e = a.parentNode;\n      c = new T(c);\n      for (var f = 0,\n          g = c.length; f < g; f++) {\n        var h = c[f];\n        e.insertBefore(h, d.nextSibling);\n        d = h;\n      }\n    },\n    addClass: Cb,\n    removeClass: Bb,\n    toggleClass: function(a, c, d) {\n      c && r(c.split(\" \"), function(c) {\n        var f = d;\n        x(f) && (f = !Ab(a, c));\n        (f ? Cb : Bb)(a, c);\n      });\n    },\n    parent: function(a) {\n      return (a = a.parentNode) && 11 !== a.nodeType ? a : null;\n    },\n    next: function(a) {\n      return a.nextElementSibling;\n    },\n    find: function(a, c) {\n      return a.getElementsByTagName ? a.getElementsByTagName(c) : [];\n    },\n    clone: Ub,\n    triggerHandler: function(a, c, d) {\n      var e,\n          f,\n          g = c.type || c,\n          h = yb(a);\n      if (h = (h = h && h.events) && h[g])\n        e = {\n          preventDefault: function() {\n            this.defaultPrevented = !0;\n          },\n          isDefaultPrevented: function() {\n            return !0 === this.defaultPrevented;\n          },\n          stopImmediatePropagation: function() {\n            this.immediatePropagationStopped = !0;\n          },\n          isImmediatePropagationStopped: function() {\n            return !0 === this.immediatePropagationStopped;\n          },\n          stopPropagation: E,\n          type: g,\n          target: a\n        }, c.type && (e = w(e, c)), c = sa(h), f = d ? [e].concat(d) : [e], r(c, function(c) {\n          e.isImmediatePropagationStopped() || c.apply(a, f);\n        });\n    }\n  }, function(a, c) {\n    T.prototype[c] = function(c, e, f) {\n      for (var g,\n          h = 0,\n          l = this.length; h < l; h++)\n        x(g) ? (g = a(this[h], c, e, f), y(g) && (g = A(g))) : Ic(g, a(this[h], c, e, f));\n      return y(g) ? g : this;\n    };\n    T.prototype.bind = T.prototype.on;\n    T.prototype.unbind = T.prototype.off;\n  });\n  eb.prototype = {\n    put: function(a, c) {\n      this[Ma(a, this.nextUid)] = c;\n    },\n    get: function(a) {\n      return this[Ma(a, this.nextUid)];\n    },\n    remove: function(a) {\n      var c = this[a = Ma(a, this.nextUid)];\n      delete this[a];\n      return c;\n    }\n  };\n  var Rc = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n      Rf = /,/,\n      Sf = /^\\s*(_?)(\\S+?)\\1\\s*$/,\n      Qc = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,\n      Fa = R(\"$injector\");\n  ab.$$annotate = function(a, c, d) {\n    var e;\n    if (\"function\" === typeof a) {\n      if (!(e = a.$inject)) {\n        e = [];\n        if (a.length) {\n          if (c)\n            throw C(d) && d || (d = a.name || mf(a)), Fa(\"strictdi\", d);\n          c = a.toString().replace(Qc, \"\");\n          c = c.match(Rc);\n          r(c[1].split(Rf), function(a) {\n            a.replace(Sf, function(a, c, d) {\n              e.push(d);\n            });\n          });\n        }\n        a.$inject = e;\n      }\n    } else\n      H(a) ? (c = a.length - 1, sb(a[c], \"fn\"), e = a.slice(0, c)) : sb(a, \"fn\", !0);\n    return e;\n  };\n  var Tf = R(\"$animate\"),\n      Ce = [\"$provide\", function(a) {\n        this.$$selectors = {};\n        this.register = function(c, d) {\n          var e = c + \"-animation\";\n          if (c && \".\" != c.charAt(0))\n            throw Tf(\"notcsel\", c);\n          this.$$selectors[c.substr(1)] = e;\n          a.factory(e, d);\n        };\n        this.classNameFilter = function(a) {\n          1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp ? a : null);\n          return this.$$classNameFilter;\n        };\n        this.$get = [\"$$q\", \"$$asyncCallback\", \"$rootScope\", function(a, d, e) {\n          function f(d) {\n            var f,\n                g = a.defer();\n            g.promise.$$cancelFn = function() {\n              f && f();\n            };\n            e.$$postDigest(function() {\n              f = d(function() {\n                g.resolve();\n              });\n            });\n            return g.promise;\n          }\n          function g(a, c) {\n            var d = [],\n                e = [],\n                f = ia();\n            r((a.attr(\"class\") || \"\").split(/\\s+/), function(a) {\n              f[a] = !0;\n            });\n            r(c, function(a, c) {\n              var g = f[c];\n              !1 === a && g ? e.push(c) : !0 !== a || g || d.push(c);\n            });\n            return 0 < d.length + e.length && [d.length ? d : null, e.length ? e : null];\n          }\n          function h(a, c, d) {\n            for (var e = 0,\n                f = c.length; e < f; ++e)\n              a[c[e]] = d;\n          }\n          function l() {\n            n || (n = a.defer(), d(function() {\n              n.resolve();\n              n = null;\n            }));\n            return n.promise;\n          }\n          function k(a, c) {\n            if (ca.isObject(c)) {\n              var d = w(c.from || {}, c.to || {});\n              a.css(d);\n            }\n          }\n          var n;\n          return {\n            animate: function(a, c, d) {\n              k(a, {\n                from: c,\n                to: d\n              });\n              return l();\n            },\n            enter: function(a, c, d, e) {\n              k(a, e);\n              d ? d.after(a) : c.prepend(a);\n              return l();\n            },\n            leave: function(a, c) {\n              k(a, c);\n              a.remove();\n              return l();\n            },\n            move: function(a, c, d, e) {\n              return this.enter(a, c, d, e);\n            },\n            addClass: function(a, c, d) {\n              return this.setClass(a, c, [], d);\n            },\n            $$addClassImmediately: function(a, c, d) {\n              a = A(a);\n              c = C(c) ? c : H(c) ? c.join(\" \") : \"\";\n              r(a, function(a) {\n                Cb(a, c);\n              });\n              k(a, d);\n              return l();\n            },\n            removeClass: function(a, c, d) {\n              return this.setClass(a, [], c, d);\n            },\n            $$removeClassImmediately: function(a, c, d) {\n              a = A(a);\n              c = C(c) ? c : H(c) ? c.join(\" \") : \"\";\n              r(a, function(a) {\n                Bb(a, c);\n              });\n              k(a, d);\n              return l();\n            },\n            setClass: function(a, c, d, e) {\n              var k = this,\n                  l = !1;\n              a = A(a);\n              var m = a.data(\"$$animateClasses\");\n              m ? e && m.options && (m.options = ca.extend(m.options || {}, e)) : (m = {\n                classes: {},\n                options: e\n              }, l = !0);\n              e = m.classes;\n              c = H(c) ? c : c.split(\" \");\n              d = H(d) ? d : d.split(\" \");\n              h(e, c, !0);\n              h(e, d, !1);\n              l && (m.promise = f(function(c) {\n                var d = a.data(\"$$animateClasses\");\n                a.removeData(\"$$animateClasses\");\n                if (d) {\n                  var e = g(a, d.classes);\n                  e && k.$$setClassImmediately(a, e[0], e[1], d.options);\n                }\n                c();\n              }), a.data(\"$$animateClasses\", m));\n              return m.promise;\n            },\n            $$setClassImmediately: function(a, c, d, e) {\n              c && this.$$addClassImmediately(a, c);\n              d && this.$$removeClassImmediately(a, d);\n              k(a, e);\n              return l();\n            },\n            enabled: E,\n            cancel: E\n          };\n        }];\n      }],\n      la = R(\"$compile\");\n  yc.$inject = [\"$provide\", \"$$sanitizeUriProvider\"];\n  var Sc = /^((?:x|data)[\\:\\-_])/i,\n      rf = R(\"$controller\"),\n      Wc = \"application/json\",\n      $b = {\"Content-Type\": Wc + \";charset=utf-8\"},\n      tf = /^\\[|^\\{(?!\\{)/,\n      uf = {\n        \"[\": /]$/,\n        \"{\": /}$/\n      },\n      sf = /^\\)\\]\\}',?\\n/,\n      ac = R(\"$interpolate\"),\n      Uf = /^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/,\n      xf = {\n        http: 80,\n        https: 443,\n        ftp: 21\n      },\n      Gb = R(\"$location\"),\n      Vf = {\n        $$html5: !1,\n        $$replace: !1,\n        absUrl: Hb(\"$$absUrl\"),\n        url: function(a) {\n          if (x(a))\n            return this.$$url;\n          var c = Uf.exec(a);\n          (c[1] || \"\" === a) && this.path(decodeURIComponent(c[1]));\n          (c[2] || c[1] || \"\" === a) && this.search(c[3] || \"\");\n          this.hash(c[5] || \"\");\n          return this;\n        },\n        protocol: Hb(\"$$protocol\"),\n        host: Hb(\"$$host\"),\n        port: Hb(\"$$port\"),\n        path: dd(\"$$path\", function(a) {\n          a = null !== a ? a.toString() : \"\";\n          return \"/\" == a.charAt(0) ? a : \"/\" + a;\n        }),\n        search: function(a, c) {\n          switch (arguments.length) {\n            case 0:\n              return this.$$search;\n            case 1:\n              if (C(a) || Y(a))\n                a = a.toString(), this.$$search = sc(a);\n              else if (J(a))\n                a = Da(a, {}), r(a, function(c, e) {\n                  null == c && delete a[e];\n                }), this.$$search = a;\n              else\n                throw Gb(\"isrcharg\");\n              break;\n            default:\n              x(c) || null === c ? delete this.$$search[a] : this.$$search[a] = c;\n          }\n          this.$$compose();\n          return this;\n        },\n        hash: dd(\"$$hash\", function(a) {\n          return null !== a ? a.toString() : \"\";\n        }),\n        replace: function() {\n          this.$$replace = !0;\n          return this;\n        }\n      };\n  r([cd, ec, dc], function(a) {\n    a.prototype = Object.create(Vf);\n    a.prototype.state = function(c) {\n      if (!arguments.length)\n        return this.$$state;\n      if (a !== dc || !this.$$html5)\n        throw Gb(\"nostate\");\n      this.$$state = x(c) ? null : c;\n      return this;\n    };\n  });\n  var na = R(\"$parse\"),\n      Wf = Function.prototype.call,\n      Xf = Function.prototype.apply,\n      Yf = Function.prototype.bind,\n      mb = ia();\n  r({\n    \"null\": function() {\n      return null;\n    },\n    \"true\": function() {\n      return !0;\n    },\n    \"false\": function() {\n      return !1;\n    },\n    undefined: function() {}\n  }, function(a, c) {\n    a.constant = a.literal = a.sharedGetter = !0;\n    mb[c] = a;\n  });\n  mb[\"this\"] = function(a) {\n    return a;\n  };\n  mb[\"this\"].sharedGetter = !0;\n  var nb = w(ia(), {\n    \"+\": function(a, c, d, e) {\n      d = d(a, c);\n      e = e(a, c);\n      return y(d) ? y(e) ? d + e : d : y(e) ? e : t;\n    },\n    \"-\": function(a, c, d, e) {\n      d = d(a, c);\n      e = e(a, c);\n      return (y(d) ? d : 0) - (y(e) ? e : 0);\n    },\n    \"*\": function(a, c, d, e) {\n      return d(a, c) * e(a, c);\n    },\n    \"/\": function(a, c, d, e) {\n      return d(a, c) / e(a, c);\n    },\n    \"%\": function(a, c, d, e) {\n      return d(a, c) % e(a, c);\n    },\n    \"===\": function(a, c, d, e) {\n      return d(a, c) === e(a, c);\n    },\n    \"!==\": function(a, c, d, e) {\n      return d(a, c) !== e(a, c);\n    },\n    \"==\": function(a, c, d, e) {\n      return d(a, c) == e(a, c);\n    },\n    \"!=\": function(a, c, d, e) {\n      return d(a, c) != e(a, c);\n    },\n    \"<\": function(a, c, d, e) {\n      return d(a, c) < e(a, c);\n    },\n    \">\": function(a, c, d, e) {\n      return d(a, c) > e(a, c);\n    },\n    \"<=\": function(a, c, d, e) {\n      return d(a, c) <= e(a, c);\n    },\n    \">=\": function(a, c, d, e) {\n      return d(a, c) >= e(a, c);\n    },\n    \"&&\": function(a, c, d, e) {\n      return d(a, c) && e(a, c);\n    },\n    \"||\": function(a, c, d, e) {\n      return d(a, c) || e(a, c);\n    },\n    \"!\": function(a, c, d) {\n      return !d(a, c);\n    },\n    \"=\": !0,\n    \"|\": !0\n  }),\n      Zf = {\n        n: \"\\n\",\n        f: \"\\f\",\n        r: \"\\r\",\n        t: \"\\t\",\n        v: \"\\v\",\n        \"'\": \"'\",\n        '\"': '\"'\n      },\n      hc = function(a) {\n        this.options = a;\n      };\n  hc.prototype = {\n    constructor: hc,\n    lex: function(a) {\n      this.text = a;\n      this.index = 0;\n      for (this.tokens = []; this.index < this.text.length; )\n        if (a = this.text.charAt(this.index), '\"' === a || \"'\" === a)\n          this.readString(a);\n        else if (this.isNumber(a) || \".\" === a && this.isNumber(this.peek()))\n          this.readNumber();\n        else if (this.isIdent(a))\n          this.readIdent();\n        else if (this.is(a, \"(){}[].,;:?\"))\n          this.tokens.push({\n            index: this.index,\n            text: a\n          }), this.index++;\n        else if (this.isWhitespace(a))\n          this.index++;\n        else {\n          var c = a + this.peek(),\n              d = c + this.peek(2),\n              e = nb[c],\n              f = nb[d];\n          nb[a] || e || f ? (a = f ? d : e ? c : a, this.tokens.push({\n            index: this.index,\n            text: a,\n            operator: !0\n          }), this.index += a.length) : this.throwError(\"Unexpected next character \", this.index, this.index + 1);\n        }\n      return this.tokens;\n    },\n    is: function(a, c) {\n      return -1 !== c.indexOf(a);\n    },\n    peek: function(a) {\n      a = a || 1;\n      return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1;\n    },\n    isNumber: function(a) {\n      return \"0\" <= a && \"9\" >= a && \"string\" === typeof a;\n    },\n    isWhitespace: function(a) {\n      return \" \" === a || \"\\r\" === a || \"\\t\" === a || \"\\n\" === a || \"\\v\" === a || \"\\u00a0\" === a;\n    },\n    isIdent: function(a) {\n      return \"a\" <= a && \"z\" >= a || \"A\" <= a && \"Z\" >= a || \"_\" === a || \"$\" === a;\n    },\n    isExpOperator: function(a) {\n      return \"-\" === a || \"+\" === a || this.isNumber(a);\n    },\n    throwError: function(a, c, d) {\n      d = d || this.index;\n      c = y(c) ? \"s \" + c + \"-\" + this.index + \" [\" + this.text.substring(c, d) + \"]\" : \" \" + d;\n      throw na(\"lexerr\", a, c, this.text);\n    },\n    readNumber: function() {\n      for (var a = \"\",\n          c = this.index; this.index < this.text.length; ) {\n        var d = z(this.text.charAt(this.index));\n        if (\".\" == d || this.isNumber(d))\n          a += d;\n        else {\n          var e = this.peek();\n          if (\"e\" == d && this.isExpOperator(e))\n            a += d;\n          else if (this.isExpOperator(d) && e && this.isNumber(e) && \"e\" == a.charAt(a.length - 1))\n            a += d;\n          else if (!this.isExpOperator(d) || e && this.isNumber(e) || \"e\" != a.charAt(a.length - 1))\n            break;\n          else\n            this.throwError(\"Invalid exponent\");\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: c,\n        text: a,\n        constant: !0,\n        value: Number(a)\n      });\n    },\n    readIdent: function() {\n      for (var a = this.index; this.index < this.text.length; ) {\n        var c = this.text.charAt(this.index);\n        if (!this.isIdent(c) && !this.isNumber(c))\n          break;\n        this.index++;\n      }\n      this.tokens.push({\n        index: a,\n        text: this.text.slice(a, this.index),\n        identifier: !0\n      });\n    },\n    readString: function(a) {\n      var c = this.index;\n      this.index++;\n      for (var d = \"\",\n          e = a,\n          f = !1; this.index < this.text.length; ) {\n        var g = this.text.charAt(this.index),\n            e = e + g;\n        if (f)\n          \"u\" === g ? (f = this.text.substring(this.index + 1, this.index + 5), f.match(/[\\da-f]{4}/i) || this.throwError(\"Invalid unicode escape [\\\\u\" + f + \"]\"), this.index += 4, d += String.fromCharCode(parseInt(f, 16))) : d += Zf[g] || g, f = !1;\n        else if (\"\\\\\" === g)\n          f = !0;\n        else {\n          if (g === a) {\n            this.index++;\n            this.tokens.push({\n              index: c,\n              text: e,\n              constant: !0,\n              value: d\n            });\n            return;\n          }\n          d += g;\n        }\n        this.index++;\n      }\n      this.throwError(\"Unterminated quote\", c);\n    }\n  };\n  var ib = function(a, c, d) {\n    this.lexer = a;\n    this.$filter = c;\n    this.options = d;\n  };\n  ib.ZERO = w(function() {\n    return 0;\n  }, {\n    sharedGetter: !0,\n    constant: !0\n  });\n  ib.prototype = {\n    constructor: ib,\n    parse: function(a) {\n      this.text = a;\n      this.tokens = this.lexer.lex(a);\n      a = this.statements();\n      0 !== this.tokens.length && this.throwError(\"is an unexpected token\", this.tokens[0]);\n      a.literal = !!a.literal;\n      a.constant = !!a.constant;\n      return a;\n    },\n    primary: function() {\n      var a;\n      this.expect(\"(\") ? (a = this.filterChain(), this.consume(\")\")) : this.expect(\"[\") ? a = this.arrayDeclaration() : this.expect(\"{\") ? a = this.object() : this.peek().identifier && this.peek().text in mb ? a = mb[this.consume().text] : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError(\"not a primary expression\", this.peek());\n      for (var c,\n          d; c = this.expect(\"(\", \"[\", \".\"); )\n        \"(\" === c.text ? (a = this.functionCall(a, d), d = null) : \"[\" === c.text ? (d = a, a = this.objectIndex(a)) : \".\" === c.text ? (d = a, a = this.fieldAccess(a)) : this.throwError(\"IMPOSSIBLE\");\n      return a;\n    },\n    throwError: function(a, c) {\n      throw na(\"syntax\", c.text, a, c.index + 1, this.text, this.text.substring(c.index));\n    },\n    peekToken: function() {\n      if (0 === this.tokens.length)\n        throw na(\"ueoe\", this.text);\n      return this.tokens[0];\n    },\n    peek: function(a, c, d, e) {\n      return this.peekAhead(0, a, c, d, e);\n    },\n    peekAhead: function(a, c, d, e, f) {\n      if (this.tokens.length > a) {\n        a = this.tokens[a];\n        var g = a.text;\n        if (g === c || g === d || g === e || g === f || !(c || d || e || f))\n          return a;\n      }\n      return !1;\n    },\n    expect: function(a, c, d, e) {\n      return (a = this.peek(a, c, d, e)) ? (this.tokens.shift(), a) : !1;\n    },\n    consume: function(a) {\n      if (0 === this.tokens.length)\n        throw na(\"ueoe\", this.text);\n      var c = this.expect(a);\n      c || this.throwError(\"is unexpected, expecting [\" + a + \"]\", this.peek());\n      return c;\n    },\n    unaryFn: function(a, c) {\n      var d = nb[a];\n      return w(function(a, f) {\n        return d(a, f, c);\n      }, {\n        constant: c.constant,\n        inputs: [c]\n      });\n    },\n    binaryFn: function(a, c, d, e) {\n      var f = nb[c];\n      return w(function(c, e) {\n        return f(c, e, a, d);\n      }, {\n        constant: a.constant && d.constant,\n        inputs: !e && [a, d]\n      });\n    },\n    identifier: function() {\n      for (var a = this.consume().text; this.peek(\".\") && this.peekAhead(1).identifier && !this.peekAhead(2, \"(\"); )\n        a += this.consume().text + this.consume().text;\n      return zf(a, this.options, this.text);\n    },\n    constant: function() {\n      var a = this.consume().value;\n      return w(function() {\n        return a;\n      }, {\n        constant: !0,\n        literal: !0\n      });\n    },\n    statements: function() {\n      for (var a = []; ; )\n        if (0 < this.tokens.length && !this.peek(\"}\", \")\", \";\", \"]\") && a.push(this.filterChain()), !this.expect(\";\"))\n          return 1 === a.length ? a[0] : function(c, d) {\n            for (var e,\n                f = 0,\n                g = a.length; f < g; f++)\n              e = a[f](c, d);\n            return e;\n          };\n    },\n    filterChain: function() {\n      for (var a = this.expression(); this.expect(\"|\"); )\n        a = this.filter(a);\n      return a;\n    },\n    filter: function(a) {\n      var c = this.$filter(this.consume().text),\n          d,\n          e;\n      if (this.peek(\":\"))\n        for (d = [], e = []; this.expect(\":\"); )\n          d.push(this.expression());\n      var f = [a].concat(d || []);\n      return w(function(f, h) {\n        var l = a(f, h);\n        if (e) {\n          e[0] = l;\n          for (l = d.length; l--; )\n            e[l + 1] = d[l](f, h);\n          return c.apply(t, e);\n        }\n        return c(l);\n      }, {\n        constant: !c.$stateful && f.every(fc),\n        inputs: !c.$stateful && f\n      });\n    },\n    expression: function() {\n      return this.assignment();\n    },\n    assignment: function() {\n      var a = this.ternary(),\n          c,\n          d;\n      return (d = this.expect(\"=\")) ? (a.assign || this.throwError(\"implies assignment but [\" + this.text.substring(0, d.index) + \"] can not be assigned to\", d), c = this.ternary(), w(function(d, f) {\n        return a.assign(d, c(d, f), f);\n      }, {inputs: [a, c]})) : a;\n    },\n    ternary: function() {\n      var a = this.logicalOR(),\n          c;\n      if (this.expect(\"?\") && (c = this.assignment(), this.consume(\":\"))) {\n        var d = this.assignment();\n        return w(function(e, f) {\n          return a(e, f) ? c(e, f) : d(e, f);\n        }, {constant: a.constant && c.constant && d.constant});\n      }\n      return a;\n    },\n    logicalOR: function() {\n      for (var a = this.logicalAND(),\n          c; c = this.expect(\"||\"); )\n        a = this.binaryFn(a, c.text, this.logicalAND(), !0);\n      return a;\n    },\n    logicalAND: function() {\n      for (var a = this.equality(),\n          c; c = this.expect(\"&&\"); )\n        a = this.binaryFn(a, c.text, this.equality(), !0);\n      return a;\n    },\n    equality: function() {\n      for (var a = this.relational(),\n          c; c = this.expect(\"==\", \"!=\", \"===\", \"!==\"); )\n        a = this.binaryFn(a, c.text, this.relational());\n      return a;\n    },\n    relational: function() {\n      for (var a = this.additive(),\n          c; c = this.expect(\"<\", \">\", \"<=\", \">=\"); )\n        a = this.binaryFn(a, c.text, this.additive());\n      return a;\n    },\n    additive: function() {\n      for (var a = this.multiplicative(),\n          c; c = this.expect(\"+\", \"-\"); )\n        a = this.binaryFn(a, c.text, this.multiplicative());\n      return a;\n    },\n    multiplicative: function() {\n      for (var a = this.unary(),\n          c; c = this.expect(\"*\", \"/\", \"%\"); )\n        a = this.binaryFn(a, c.text, this.unary());\n      return a;\n    },\n    unary: function() {\n      var a;\n      return this.expect(\"+\") ? this.primary() : (a = this.expect(\"-\")) ? this.binaryFn(ib.ZERO, a.text, this.unary()) : (a = this.expect(\"!\")) ? this.unaryFn(a.text, this.unary()) : this.primary();\n    },\n    fieldAccess: function(a) {\n      var c = this.identifier();\n      return w(function(d, e, f) {\n        d = f || a(d, e);\n        return null == d ? t : c(d);\n      }, {assign: function(d, e, f) {\n          var g = a(d, f);\n          g || a.assign(d, g = {}, f);\n          return c.assign(g, e);\n        }});\n    },\n    objectIndex: function(a) {\n      var c = this.text,\n          d = this.expression();\n      this.consume(\"]\");\n      return w(function(e, f) {\n        var g = a(e, f),\n            h = d(e, f);\n        ua(h, c);\n        return g ? oa(g[h], c) : t;\n      }, {assign: function(e, f, g) {\n          var h = ua(d(e, g), c),\n              l = oa(a(e, g), c);\n          l || a.assign(e, l = {}, g);\n          return l[h] = f;\n        }});\n    },\n    functionCall: function(a, c) {\n      var d = [];\n      if (\")\" !== this.peekToken().text) {\n        do\n          d.push(this.expression());\n while (this.expect(\",\"));\n      }\n      this.consume(\")\");\n      var e = this.text,\n          f = d.length ? [] : null;\n      return function(g, h) {\n        var l = c ? c(g, h) : y(c) ? t : g,\n            k = a(g, h, l) || E;\n        if (f)\n          for (var n = d.length; n--; )\n            f[n] = oa(d[n](g, h), e);\n        oa(l, e);\n        if (k) {\n          if (k.constructor === k)\n            throw na(\"isecfn\", e);\n          if (k === Wf || k === Xf || k === Yf)\n            throw na(\"isecff\", e);\n        }\n        l = k.apply ? k.apply(l, f) : k(f[0], f[1], f[2], f[3], f[4]);\n        f && (f.length = 0);\n        return oa(l, e);\n      };\n    },\n    arrayDeclaration: function() {\n      var a = [];\n      if (\"]\" !== this.peekToken().text) {\n        do {\n          if (this.peek(\"]\"))\n            break;\n          a.push(this.expression());\n        } while (this.expect(\",\"));\n      }\n      this.consume(\"]\");\n      return w(function(c, d) {\n        for (var e = [],\n            f = 0,\n            g = a.length; f < g; f++)\n          e.push(a[f](c, d));\n        return e;\n      }, {\n        literal: !0,\n        constant: a.every(fc),\n        inputs: a\n      });\n    },\n    object: function() {\n      var a = [],\n          c = [];\n      if (\"}\" !== this.peekToken().text) {\n        do {\n          if (this.peek(\"}\"))\n            break;\n          var d = this.consume();\n          d.constant ? a.push(d.value) : d.identifier ? a.push(d.text) : this.throwError(\"invalid key\", d);\n          this.consume(\":\");\n          c.push(this.expression());\n        } while (this.expect(\",\"));\n      }\n      this.consume(\"}\");\n      return w(function(d, f) {\n        for (var g = {},\n            h = 0,\n            l = c.length; h < l; h++)\n          g[a[h]] = c[h](d, f);\n        return g;\n      }, {\n        literal: !0,\n        constant: c.every(fc),\n        inputs: c\n      });\n    }\n  };\n  var Bf = ia(),\n      Af = ia(),\n      Cf = Object.prototype.valueOf,\n      Ba = R(\"$sce\"),\n      pa = {\n        HTML: \"html\",\n        CSS: \"css\",\n        URL: \"url\",\n        RESOURCE_URL: \"resourceUrl\",\n        JS: \"js\"\n      },\n      la = R(\"$compile\"),\n      $ = W.createElement(\"a\"),\n      id = Aa(Q.location.href);\n  Fc.$inject = [\"$provide\"];\n  jd.$inject = [\"$locale\"];\n  ld.$inject = [\"$locale\"];\n  var od = \".\",\n      Mf = {\n        yyyy: U(\"FullYear\", 4),\n        yy: U(\"FullYear\", 2, 0, !0),\n        y: U(\"FullYear\", 1),\n        MMMM: Jb(\"Month\"),\n        MMM: Jb(\"Month\", !0),\n        MM: U(\"Month\", 2, 1),\n        M: U(\"Month\", 1, 1),\n        dd: U(\"Date\", 2),\n        d: U(\"Date\", 1),\n        HH: U(\"Hours\", 2),\n        H: U(\"Hours\", 1),\n        hh: U(\"Hours\", 2, -12),\n        h: U(\"Hours\", 1, -12),\n        mm: U(\"Minutes\", 2),\n        m: U(\"Minutes\", 1),\n        ss: U(\"Seconds\", 2),\n        s: U(\"Seconds\", 1),\n        sss: U(\"Milliseconds\", 3),\n        EEEE: Jb(\"Day\"),\n        EEE: Jb(\"Day\", !0),\n        a: function(a, c) {\n          return 12 > a.getHours() ? c.AMPMS[0] : c.AMPMS[1];\n        },\n        Z: function(a) {\n          a = -1 * a.getTimezoneOffset();\n          return a = (0 <= a ? \"+\" : \"\") + (Ib(Math[0 < a ? \"floor\" : \"ceil\"](a / 60), 2) + Ib(Math.abs(a % 60), 2));\n        },\n        ww: qd(2),\n        w: qd(1),\n        G: ic,\n        GG: ic,\n        GGG: ic,\n        GGGG: function(a, c) {\n          return 0 >= a.getFullYear() ? c.ERANAMES[0] : c.ERANAMES[1];\n        }\n      },\n      Lf = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,\n      Kf = /^\\-?\\d+$/;\n  kd.$inject = [\"$locale\"];\n  var Hf = ea(z),\n      If = ea(ub);\n  md.$inject = [\"$parse\"];\n  var Td = ea({\n    restrict: \"E\",\n    compile: function(a, c) {\n      if (!c.href && !c.xlinkHref && !c.name)\n        return function(a, c) {\n          if (\"a\" === c[0].nodeName.toLowerCase()) {\n            var f = \"[object SVGAnimatedString]\" === Ca.call(c.prop(\"href\")) ? \"xlink:href\" : \"href\";\n            c.on(\"click\", function(a) {\n              c.attr(f) || a.preventDefault();\n            });\n          }\n        };\n    }\n  }),\n      vb = {};\n  r(Eb, function(a, c) {\n    if (\"multiple\" != a) {\n      var d = xa(\"ng-\" + c);\n      vb[d] = function() {\n        return {\n          restrict: \"A\",\n          priority: 100,\n          link: function(a, f, g) {\n            a.$watch(g[d], function(a) {\n              g.$set(c, !!a);\n            });\n          }\n        };\n      };\n    }\n  });\n  r(Pc, function(a, c) {\n    vb[c] = function() {\n      return {\n        priority: 100,\n        link: function(a, e, f) {\n          if (\"ngPattern\" === c && \"/\" == f.ngPattern.charAt(0) && (e = f.ngPattern.match(Of))) {\n            f.$set(\"ngPattern\", new RegExp(e[1], e[2]));\n            return;\n          }\n          a.$watch(f[c], function(a) {\n            f.$set(c, a);\n          });\n        }\n      };\n    };\n  });\n  r([\"src\", \"srcset\", \"href\"], function(a) {\n    var c = xa(\"ng-\" + a);\n    vb[c] = function() {\n      return {\n        priority: 99,\n        link: function(d, e, f) {\n          var g = a,\n              h = a;\n          \"href\" === a && \"[object SVGAnimatedString]\" === Ca.call(e.prop(\"href\")) && (h = \"xlinkHref\", f.$attr[h] = \"xlink:href\", g = null);\n          f.$observe(c, function(c) {\n            c ? (f.$set(h, c), Qa && g && e.prop(g, f[h])) : \"href\" === a && f.$set(h, null);\n          });\n        }\n      };\n    };\n  });\n  var Kb = {\n    $addControl: E,\n    $$renameControl: function(a, c) {\n      a.$name = c;\n    },\n    $removeControl: E,\n    $setValidity: E,\n    $setDirty: E,\n    $setPristine: E,\n    $setSubmitted: E\n  };\n  rd.$inject = [\"$element\", \"$attrs\", \"$scope\", \"$animate\", \"$interpolate\"];\n  var yd = function(a) {\n    return [\"$timeout\", function(c) {\n      return {\n        name: \"form\",\n        restrict: a ? \"EAC\" : \"E\",\n        controller: rd,\n        compile: function(d, e) {\n          d.addClass(Ra).addClass(lb);\n          var f = e.name ? \"name\" : a && e.ngForm ? \"ngForm\" : !1;\n          return {pre: function(a, d, e, k) {\n              if (!(\"action\" in e)) {\n                var n = function(c) {\n                  a.$apply(function() {\n                    k.$commitViewValue();\n                    k.$setSubmitted();\n                  });\n                  c.preventDefault();\n                };\n                d[0].addEventListener(\"submit\", n, !1);\n                d.on(\"$destroy\", function() {\n                  c(function() {\n                    d[0].removeEventListener(\"submit\", n, !1);\n                  }, 0, !1);\n                });\n              }\n              var p = k.$$parentForm;\n              f && (hb(a, null, k.$name, k, k.$name), e.$observe(f, function(c) {\n                k.$name !== c && (hb(a, null, k.$name, t, k.$name), p.$$renameControl(k, c), hb(a, null, k.$name, k, k.$name));\n              }));\n              d.on(\"$destroy\", function() {\n                p.$removeControl(k);\n                f && hb(a, null, e[f], t, k.$name);\n                w(k, Kb);\n              });\n            }};\n        }\n      };\n    }];\n  },\n      Ud = yd(),\n      ge = yd(!0),\n      Nf = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/,\n      $f = /^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n      ag = /^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,\n      bg = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$/,\n      zd = /^(\\d{4})-(\\d{2})-(\\d{2})$/,\n      Ad = /^(\\d{4})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,\n      lc = /^(\\d{4})-W(\\d\\d)$/,\n      Bd = /^(\\d{4})-(\\d\\d)$/,\n      Cd = /^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,\n      Dd = {\n        text: function(a, c, d, e, f, g) {\n          jb(a, c, d, e, f, g);\n          jc(e);\n        },\n        date: kb(\"date\", zd, Mb(zd, [\"yyyy\", \"MM\", \"dd\"]), \"yyyy-MM-dd\"),\n        \"datetime-local\": kb(\"datetimelocal\", Ad, Mb(Ad, \"yyyy MM dd HH mm ss sss\".split(\" \")), \"yyyy-MM-ddTHH:mm:ss.sss\"),\n        time: kb(\"time\", Cd, Mb(Cd, [\"HH\", \"mm\", \"ss\", \"sss\"]), \"HH:mm:ss.sss\"),\n        week: kb(\"week\", lc, function(a, c) {\n          if (ga(a))\n            return a;\n          if (C(a)) {\n            lc.lastIndex = 0;\n            var d = lc.exec(a);\n            if (d) {\n              var e = +d[1],\n                  f = +d[2],\n                  g = d = 0,\n                  h = 0,\n                  l = 0,\n                  k = pd(e),\n                  f = 7 * (f - 1);\n              c && (d = c.getHours(), g = c.getMinutes(), h = c.getSeconds(), l = c.getMilliseconds());\n              return new Date(e, 0, k.getDate() + f, d, g, h, l);\n            }\n          }\n          return NaN;\n        }, \"yyyy-Www\"),\n        month: kb(\"month\", Bd, Mb(Bd, [\"yyyy\", \"MM\"]), \"yyyy-MM\"),\n        number: function(a, c, d, e, f, g) {\n          td(a, c, d, e);\n          jb(a, c, d, e, f, g);\n          e.$$parserName = \"number\";\n          e.$parsers.push(function(a) {\n            return e.$isEmpty(a) ? null : bg.test(a) ? parseFloat(a) : t;\n          });\n          e.$formatters.push(function(a) {\n            if (!e.$isEmpty(a)) {\n              if (!Y(a))\n                throw Nb(\"numfmt\", a);\n              a = a.toString();\n            }\n            return a;\n          });\n          if (y(d.min) || d.ngMin) {\n            var h;\n            e.$validators.min = function(a) {\n              return e.$isEmpty(a) || x(h) || a >= h;\n            };\n            d.$observe(\"min\", function(a) {\n              y(a) && !Y(a) && (a = parseFloat(a, 10));\n              h = Y(a) && !isNaN(a) ? a : t;\n              e.$validate();\n            });\n          }\n          if (y(d.max) || d.ngMax) {\n            var l;\n            e.$validators.max = function(a) {\n              return e.$isEmpty(a) || x(l) || a <= l;\n            };\n            d.$observe(\"max\", function(a) {\n              y(a) && !Y(a) && (a = parseFloat(a, 10));\n              l = Y(a) && !isNaN(a) ? a : t;\n              e.$validate();\n            });\n          }\n        },\n        url: function(a, c, d, e, f, g) {\n          jb(a, c, d, e, f, g);\n          jc(e);\n          e.$$parserName = \"url\";\n          e.$validators.url = function(a, c) {\n            var d = a || c;\n            return e.$isEmpty(d) || $f.test(d);\n          };\n        },\n        email: function(a, c, d, e, f, g) {\n          jb(a, c, d, e, f, g);\n          jc(e);\n          e.$$parserName = \"email\";\n          e.$validators.email = function(a, c) {\n            var d = a || c;\n            return e.$isEmpty(d) || ag.test(d);\n          };\n        },\n        radio: function(a, c, d, e) {\n          x(d.name) && c.attr(\"name\", ++ob);\n          c.on(\"click\", function(a) {\n            c[0].checked && e.$setViewValue(d.value, a && a.type);\n          });\n          e.$render = function() {\n            c[0].checked = d.value == e.$viewValue;\n          };\n          d.$observe(\"value\", e.$render);\n        },\n        checkbox: function(a, c, d, e, f, g, h, l) {\n          var k = ud(l, a, \"ngTrueValue\", d.ngTrueValue, !0),\n              n = ud(l, a, \"ngFalseValue\", d.ngFalseValue, !1);\n          c.on(\"click\", function(a) {\n            e.$setViewValue(c[0].checked, a && a.type);\n          });\n          e.$render = function() {\n            c[0].checked = e.$viewValue;\n          };\n          e.$isEmpty = function(a) {\n            return !1 === a;\n          };\n          e.$formatters.push(function(a) {\n            return ha(a, k);\n          });\n          e.$parsers.push(function(a) {\n            return a ? k : n;\n          });\n        },\n        hidden: E,\n        button: E,\n        submit: E,\n        reset: E,\n        file: E\n      },\n      zc = [\"$browser\", \"$sniffer\", \"$filter\", \"$parse\", function(a, c, d, e) {\n        return {\n          restrict: \"E\",\n          require: [\"?ngModel\"],\n          link: {pre: function(f, g, h, l) {\n              l[0] && (Dd[z(h.type)] || Dd.text)(f, g, h, l[0], c, a, d, e);\n            }}\n        };\n      }],\n      cg = /^(true|false|\\d+)$/,\n      ye = function() {\n        return {\n          restrict: \"A\",\n          priority: 100,\n          compile: function(a, c) {\n            return cg.test(c.ngValue) ? function(a, c, f) {\n              f.$set(\"value\", a.$eval(f.ngValue));\n            } : function(a, c, f) {\n              a.$watch(f.ngValue, function(a) {\n                f.$set(\"value\", a);\n              });\n            };\n          }\n        };\n      },\n      Zd = [\"$compile\", function(a) {\n        return {\n          restrict: \"AC\",\n          compile: function(c) {\n            a.$$addBindingClass(c);\n            return function(c, e, f) {\n              a.$$addBindingInfo(e, f.ngBind);\n              e = e[0];\n              c.$watch(f.ngBind, function(a) {\n                e.textContent = a === t ? \"\" : a;\n              });\n            };\n          }\n        };\n      }],\n      ae = [\"$interpolate\", \"$compile\", function(a, c) {\n        return {compile: function(d) {\n            c.$$addBindingClass(d);\n            return function(d, f, g) {\n              d = a(f.attr(g.$attr.ngBindTemplate));\n              c.$$addBindingInfo(f, d.expressions);\n              f = f[0];\n              g.$observe(\"ngBindTemplate\", function(a) {\n                f.textContent = a === t ? \"\" : a;\n              });\n            };\n          }};\n      }],\n      $d = [\"$sce\", \"$parse\", \"$compile\", function(a, c, d) {\n        return {\n          restrict: \"A\",\n          compile: function(e, f) {\n            var g = c(f.ngBindHtml),\n                h = c(f.ngBindHtml, function(a) {\n                  return (a || \"\").toString();\n                });\n            d.$$addBindingClass(e);\n            return function(c, e, f) {\n              d.$$addBindingInfo(e, f.ngBindHtml);\n              c.$watch(h, function() {\n                e.html(a.getTrustedHtml(g(c)) || \"\");\n              });\n            };\n          }\n        };\n      }],\n      xe = ea({\n        restrict: \"A\",\n        require: \"ngModel\",\n        link: function(a, c, d, e) {\n          e.$viewChangeListeners.push(function() {\n            a.$eval(d.ngChange);\n          });\n        }\n      }),\n      be = kc(\"\", !0),\n      de = kc(\"Odd\", 0),\n      ce = kc(\"Even\", 1),\n      ee = Ia({compile: function(a, c) {\n          c.$set(\"ngCloak\", t);\n          a.removeClass(\"ng-cloak\");\n        }}),\n      fe = [function() {\n        return {\n          restrict: \"A\",\n          scope: !0,\n          controller: \"@\",\n          priority: 500\n        };\n      }],\n      Ec = {},\n      dg = {\n        blur: !0,\n        focus: !0\n      };\n  r(\"click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste\".split(\" \"), function(a) {\n    var c = xa(\"ng-\" + a);\n    Ec[c] = [\"$parse\", \"$rootScope\", function(d, e) {\n      return {\n        restrict: \"A\",\n        compile: function(f, g) {\n          var h = d(g[c], null, !0);\n          return function(c, d) {\n            d.on(a, function(d) {\n              var f = function() {\n                h(c, {$event: d});\n              };\n              dg[a] && e.$$phase ? c.$evalAsync(f) : c.$apply(f);\n            });\n          };\n        }\n      };\n    }];\n  });\n  var ie = [\"$animate\", function(a) {\n    return {\n      multiElement: !0,\n      transclude: \"element\",\n      priority: 600,\n      terminal: !0,\n      restrict: \"A\",\n      $$tlb: !0,\n      link: function(c, d, e, f, g) {\n        var h,\n            l,\n            k;\n        c.$watch(e.ngIf, function(c) {\n          c ? l || g(function(c, f) {\n            l = f;\n            c[c.length++] = W.createComment(\" end ngIf: \" + e.ngIf + \" \");\n            h = {clone: c};\n            a.enter(c, d.parent(), d);\n          }) : (k && (k.remove(), k = null), l && (l.$destroy(), l = null), h && (k = tb(h.clone), a.leave(k).then(function() {\n            k = null;\n          }), h = null));\n        });\n      }\n    };\n  }],\n      je = [\"$templateRequest\", \"$anchorScroll\", \"$animate\", \"$sce\", function(a, c, d, e) {\n        return {\n          restrict: \"ECA\",\n          priority: 400,\n          terminal: !0,\n          transclude: \"element\",\n          controller: ca.noop,\n          compile: function(f, g) {\n            var h = g.ngInclude || g.src,\n                l = g.onload || \"\",\n                k = g.autoscroll;\n            return function(f, g, q, r, s) {\n              var t = 0,\n                  v,\n                  m,\n                  F,\n                  w = function() {\n                    m && (m.remove(), m = null);\n                    v && (v.$destroy(), v = null);\n                    F && (d.leave(F).then(function() {\n                      m = null;\n                    }), m = F, F = null);\n                  };\n              f.$watch(e.parseAsResourceUrl(h), function(e) {\n                var h = function() {\n                  !y(k) || k && !f.$eval(k) || c();\n                },\n                    m = ++t;\n                e ? (a(e, !0).then(function(a) {\n                  if (m === t) {\n                    var c = f.$new();\n                    r.template = a;\n                    a = s(c, function(a) {\n                      w();\n                      d.enter(a, null, g).then(h);\n                    });\n                    v = c;\n                    F = a;\n                    v.$emit(\"$includeContentLoaded\", e);\n                    f.$eval(l);\n                  }\n                }, function() {\n                  m === t && (w(), f.$emit(\"$includeContentError\", e));\n                }), f.$emit(\"$includeContentRequested\", e)) : (w(), r.template = null);\n              });\n            };\n          }\n        };\n      }],\n      Ae = [\"$compile\", function(a) {\n        return {\n          restrict: \"ECA\",\n          priority: -400,\n          require: \"ngInclude\",\n          link: function(c, d, e, f) {\n            /SVG/.test(d[0].toString()) ? (d.empty(), a(Hc(f.template, W).childNodes)(c, function(a) {\n              d.append(a);\n            }, {futureParentElement: d})) : (d.html(f.template), a(d.contents())(c));\n          }\n        };\n      }],\n      ke = Ia({\n        priority: 450,\n        compile: function() {\n          return {pre: function(a, c, d) {\n              a.$eval(d.ngInit);\n            }};\n        }\n      }),\n      we = function() {\n        return {\n          restrict: \"A\",\n          priority: 100,\n          require: \"ngModel\",\n          link: function(a, c, d, e) {\n            var f = c.attr(d.$attr.ngList) || \", \",\n                g = \"false\" !== d.ngTrim,\n                h = g ? N(f) : f;\n            e.$parsers.push(function(a) {\n              if (!x(a)) {\n                var c = [];\n                a && r(a.split(h), function(a) {\n                  a && c.push(g ? N(a) : a);\n                });\n                return c;\n              }\n            });\n            e.$formatters.push(function(a) {\n              return H(a) ? a.join(f) : t;\n            });\n            e.$isEmpty = function(a) {\n              return !a || !a.length;\n            };\n          }\n        };\n      },\n      lb = \"ng-valid\",\n      vd = \"ng-invalid\",\n      Ra = \"ng-pristine\",\n      Lb = \"ng-dirty\",\n      xd = \"ng-pending\",\n      Nb = new R(\"ngModel\"),\n      eg = [\"$scope\", \"$exceptionHandler\", \"$attrs\", \"$element\", \"$parse\", \"$animate\", \"$timeout\", \"$rootScope\", \"$q\", \"$interpolate\", function(a, c, d, e, f, g, h, l, k, n) {\n        this.$modelValue = this.$viewValue = Number.NaN;\n        this.$$rawModelValue = t;\n        this.$validators = {};\n        this.$asyncValidators = {};\n        this.$parsers = [];\n        this.$formatters = [];\n        this.$viewChangeListeners = [];\n        this.$untouched = !0;\n        this.$touched = !1;\n        this.$pristine = !0;\n        this.$dirty = !1;\n        this.$valid = !0;\n        this.$invalid = !1;\n        this.$error = {};\n        this.$$success = {};\n        this.$pending = t;\n        this.$name = n(d.name || \"\", !1)(a);\n        var p = f(d.ngModel),\n            q = p.assign,\n            u = p,\n            s = q,\n            M = null,\n            v,\n            m = this;\n        this.$$setOptions = function(a) {\n          if ((m.$options = a) && a.getterSetter) {\n            var c = f(d.ngModel + \"()\"),\n                g = f(d.ngModel + \"($$$p)\");\n            u = function(a) {\n              var d = p(a);\n              G(d) && (d = c(a));\n              return d;\n            };\n            s = function(a, c) {\n              G(p(a)) ? g(a, {$$$p: m.$modelValue}) : q(a, m.$modelValue);\n            };\n          } else if (!p.assign)\n            throw Nb(\"nonassign\", d.ngModel, wa(e));\n        };\n        this.$render = E;\n        this.$isEmpty = function(a) {\n          return x(a) || \"\" === a || null === a || a !== a;\n        };\n        var F = e.inheritedData(\"$formController\") || Kb,\n            w = 0;\n        sd({\n          ctrl: this,\n          $element: e,\n          set: function(a, c) {\n            a[c] = !0;\n          },\n          unset: function(a, c) {\n            delete a[c];\n          },\n          parentForm: F,\n          $animate: g\n        });\n        this.$setPristine = function() {\n          m.$dirty = !1;\n          m.$pristine = !0;\n          g.removeClass(e, Lb);\n          g.addClass(e, Ra);\n        };\n        this.$setDirty = function() {\n          m.$dirty = !0;\n          m.$pristine = !1;\n          g.removeClass(e, Ra);\n          g.addClass(e, Lb);\n          F.$setDirty();\n        };\n        this.$setUntouched = function() {\n          m.$touched = !1;\n          m.$untouched = !0;\n          g.setClass(e, \"ng-untouched\", \"ng-touched\");\n        };\n        this.$setTouched = function() {\n          m.$touched = !0;\n          m.$untouched = !1;\n          g.setClass(e, \"ng-touched\", \"ng-untouched\");\n        };\n        this.$rollbackViewValue = function() {\n          h.cancel(M);\n          m.$viewValue = m.$$lastCommittedViewValue;\n          m.$render();\n        };\n        this.$validate = function() {\n          if (!Y(m.$modelValue) || !isNaN(m.$modelValue)) {\n            var a = m.$$rawModelValue,\n                c = m.$valid,\n                d = m.$modelValue,\n                e = m.$options && m.$options.allowInvalid;\n            m.$$runValidators(a, m.$$lastCommittedViewValue, function(f) {\n              e || c === f || (m.$modelValue = f ? a : t, m.$modelValue !== d && m.$$writeModelToScope());\n            });\n          }\n        };\n        this.$$runValidators = function(a, c, d) {\n          function e() {\n            var d = !0;\n            r(m.$validators, function(e, f) {\n              var h = e(a, c);\n              d = d && h;\n              g(f, h);\n            });\n            return d ? !0 : (r(m.$asyncValidators, function(a, c) {\n              g(c, null);\n            }), !1);\n          }\n          function f() {\n            var d = [],\n                e = !0;\n            r(m.$asyncValidators, function(f, h) {\n              var k = f(a, c);\n              if (!k || !G(k.then))\n                throw Nb(\"$asyncValidators\", k);\n              g(h, t);\n              d.push(k.then(function() {\n                g(h, !0);\n              }, function(a) {\n                e = !1;\n                g(h, !1);\n              }));\n            });\n            d.length ? k.all(d).then(function() {\n              h(e);\n            }, E) : h(!0);\n          }\n          function g(a, c) {\n            l === w && m.$setValidity(a, c);\n          }\n          function h(a) {\n            l === w && d(a);\n          }\n          w++;\n          var l = w;\n          (function() {\n            var a = m.$$parserName || \"parse\";\n            if (v === t)\n              g(a, null);\n            else\n              return v || (r(m.$validators, function(a, c) {\n                g(c, null);\n              }), r(m.$asyncValidators, function(a, c) {\n                g(c, null);\n              })), g(a, v), v;\n            return !0;\n          })() ? e() ? f() : h(!1) : h(!1);\n        };\n        this.$commitViewValue = function() {\n          var a = m.$viewValue;\n          h.cancel(M);\n          if (m.$$lastCommittedViewValue !== a || \"\" === a && m.$$hasNativeValidators)\n            m.$$lastCommittedViewValue = a, m.$pristine && this.$setDirty(), this.$$parseAndValidate();\n        };\n        this.$$parseAndValidate = function() {\n          var c = m.$$lastCommittedViewValue;\n          if (v = x(c) ? t : !0)\n            for (var d = 0; d < m.$parsers.length; d++)\n              if (c = m.$parsers[d](c), x(c)) {\n                v = !1;\n                break;\n              }\n          Y(m.$modelValue) && isNaN(m.$modelValue) && (m.$modelValue = u(a));\n          var e = m.$modelValue,\n              f = m.$options && m.$options.allowInvalid;\n          m.$$rawModelValue = c;\n          f && (m.$modelValue = c, m.$modelValue !== e && m.$$writeModelToScope());\n          m.$$runValidators(c, m.$$lastCommittedViewValue, function(a) {\n            f || (m.$modelValue = a ? c : t, m.$modelValue !== e && m.$$writeModelToScope());\n          });\n        };\n        this.$$writeModelToScope = function() {\n          s(a, m.$modelValue);\n          r(m.$viewChangeListeners, function(a) {\n            try {\n              a();\n            } catch (d) {\n              c(d);\n            }\n          });\n        };\n        this.$setViewValue = function(a, c) {\n          m.$viewValue = a;\n          m.$options && !m.$options.updateOnDefault || m.$$debounceViewValueCommit(c);\n        };\n        this.$$debounceViewValueCommit = function(c) {\n          var d = 0,\n              e = m.$options;\n          e && y(e.debounce) && (e = e.debounce, Y(e) ? d = e : Y(e[c]) ? d = e[c] : Y(e[\"default\"]) && (d = e[\"default\"]));\n          h.cancel(M);\n          d ? M = h(function() {\n            m.$commitViewValue();\n          }, d) : l.$$phase ? m.$commitViewValue() : a.$apply(function() {\n            m.$commitViewValue();\n          });\n        };\n        a.$watch(function() {\n          var c = u(a);\n          if (c !== m.$modelValue) {\n            m.$modelValue = m.$$rawModelValue = c;\n            v = t;\n            for (var d = m.$formatters,\n                e = d.length,\n                f = c; e--; )\n              f = d[e](f);\n            m.$viewValue !== f && (m.$viewValue = m.$$lastCommittedViewValue = f, m.$render(), m.$$runValidators(c, f, E));\n          }\n          return c;\n        });\n      }],\n      ve = [\"$rootScope\", function(a) {\n        return {\n          restrict: \"A\",\n          require: [\"ngModel\", \"^?form\", \"^?ngModelOptions\"],\n          controller: eg,\n          priority: 1,\n          compile: function(c) {\n            c.addClass(Ra).addClass(\"ng-untouched\").addClass(lb);\n            return {\n              pre: function(a, c, f, g) {\n                var h = g[0],\n                    l = g[1] || Kb;\n                h.$$setOptions(g[2] && g[2].$options);\n                l.$addControl(h);\n                f.$observe(\"name\", function(a) {\n                  h.$name !== a && l.$$renameControl(h, a);\n                });\n                a.$on(\"$destroy\", function() {\n                  l.$removeControl(h);\n                });\n              },\n              post: function(c, e, f, g) {\n                var h = g[0];\n                if (h.$options && h.$options.updateOn)\n                  e.on(h.$options.updateOn, function(a) {\n                    h.$$debounceViewValueCommit(a && a.type);\n                  });\n                e.on(\"blur\", function(e) {\n                  h.$touched || (a.$$phase ? c.$evalAsync(h.$setTouched) : c.$apply(h.$setTouched));\n                });\n              }\n            };\n          }\n        };\n      }],\n      fg = /(\\s+|^)default(\\s+|$)/,\n      ze = function() {\n        return {\n          restrict: \"A\",\n          controller: [\"$scope\", \"$attrs\", function(a, c) {\n            var d = this;\n            this.$options = a.$eval(c.ngModelOptions);\n            this.$options.updateOn !== t ? (this.$options.updateOnDefault = !1, this.$options.updateOn = N(this.$options.updateOn.replace(fg, function() {\n              d.$options.updateOnDefault = !0;\n              return \" \";\n            }))) : this.$options.updateOnDefault = !0;\n          }]\n        };\n      },\n      le = Ia({\n        terminal: !0,\n        priority: 1E3\n      }),\n      me = [\"$locale\", \"$interpolate\", function(a, c) {\n        var d = /{}/g,\n            e = /^when(Minus)?(.+)$/;\n        return {\n          restrict: \"EA\",\n          link: function(f, g, h) {\n            function l(a) {\n              g.text(a || \"\");\n            }\n            var k = h.count,\n                n = h.$attr.when && g.attr(h.$attr.when),\n                p = h.offset || 0,\n                q = f.$eval(n) || {},\n                u = {},\n                n = c.startSymbol(),\n                s = c.endSymbol(),\n                t = n + k + \"-\" + p + s,\n                v = ca.noop,\n                m;\n            r(h, function(a, c) {\n              var d = e.exec(c);\n              d && (d = (d[1] ? \"-\" : \"\") + z(d[2]), q[d] = g.attr(h.$attr[c]));\n            });\n            r(q, function(a, e) {\n              u[e] = c(a.replace(d, t));\n            });\n            f.$watch(k, function(c) {\n              c = parseFloat(c);\n              var d = isNaN(c);\n              d || c in q || (c = a.pluralCat(c - p));\n              c === m || d && isNaN(m) || (v(), v = f.$watch(u[c], l), m = c);\n            });\n          }\n        };\n      }],\n      ne = [\"$parse\", \"$animate\", function(a, c) {\n        var d = R(\"ngRepeat\"),\n            e = function(a, c, d, e, k, n, p) {\n              a[d] = e;\n              k && (a[k] = n);\n              a.$index = c;\n              a.$first = 0 === c;\n              a.$last = c === p - 1;\n              a.$middle = !(a.$first || a.$last);\n              a.$odd = !(a.$even = 0 === (c & 1));\n            };\n        return {\n          restrict: \"A\",\n          multiElement: !0,\n          transclude: \"element\",\n          priority: 1E3,\n          terminal: !0,\n          $$tlb: !0,\n          compile: function(f, g) {\n            var h = g.ngRepeat,\n                l = W.createComment(\" end ngRepeat: \" + h + \" \"),\n                k = h.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n            if (!k)\n              throw d(\"iexp\", h);\n            var n = k[1],\n                p = k[2],\n                q = k[3],\n                u = k[4],\n                k = n.match(/^(?:(\\s*[\\$\\w]+)|\\(\\s*([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\s*\\))$/);\n            if (!k)\n              throw d(\"iidexp\", n);\n            var s = k[3] || k[1],\n                y = k[2];\n            if (q && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(q) || /^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(q)))\n              throw d(\"badident\", q);\n            var v,\n                m,\n                w,\n                x,\n                E = {$id: Ma};\n            u ? v = a(u) : (w = function(a, c) {\n              return Ma(c);\n            }, x = function(a) {\n              return a;\n            });\n            return function(a, f, g, k, n) {\n              v && (m = function(c, d, e) {\n                y && (E[y] = c);\n                E[s] = d;\n                E.$index = e;\n                return v(a, E);\n              });\n              var u = ia();\n              a.$watchCollection(p, function(g) {\n                var k,\n                    p,\n                    v = f[0],\n                    D,\n                    E = ia(),\n                    G,\n                    H,\n                    L,\n                    S,\n                    J,\n                    C,\n                    z;\n                q && (a[q] = g);\n                if (Sa(g))\n                  J = g, p = m || w;\n                else {\n                  p = m || x;\n                  J = [];\n                  for (z in g)\n                    g.hasOwnProperty(z) && \"$\" != z.charAt(0) && J.push(z);\n                  J.sort();\n                }\n                G = J.length;\n                z = Array(G);\n                for (k = 0; k < G; k++)\n                  if (H = g === J ? k : J[k], L = g[H], S = p(H, L, k), u[S])\n                    C = u[S], delete u[S], E[S] = C, z[k] = C;\n                  else {\n                    if (E[S])\n                      throw r(z, function(a) {\n                        a && a.scope && (u[a.id] = a);\n                      }), d(\"dupes\", h, S, L);\n                    z[k] = {\n                      id: S,\n                      scope: t,\n                      clone: t\n                    };\n                    E[S] = !0;\n                  }\n                for (D in u) {\n                  C = u[D];\n                  S = tb(C.clone);\n                  c.leave(S);\n                  if (S[0].parentNode)\n                    for (k = 0, p = S.length; k < p; k++)\n                      S[k].$$NG_REMOVED = !0;\n                  C.scope.$destroy();\n                }\n                for (k = 0; k < G; k++)\n                  if (H = g === J ? k : J[k], L = g[H], C = z[k], C.scope) {\n                    D = v;\n                    do\n                      D = D.nextSibling;\n while (D && D.$$NG_REMOVED);\n                    C.clone[0] != D && c.move(tb(C.clone), null, A(v));\n                    v = C.clone[C.clone.length - 1];\n                    e(C.scope, k, s, L, y, H, G);\n                  } else\n                    n(function(a, d) {\n                      C.scope = d;\n                      var f = l.cloneNode(!1);\n                      a[a.length++] = f;\n                      c.enter(a, null, A(v));\n                      v = f;\n                      C.clone = a;\n                      E[C.id] = C;\n                      e(C.scope, k, s, L, y, H, G);\n                    });\n                u = E;\n              });\n            };\n          }\n        };\n      }],\n      oe = [\"$animate\", function(a) {\n        return {\n          restrict: \"A\",\n          multiElement: !0,\n          link: function(c, d, e) {\n            c.$watch(e.ngShow, function(c) {\n              a[c ? \"removeClass\" : \"addClass\"](d, \"ng-hide\", {tempClasses: \"ng-hide-animate\"});\n            });\n          }\n        };\n      }],\n      he = [\"$animate\", function(a) {\n        return {\n          restrict: \"A\",\n          multiElement: !0,\n          link: function(c, d, e) {\n            c.$watch(e.ngHide, function(c) {\n              a[c ? \"addClass\" : \"removeClass\"](d, \"ng-hide\", {tempClasses: \"ng-hide-animate\"});\n            });\n          }\n        };\n      }],\n      pe = Ia(function(a, c, d) {\n        a.$watchCollection(d.ngStyle, function(a, d) {\n          d && a !== d && r(d, function(a, d) {\n            c.css(d, \"\");\n          });\n          a && c.css(a);\n        });\n      }),\n      qe = [\"$animate\", function(a) {\n        return {\n          restrict: \"EA\",\n          require: \"ngSwitch\",\n          controller: [\"$scope\", function() {\n            this.cases = {};\n          }],\n          link: function(c, d, e, f) {\n            var g = [],\n                h = [],\n                l = [],\n                k = [],\n                n = function(a, c) {\n                  return function() {\n                    a.splice(c, 1);\n                  };\n                };\n            c.$watch(e.ngSwitch || e.on, function(c) {\n              var d,\n                  e;\n              d = 0;\n              for (e = l.length; d < e; ++d)\n                a.cancel(l[d]);\n              d = l.length = 0;\n              for (e = k.length; d < e; ++d) {\n                var s = tb(h[d].clone);\n                k[d].$destroy();\n                (l[d] = a.leave(s)).then(n(l, d));\n              }\n              h.length = 0;\n              k.length = 0;\n              (g = f.cases[\"!\" + c] || f.cases[\"?\"]) && r(g, function(c) {\n                c.transclude(function(d, e) {\n                  k.push(e);\n                  var f = c.element;\n                  d[d.length++] = W.createComment(\" end ngSwitchWhen: \");\n                  h.push({clone: d});\n                  a.enter(d, f.parent(), f);\n                });\n              });\n            });\n          }\n        };\n      }],\n      re = Ia({\n        transclude: \"element\",\n        priority: 1200,\n        require: \"^ngSwitch\",\n        multiElement: !0,\n        link: function(a, c, d, e, f) {\n          e.cases[\"!\" + d.ngSwitchWhen] = e.cases[\"!\" + d.ngSwitchWhen] || [];\n          e.cases[\"!\" + d.ngSwitchWhen].push({\n            transclude: f,\n            element: c\n          });\n        }\n      }),\n      se = Ia({\n        transclude: \"element\",\n        priority: 1200,\n        require: \"^ngSwitch\",\n        multiElement: !0,\n        link: function(a, c, d, e, f) {\n          e.cases[\"?\"] = e.cases[\"?\"] || [];\n          e.cases[\"?\"].push({\n            transclude: f,\n            element: c\n          });\n        }\n      }),\n      ue = Ia({\n        restrict: \"EAC\",\n        link: function(a, c, d, e, f) {\n          if (!f)\n            throw R(\"ngTransclude\")(\"orphan\", wa(c));\n          f(function(a) {\n            c.empty();\n            c.append(a);\n          });\n        }\n      }),\n      Vd = [\"$templateCache\", function(a) {\n        return {\n          restrict: \"E\",\n          terminal: !0,\n          compile: function(c, d) {\n            \"text/ng-template\" == d.type && a.put(d.id, c[0].text);\n          }\n        };\n      }],\n      gg = R(\"ngOptions\"),\n      te = ea({\n        restrict: \"A\",\n        terminal: !0\n      }),\n      Wd = [\"$compile\", \"$parse\", function(a, c) {\n        var d = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/,\n            e = {$setViewValue: E};\n        return {\n          restrict: \"E\",\n          require: [\"select\", \"?ngModel\"],\n          controller: [\"$element\", \"$scope\", \"$attrs\", function(a, c, d) {\n            var l = this,\n                k = {},\n                n = e,\n                p;\n            l.databound = d.ngModel;\n            l.init = function(a, c, d) {\n              n = a;\n              p = d;\n            };\n            l.addOption = function(c, d) {\n              La(c, '\"option value\"');\n              k[c] = !0;\n              n.$viewValue == c && (a.val(c), p.parent() && p.remove());\n              d && d[0].hasAttribute(\"selected\") && (d[0].selected = !0);\n            };\n            l.removeOption = function(a) {\n              this.hasOption(a) && (delete k[a], n.$viewValue === a && this.renderUnknownOption(a));\n            };\n            l.renderUnknownOption = function(c) {\n              c = \"? \" + Ma(c) + \" ?\";\n              p.val(c);\n              a.prepend(p);\n              a.val(c);\n              p.prop(\"selected\", !0);\n            };\n            l.hasOption = function(a) {\n              return k.hasOwnProperty(a);\n            };\n            c.$on(\"$destroy\", function() {\n              l.renderUnknownOption = E;\n            });\n          }],\n          link: function(e, g, h, l) {\n            function k(a, c, d, e) {\n              d.$render = function() {\n                var a = d.$viewValue;\n                e.hasOption(a) ? (C.parent() && C.remove(), c.val(a), \"\" === a && v.prop(\"selected\", !0)) : x(a) && v ? c.val(\"\") : e.renderUnknownOption(a);\n              };\n              c.on(\"change\", function() {\n                a.$apply(function() {\n                  C.parent() && C.remove();\n                  d.$setViewValue(c.val());\n                });\n              });\n            }\n            function n(a, c, d) {\n              var e;\n              d.$render = function() {\n                var a = new eb(d.$viewValue);\n                r(c.find(\"option\"), function(c) {\n                  c.selected = y(a.get(c.value));\n                });\n              };\n              a.$watch(function() {\n                ha(e, d.$viewValue) || (e = sa(d.$viewValue), d.$render());\n              });\n              c.on(\"change\", function() {\n                a.$apply(function() {\n                  var a = [];\n                  r(c.find(\"option\"), function(c) {\n                    c.selected && a.push(c.value);\n                  });\n                  d.$setViewValue(a);\n                });\n              });\n            }\n            function p(e, f, g) {\n              function h(a, c, d) {\n                T[x] = d;\n                G && (T[G] = c);\n                return a(e, T);\n              }\n              function k(a) {\n                var c;\n                if (u)\n                  if (I && H(a)) {\n                    c = new eb([]);\n                    for (var d = 0; d < a.length; d++)\n                      c.put(h(I, null, a[d]), !0);\n                  } else\n                    c = new eb(a);\n                else\n                  I && (a = h(I, null, a));\n                return function(d, e) {\n                  var f;\n                  f = I ? I : B ? B : z;\n                  return u ? y(c.remove(h(f, d, e))) : a === h(f, d, e);\n                };\n              }\n              function l() {\n                m || (e.$$postDigest(p), m = !0);\n              }\n              function n(a, c, d) {\n                a[c] = a[c] || 0;\n                a[c] += d ? 1 : -1;\n              }\n              function p() {\n                m = !1;\n                var a = {\"\": []},\n                    c = [\"\"],\n                    d,\n                    l,\n                    s,\n                    t,\n                    v;\n                s = g.$viewValue;\n                t = L(e) || [];\n                var B = G ? Object.keys(t).sort() : t,\n                    x,\n                    A,\n                    H,\n                    z,\n                    O = {};\n                v = k(s);\n                var N = !1,\n                    U,\n                    W;\n                Q = {};\n                for (z = 0; H = B.length, z < H; z++) {\n                  x = z;\n                  if (G && (x = B[z], \"$\" === x.charAt(0)))\n                    continue;\n                  A = t[x];\n                  d = h(J, x, A) || \"\";\n                  (l = a[d]) || (l = a[d] = [], c.push(d));\n                  d = v(x, A);\n                  N = N || d;\n                  A = h(C, x, A);\n                  A = y(A) ? A : \"\";\n                  W = I ? I(e, T) : G ? B[z] : z;\n                  I && (Q[W] = x);\n                  l.push({\n                    id: W,\n                    label: A,\n                    selected: d\n                  });\n                }\n                u || (w || null === s ? a[\"\"].unshift({\n                  id: \"\",\n                  label: \"\",\n                  selected: !N\n                }) : N || a[\"\"].unshift({\n                  id: \"?\",\n                  label: \"\",\n                  selected: !0\n                }));\n                x = 0;\n                for (B = c.length; x < B; x++) {\n                  d = c[x];\n                  l = a[d];\n                  R.length <= x ? (s = {\n                    element: E.clone().attr(\"label\", d),\n                    label: l.label\n                  }, t = [s], R.push(t), f.append(s.element)) : (t = R[x], s = t[0], s.label != d && s.element.attr(\"label\", s.label = d));\n                  N = null;\n                  z = 0;\n                  for (H = l.length; z < H; z++)\n                    d = l[z], (v = t[z + 1]) ? (N = v.element, v.label !== d.label && (n(O, v.label, !1), n(O, d.label, !0), N.text(v.label = d.label), N.prop(\"label\", v.label)), v.id !== d.id && N.val(v.id = d.id), N[0].selected !== d.selected && (N.prop(\"selected\", v.selected = d.selected), Qa && N.prop(\"selected\", v.selected))) : (\"\" === d.id && w ? U = w : (U = F.clone()).val(d.id).prop(\"selected\", d.selected).attr(\"selected\", d.selected).prop(\"label\", d.label).text(d.label), t.push(v = {\n                      element: U,\n                      label: d.label,\n                      id: d.id,\n                      selected: d.selected\n                    }), n(O, d.label, !0), N ? N.after(U) : s.element.append(U), N = U);\n                  for (z++; t.length > z; )\n                    d = t.pop(), n(O, d.label, !1), d.element.remove();\n                }\n                for (; R.length > x; ) {\n                  l = R.pop();\n                  for (z = 1; z < l.length; ++z)\n                    n(O, l[z].label, !1);\n                  l[0].element.remove();\n                }\n                r(O, function(a, c) {\n                  0 < a ? q.addOption(c) : 0 > a && q.removeOption(c);\n                });\n              }\n              var v;\n              if (!(v = s.match(d)))\n                throw gg(\"iexp\", s, wa(f));\n              var C = c(v[2] || v[1]),\n                  x = v[4] || v[6],\n                  A = / as /.test(v[0]) && v[1],\n                  B = A ? c(A) : null,\n                  G = v[5],\n                  J = c(v[3] || \"\"),\n                  z = c(v[2] ? v[1] : x),\n                  L = c(v[7]),\n                  I = v[8] ? c(v[8]) : null,\n                  Q = {},\n                  R = [[{\n                    element: f,\n                    label: \"\"\n                  }]],\n                  T = {};\n              w && (a(w)(e), w.removeClass(\"ng-scope\"), w.remove());\n              f.empty();\n              f.on(\"change\", function() {\n                e.$apply(function() {\n                  var a = L(e) || [],\n                      c;\n                  if (u)\n                    c = [], r(f.val(), function(d) {\n                      d = I ? Q[d] : d;\n                      c.push(\"?\" === d ? t : \"\" === d ? null : h(B ? B : z, d, a[d]));\n                    });\n                  else {\n                    var d = I ? Q[f.val()] : f.val();\n                    c = \"?\" === d ? t : \"\" === d ? null : h(B ? B : z, d, a[d]);\n                  }\n                  g.$setViewValue(c);\n                  p();\n                });\n              });\n              g.$render = p;\n              e.$watchCollection(L, l);\n              e.$watchCollection(function() {\n                var a = L(e),\n                    c;\n                if (a && H(a)) {\n                  c = Array(a.length);\n                  for (var d = 0,\n                      f = a.length; d < f; d++)\n                    c[d] = h(C, d, a[d]);\n                } else if (a)\n                  for (d in c = {}, a)\n                    a.hasOwnProperty(d) && (c[d] = h(C, d, a[d]));\n                return c;\n              }, l);\n              u && e.$watchCollection(function() {\n                return g.$modelValue;\n              }, l);\n            }\n            if (l[1]) {\n              var q = l[0];\n              l = l[1];\n              var u = h.multiple,\n                  s = h.ngOptions,\n                  w = !1,\n                  v,\n                  m = !1,\n                  F = A(W.createElement(\"option\")),\n                  E = A(W.createElement(\"optgroup\")),\n                  C = F.clone();\n              h = 0;\n              for (var B = g.children(),\n                  G = B.length; h < G; h++)\n                if (\"\" === B[h].value) {\n                  v = w = B.eq(h);\n                  break;\n                }\n              q.init(l, w, C);\n              u && (l.$isEmpty = function(a) {\n                return !a || 0 === a.length;\n              });\n              s ? p(e, g, l) : u ? n(e, g, l) : k(e, g, l, q);\n            }\n          }\n        };\n      }],\n      Yd = [\"$interpolate\", function(a) {\n        var c = {\n          addOption: E,\n          removeOption: E\n        };\n        return {\n          restrict: \"E\",\n          priority: 100,\n          compile: function(d, e) {\n            if (x(e.value)) {\n              var f = a(d.text(), !0);\n              f || e.$set(\"value\", d.text());\n            }\n            return function(a, d, e) {\n              var k = d.parent(),\n                  n = k.data(\"$selectController\") || k.parent().data(\"$selectController\");\n              n && n.databound || (n = c);\n              f ? a.$watch(f, function(a, c) {\n                e.$set(\"value\", a);\n                c !== a && n.removeOption(c);\n                n.addOption(a, d);\n              }) : n.addOption(e.value, d);\n              d.on(\"$destroy\", function() {\n                n.removeOption(e.value);\n              });\n            };\n          }\n        };\n      }],\n      Xd = ea({\n        restrict: \"E\",\n        terminal: !1\n      }),\n      Bc = function() {\n        return {\n          restrict: \"A\",\n          require: \"?ngModel\",\n          link: function(a, c, d, e) {\n            e && (d.required = !0, e.$validators.required = function(a, c) {\n              return !d.required || !e.$isEmpty(c);\n            }, d.$observe(\"required\", function() {\n              e.$validate();\n            }));\n          }\n        };\n      },\n      Ac = function() {\n        return {\n          restrict: \"A\",\n          require: \"?ngModel\",\n          link: function(a, c, d, e) {\n            if (e) {\n              var f,\n                  g = d.ngPattern || d.pattern;\n              d.$observe(\"pattern\", function(a) {\n                C(a) && 0 < a.length && (a = new RegExp(\"^\" + a + \"$\"));\n                if (a && !a.test)\n                  throw R(\"ngPattern\")(\"noregexp\", g, a, wa(c));\n                f = a || t;\n                e.$validate();\n              });\n              e.$validators.pattern = function(a) {\n                return e.$isEmpty(a) || x(f) || f.test(a);\n              };\n            }\n          }\n        };\n      },\n      Dc = function() {\n        return {\n          restrict: \"A\",\n          require: \"?ngModel\",\n          link: function(a, c, d, e) {\n            if (e) {\n              var f = -1;\n              d.$observe(\"maxlength\", function(a) {\n                a = aa(a);\n                f = isNaN(a) ? -1 : a;\n                e.$validate();\n              });\n              e.$validators.maxlength = function(a, c) {\n                return 0 > f || e.$isEmpty(c) || c.length <= f;\n              };\n            }\n          }\n        };\n      },\n      Cc = function() {\n        return {\n          restrict: \"A\",\n          require: \"?ngModel\",\n          link: function(a, c, d, e) {\n            if (e) {\n              var f = 0;\n              d.$observe(\"minlength\", function(a) {\n                f = aa(a) || 0;\n                e.$validate();\n              });\n              e.$validators.minlength = function(a, c) {\n                return e.$isEmpty(c) || c.length >= f;\n              };\n            }\n          }\n        };\n      };\n  Q.angular.bootstrap ? console.log(\"WARNING: Tried to load angular more than once.\") : (Nd(), Pd(ca), A(W).ready(function() {\n    Jd(W, uc);\n  }));\n})(window, document);\n!window.angular.$$csp() && window.angular.element(document).find(\"head\").prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\\\:form{display:block;}</style>');\n\n\n//# sourceURL=F:/nodeTemplate/node_modules/angular/angular.min.js\n},{}],3:[function(require,module,exports){\n\"use strict\";\nrequire('./angular.min.js');\nmodule.exports = angular;\n\n\n//# sourceURL=F:/nodeTemplate/node_modules/angular/index.js\n},{\"./angular.min.js\":2}],4:[function(require,module,exports){\nvar errno = require('errno');\n\nObject.keys(errno.code).forEach(function(code) {\n\tvar e = errno.code[code];\n\n\texports[code] = function(path) {\n\t\tvar err = new Error(code+', '+e.description+(path ? ' \\''+path+'\\'' : ''));\n\t\terr.errno = e.errno;\n\t\terr.code = code;\n\t\terr.path = path;\n\t\treturn err;\n\t};\n});\n},{\"errno\":19}],5:[function(require,module,exports){\n(function (process,Buffer){\nvar fwd = require('fwd-stream');\nvar sublevel = require('level-sublevel');\nvar blobs = require('level-blobs');\nvar peek = require('level-peek');\nvar once = require('once');\nvar errno = require('./errno');\nvar paths = require('./paths');\nvar watchers = require('./watchers');\n\nvar nextTick = function(cb, err, val) {\n\tprocess.nextTick(function() {\n\t\tcb(err, val);\n\t});\n};\n\nvar noop = function() {};\n\nmodule.exports = function(db, opts) {\n\tvar fs = {};\n\n\tdb = sublevel(db);\n\n\tvar bl = blobs(db.sublevel('blobs'), opts);\n\tvar ps = paths(db.sublevel('stats'));\n\tvar links = db.sublevel('links');\n\n\tvar listeners = watchers();\n\tvar fds = [];\n\n\tvar now = Date.now();\n\tvar inc = function() {\n\t\treturn ++now;\n\t};\n\n\tfs.mkdir = function(key, mode, cb) {\n\t\tif (typeof mode === 'function') return fs.mkdir(key, null, mode);\n\t\tif (!mode) mode = 0777;\n\t\tif (!cb) cb = noop;\n\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\t\t\tif (stat) return cb(errno.EEXIST(key));\n\n\t\t\tps.put(key, {\n\t\t\t\ttype:'directory',\n\t\t\t\tmode: mode,\n\t\t\t\tsize: 4096\n\t\t\t}, listeners.cb(key, cb));\n\t\t});\n\t};\n\n\tfs.rmdir = function(key, cb) {\n\t\tif (!cb) cb = noop;\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tfs.readdir(key, function(err, files) {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\tif (files.length) return cb(errno.ENOTEMPTY(key));\n\t\t\t\tps.del(key, listeners.cb(key, cb));\n\t\t\t});\n\t\t});\n\n\t};\n\n\tfs.readdir = function(key, cb) {\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (!stat) return cb(errno.ENOENT(key));\n\t\t\tif (!stat.isDirectory()) return cb(errno.ENOTDIR(key));\n\t\t\tps.list(key, cb);\n\t\t});\n\t};\n\n\tvar stat = function(key, lookup, cb) {\n\t\tlookup(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (!stat.isFile()) return cb(null, stat);\n\t\t\tvar blob = stat && stat.blob || key;\n\t\t\tbl.size(blob, function(err, size) {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\tstat.size = size;\n\t\t\t\tcb(null, stat);\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.stat = function(key, cb) {\n\t\tstat(key, ps.follow, cb);\n\t};\n\n\tfs.lstat = function(key, cb) {\n\t\tstat(key, ps.get, cb);\n\t};\n\n\tfs.exists = function(key, cb) {\n\t\tps.follow(key, function(err) {\n\t\t\tcb(!err);\n\t\t});\n\t};\n\n\tvar chmod = function(key, lookup, mode, cb) {\n\t\tif (!cb) cb = noop;\n\t\tlookup(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tps.update(key, {mode:mode}, listeners.cb(key, cb));\n\t\t});\n\t};\n\n\tfs.chmod = function(key, mode, cb) {\n\t\tchmod(key, ps.follow, mode, cb);\n\t};\n\n\tfs.lchmod = function(key, mode, cb) {\n\t\tchmod(key, ps.get, mode, cb);\n\t};\n\n\tvar chown = function(key, lookup, uid, gid, cb) {\n\t\tif (!cb) cb = noop;\n\t\tlookup(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tps.update(key, {uid:uid, gid:gid}, listeners.cb(key, cb));\n\t\t});\n\t};\n\n\tfs.chown = function(key, uid, gid, cb) {\n\t\tchown(key, ps.follow, uid, gid, cb);\n\t};\n\n\tfs.lchown = function(key, uid, gid, cb) {\n\t\tchown(key, ps.get, uid, gid, cb);\n\t};\n\n\tfs.utimes = function(key, atime, mtime, cb) {\n\t\tif (!cb) cb = noop;\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tvar upd = {};\n\t\t\tif (atime) upd.atime = atime;\n\t\t\tif (mtime) upd.mtime = mtime;\n\t\t\tps.update(key, upd, listeners.cb(key, cb));\n\t\t});\n\t};\n\n\tfs.rename = function(from, to, cb) {\n\t\tif (!cb) cb = noop;\n\n\t\tps.follow(from, function(err, statFrom, from) {\n\t\t\tif (err) return cb(err);\n\n\t\t\tvar rename = function() {\n\t\t\t\tcb = listeners.cb(to, listeners.cb(from, cb));\n\t\t\t\tps.put(to, statFrom, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\tps.del(from, cb);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tps.follow(to, function(err, statTo, to) {\n\t\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\t\t\t\tif (!statTo) return rename();\n\t\t\t\tif (statFrom.isDirectory() !== statTo.isDirectory()) return cb(errno.EISDIR(from));\n\n\t\t\t\tif (statTo.isDirectory()) {\n\t\t\t\t\tfs.readdir(to, function(err, list) {\n\t\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\t\tif (list.length) return cb(errno.ENOTEMPTY(from));\n\t\t\t\t\t\trename();\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trename();\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.realpath = function(key, cache, cb) {\n\t\tif (typeof cache === 'function') return fs.realpath(key, null, cache);\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tcb(null, key);\n\t\t});\n\t};\n\n\tfs.writeFile = function(key, data, opts, cb) {\n\t\tif (typeof opts === 'function') return fs.writeFile(key, data, null, opts);\n\t\tif (typeof opts === 'string') opts = {encoding:opts};\n\t\tif (!opts) opts = {};\n\t\tif (!cb) cb = noop;\n\n\t\tif (!Buffer.isBuffer(data)) data = new Buffer(data, opts.encoding || 'utf-8');\n\n\t\tvar flags = opts.flags || 'w';\n\t\topts.append = flags[0] !== 'w';\n\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\t\t\tif (stat && stat.isDirectory()) return cb(errno.EISDIR(key));\n\t\t\tif (stat && flags[1] === 'x') return cb(errno.EEXIST(key));\n\n\t\t\tvar blob = stat && stat.blob || key;\n\t\t\tps.writable(key, function(err) {\n\t\t\t\tif (err) return cb(err);\n\n\t\t\t\tbl.write(blob, data, opts, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\tps.put(key, {\n\t\t\t\t\t\tctime: stat && stat.ctime,\n\t\t\t\t\t\tmtime: new Date(),\n\t\t\t\t\t\tmode: opts.mode || 0666,\n\t\t\t\t\t\ttype:'file'\n\t\t\t\t\t}, listeners.cb(key, cb));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.appendFile = function(key, data, opts, cb) {\n\t\tif (typeof opts === 'function') return fs.appendFile(key, data, null, opts);\n\t\tif (typeof opts === 'string') opts = {encoding:opts};\n\t\tif (!opts) opts = {};\n\n\t\topts.flags = 'a';\n\t\tfs.writeFile(key, data, opts, cb);\n\t};\n\n\tfs.unlink = function(key, cb) {\n\t\tif (!cb) cb = noop;\n\n\t\tps.get(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (stat.isDirectory()) return cb(errno.EISDIR(key));\n\n\t\t\tvar clean = function(target) {\n\t\t\t\tpeek(links, {start:target+'\\xff', end:target+'\\xff\\xff'}, function(err) {\n\t\t\t\t\tif (err) return bl.remove(target, cb); // no more links\n\t\t\t\t\tcb();\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tvar onlink = function() {\n\t\t\t\tvar target = stat.link.slice(0, stat.link.indexOf('\\xff'));\n\t\t\t\tlinks.del(stat.link, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\tclean(target);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tps.del(key, listeners.cb(key, function(err) {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\tif (stat.link) return onlink();\n\t\t\t\tlinks.del(key+'\\xff', function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\tclean(key);\n\t\t\t\t});\n\t\t\t}));\n\t\t});\n\t};\n\n\tfs.readFile = function(key, opts, cb) {\n\t\tif (typeof opts === 'function') return fs.readFile(key, null, opts);\n\t\tif (typeof opts === 'string') opts = {encoding:opts};\n\t\tif (!opts) opts = {};\n\n\t\tvar encoding = opts.encoding || 'binary';\n\t\tvar flag = opts.flag || 'r';\n\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (stat.isDirectory()) return cb(errno.EISDIR(key));\n\n\t\t\tvar blob = stat && stat.blob || key;\n\t\t\tbl.read(blob, function(err, data) {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\tcb(null, opts.encoding ? data.toString(opts.encoding) : data);\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.createReadStream = function(key, opts) {\n\t\tif (!opts) opts = {};\n\n\t\tvar closed = false;\n\t\tvar rs = fwd.readable(function(cb) {\n\t\t\tps.follow(key, function(err, stat, key) {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\tif (stat.isDirectory()) return cb(errno.EISDIR(key));\n\n\t\t\t\tvar blob = stat && stat.blob || key;\n\t\t\t\tvar r = bl.createReadStream(blob, opts);\n\n\t\t\t\trs.emit('open');\n\t\t\t\tr.on('end', function() {\n\t\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\t\tif (!closed) rs.emit('close');\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tcb(null, r);\n\t\t\t});\n\t\t});\n\n\t\trs.on('close', function() {\n\t\t\tclosed = true;\n\t\t});\n\n\t\treturn rs;\n\t};\n\n\tfs.createWriteStream = function(key, opts) {\n\t\tif (!opts) opts = {};\n\n\t\tvar flags = opts.flags || 'w';\n\t\tvar closed = false;\n\t\tvar mode = opts.mode || 0666;\n\n\t\topts.append = flags[0] === 'a';\n\n\t\tvar ws = fwd.writable(function(cb) {\n\t\t\tps.follow(key, function(err, stat, key) {\n\t\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\t\t\t\tif (stat && stat.isDirectory()) return cb(errno.EISDIR(key));\n\t\t\t\tif (stat && flags[1] === 'x') return cb(errno.EEXIST(key));\n\n\t\t\t\tvar blob = stat && stat.blob || key;\n\t\t\t\tps.writable(blob, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\tvar ctime = stat ? stat.ctime : new Date();\n\t\t\t\t\tvar s = {\n\t\t\t\t\t\tctime: ctime,\n\t\t\t\t\t\tmtime: new Date(),\n\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\ttype:'file'\n\t\t\t\t\t};\n\n\t\t\t\t\tps.put(key, s, function(err) {\n\t\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\t\tvar w = bl.createWriteStream(blob, opts);\n\n\t\t\t\t\t\tws.emit('open');\n\t\t\t\t\t\tw.on('finish', function() {\n\t\t\t\t\t\t\ts.mtime = new Date();\n\t\t\t\t\t\t\tps.put(key, s, function() {\n\t\t\t\t\t\t\t\tlisteners.change(key);\n\t\t\t\t\t\t\t\tif (!closed) ws.emit('close');\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tcb(null, w);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tws.on('close', function() {\n\t\t\tclosed = true;\n\t\t});\n\n\t\treturn ws;\n\t};\n\n\tfs.truncate = function(key, len, cb) {\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err) return cb(err);\n\n\t\t\tvar blob = stat && stat.blob || key;\n\t\t\tbl.size(blob, function(err, size) {\n\t\t\t\tif (err) return cb(err);\n\n\t\t\t\tps.writable(key, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\tcb = once(listeners.cb(key, cb));\n\t\t\t\t\tif (!len) return bl.remove(blob, cb);\n\n\t\t\t\t\tvar ws = bl.createWriteStream(blob, {\n\t\t\t\t\t\tstart:size < len ? len-1 : len\n\t\t\t\t\t});\n\n\t\t\t\t\tws.on('error', cb);\n\t\t\t\t\tws.on('finish', cb);\n\n\t\t\t\t\tif (size < len) ws.write(new Buffer([0]));\n\t\t\t\t\tws.end();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.watchFile = function(key, opts, cb) {\n\t\tif (typeof opts === 'function') return fs.watchFile(key, null, opts);\n\t\treturn listeners.watch(ps.normalize(key), cb);\n\t};\n\n\tfs.unwatchFile = function(key, cb) {\n\t\tlisteners.unwatch(ps.normalize(key), cb);\n\t};\n\n\tfs.watch = function(key, opts, cb) {\n\t\tif (typeof opts === 'function') return fs.watch(key, null, opts)\n\t\treturn listeners.watcher(ps.normalize(key), cb);\n\t};\n\n\tfs.notify = function(cb) {\n\t\tlisteners.on('change', cb)\n\t}\n\n\tfs.open = function(key, flags, mode, cb) {\n\t\tif (typeof mode === 'function') return fs.open(key, flags, null, mode);\n\n\t\tps.follow(key, function(err, stat, key) {\n\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\n\t\t\tvar fl = flags[0];\n\t\t\tvar plus = flags[1] === '+' || flags[2] === '+';\n\t\t\tvar blob = stat && stat.blob || key;\n\n\t\t\tvar f = {\n\t\t\t\tkey: key,\n\t\t\t\tblob: blob,\n\t\t\t\tmode: mode || 0666,\n\t\t\t\treadable: fl === 'r' || ((fl === 'w' || fl === 'a') && plus),\n\t\t\t\twritable: fl === 'w' || fl === 'a' || (fl === 'r' && plus),\n\t\t\t\tappend: fl === 'a'\n\t\t\t};\n\n\t\t\tif (fl === 'r' && err) return cb(err);\n\t\t\tif (flags[1] === 'x' && stat) return cb(errno.EEXIST(key));\n\t\t\tif (stat && stat.isDirectory()) return cb(errno.EISDIR(key));\n\n\t\t\tbl.size(blob, function(err, size) {\n\t\t\t\tif (err) return cb(err);\n\n\t\t\t\tif (f.append) f.writePos = size;\n\n\t\t\t\tps.writable(key, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\tvar onready = function(err) {\n\t\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\t\tvar i = fds.indexOf(null);\n\t\t\t\t\t\tif (i === -1) i = 10+fds.push(fds.length+10)-1;\n\n\t\t\t\t\t\tf.fd = i;\n\t\t\t\t\t\tfds[i] = f;\n\t\t\t\t\t\tlisteners.change(key);\n\n\t\t\t\t\t\tcb(null, f.fd);\n\t\t\t\t\t};\n\n\t\t\t\t\tvar ontruncate = function(err) {\n\t\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\t\tif (stat) return onready();\n\t\t\t\t\t\tps.put(blob, {ctime:stat && stat.ctime, type:'file'}, onready);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (!f.append && f.writable) return bl.remove(blob, ontruncate);\n\t\t\t\t\tontruncate();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.close = function(fd, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!f) return nextTick(cb, errno.EBADF());\n\n\t\tfds[fd] = null;\n\t\tnextTick(listeners.cb(f.key, cb));\n\t};\n\n\tfs.write = function(fd, buf, off, len, pos, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f || !f.writable) return nextTick(cb, errno.EBADF());\n\n\t\tif (pos === null) pos = f.writePos || 0;\n\n\t\tvar slice = buf.slice(off, off+len);\n\t\tf.writePos = pos + slice.length;\n\n\t\tbl.write(f.blob, slice, {start:pos, append:true}, function(err) {\n\t\t\tif (err) return cb(err);\n\t\t\tcb(null, len, buf);\n\t\t});\n\t};\n\n\tfs.read = function(fd, buf, off, len, pos, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f || !f.readable) return nextTick(cb, errno.EBADF());\n\n\t\tif (pos === null) pos = fs.readPos || 0;\n\n\t\tbl.read(f.blob, {start:pos, end:pos+len-1}, function(err, read) {\n\t\t\tif (err) return cb(err);\n\t\t\tvar slice = read.slice(0, len);\n\t\t\tslice.copy(buf, off);\n\t\t\tfs.readPos = pos+slice.length;\n\t\t\tcb(null, slice.length, buf);\n\t\t});\n\t};\n\n\tfs.fsync = function(fd, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f || !f.writable) return nextTick(cb, errno.EBADF());\n\n\t\tnextTick(cb);\n\t};\n\n\tfs.ftruncate = function(fd, len, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f) return nextTick(cb, errno.EBADF());\n\n\t\tfs.truncate(f.blob, len, cb);\n\t};\n\n\tfs.fchown = function(fd, uid, gid, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f) return nextTick(cb, errno.EBADF());\n\n\t\tfs.chown(f.key, uid, gid, cb);\n\t};\n\n\tfs.fchmod = function(fd, mode, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f) return nextTick(cb, errno.EBADF());\n\n\t\tfs.chmod(f.key, mode, cb);\n\t};\n\n\tfs.futimes = function(fd, atime, mtime, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!cb) cb = noop;\n\t\tif (!f) return nextTick(cb, errno.EBADF());\n\n\t\tfs.utimes(f.key, atime, mtime, cb);\n\t};\n\n\tfs.fstat = function(fd, cb) {\n\t\tvar f = fds[fd];\n\t\tif (!f) return nextTick(cb, errno.EBADF());\n\n\t\tfs.stat(f.key, cb);\n\t};\n\n\tfs.symlink = function(target, name, cb) {\n\t\tif (!cb) cb = noop;\n\t\tps.follow(target, function(err, stat, target) {\n\t\t\tif (err) return cb(err);\n\t\t\tps.get(name, function(err, stat) {\n\t\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\t\t\t\tif (stat) return cb(errno.EEXIST(name));\n\t\t\t\tps.put(name, {type:'symlink', target:target, mode:0777}, cb);\n\t\t\t});\n\t\t});\n\t};\n\n\tfs.readlink = function(key, cb) {\n\t\tps.get(key, function(err, stat) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (!stat.target) return cb(errno.EINVAL(key));\n\t\t\tcb(null, stat.target);\n\t\t});\n\t};\n\n\tfs.link = function(target, name, cb) {\n\t\tif (!cb) cb = noop;\n\t\tps.follow(target, function(err, stat, target) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (!stat.isFile()) return cb(errno.EINVAL(target));\n\t\t\tps.get(name, function(err, st) {\n\t\t\t\tif (err && err.code !== 'ENOENT') return cb(err);\n\t\t\t\tif (st) return cb(errno.EEXIST(name));\n\t\t\t\tvar link = target+'\\xff'+inc();\n\t\t\t\tlinks.put(target+'\\xff', target, function(err) {\n\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\tlinks.put(link, target, function(err) {\n\t\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\t\tps.put(name, {type:'file', link:link, blob:target, mode:stat.mode}, cb);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\treturn fs;\n};\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"./errno\":4,\"./paths\":65,\"./watchers\":67,\"_process\":119,\"buffer\":111,\"fwd-stream\":21,\"level-blobs\":34,\"level-peek\":46,\"level-sublevel\":49,\"once\":62}],6:[function(require,module,exports){\n(function (Buffer){\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar TA = require('typedarray')\nvar U8 = typeof Uint8Array !== 'undefined' ? Uint8Array : TA.Uint8Array\n\nfunction ConcatStream(opts, cb) {\n  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!opts) opts = {}\n\n  var encoding = opts.encoding\n  var shouldInferEncoding = false\n\n  if (!encoding) {\n    shouldInferEncoding = true\n  } else {\n    encoding =  String(encoding).toLowerCase()\n    if (encoding === 'u8' || encoding === 'uint8') {\n      encoding = 'uint8array'\n    }\n  }\n\n  Writable.call(this, { objectMode: true })\n\n  this.encoding = encoding\n  this.shouldInferEncoding = shouldInferEncoding\n\n  if (cb) this.on('finish', function () { cb(this.getBody()) })\n  this.body = []\n}\n\nmodule.exports = ConcatStream\ninherits(ConcatStream, Writable)\n\nConcatStream.prototype._write = function(chunk, enc, next) {\n  this.body.push(chunk)\n  next()\n}\n\nConcatStream.prototype.inferEncoding = function (buff) {\n  var firstBuffer = buff === undefined ? this.body[0] : buff;\n  if (Buffer.isBuffer(firstBuffer)) return 'buffer'\n  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'\n  if (Array.isArray(firstBuffer)) return 'array'\n  if (typeof firstBuffer === 'string') return 'string'\n  if (Object.prototype.toString.call(firstBuffer) === \"[object Object]\") return 'object'\n  return 'buffer'\n}\n\nConcatStream.prototype.getBody = function () {\n  if (!this.encoding && this.body.length === 0) return []\n  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()\n  if (this.encoding === 'array') return arrayConcat(this.body)\n  if (this.encoding === 'string') return stringConcat(this.body)\n  if (this.encoding === 'buffer') return bufferConcat(this.body)\n  if (this.encoding === 'uint8array') return u8Concat(this.body)\n  return this.body\n}\n\nvar isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]'\n}\n\nfunction isArrayish (arr) {\n  return /Array\\]$/.test(Object.prototype.toString.call(arr))\n}\n\nfunction stringConcat (parts) {\n  var strings = []\n  var needsToString = false\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]\n    if (typeof p === 'string') {\n      strings.push(p)\n    } else if (Buffer.isBuffer(p)) {\n      strings.push(p)\n    } else {\n      strings.push(Buffer(p))\n    }\n  }\n  if (Buffer.isBuffer(parts[0])) {\n    strings = Buffer.concat(strings)\n    strings = strings.toString('utf8')\n  } else {\n    strings = strings.join('')\n  }\n  return strings\n}\n\nfunction bufferConcat (parts) {\n  var bufs = []\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]\n    if (Buffer.isBuffer(p)) {\n      bufs.push(p)\n    } else if (typeof p === 'string' || isArrayish(p)\n    || (p && typeof p.subarray === 'function')) {\n      bufs.push(Buffer(p))\n    } else bufs.push(Buffer(String(p)))\n  }\n  return Buffer.concat(bufs)\n}\n\nfunction arrayConcat (parts) {\n  var res = []\n  for (var i = 0; i < parts.length; i++) {\n    res.push.apply(res, parts[i])\n  }\n  return res\n}\n\nfunction u8Concat (parts) {\n  var len = 0\n  for (var i = 0; i < parts.length; i++) {\n    if (typeof parts[i] === 'string') {\n      parts[i] = Buffer(parts[i])\n    }\n    len += parts[i].length\n  }\n  var u8 = new U8(len)\n  for (var i = 0, offset = 0; i < parts.length; i++) {\n    var part = parts[i]\n    for (var j = 0; j < part.length; j++) {\n      u8[offset++] = part[j]\n    }\n  }\n  return u8\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":111,\"inherits\":7,\"readable-stream\":16,\"typedarray\":17}],7:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],8:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_readable\":10,\"./_stream_writable\":12,\"_process\":119,\"core-util-is\":13,\"inherits\":7}],9:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":11,\"core-util-is\":13,\"inherits\":7}],10:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":8,\"_process\":119,\"buffer\":111,\"core-util-is\":13,\"events\":115,\"inherits\":7,\"isarray\":14,\"stream\":131,\"string_decoder/\":15,\"util\":110}],11:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":8,\"core-util-is\":13,\"inherits\":7}],12:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":8,\"_process\":119,\"buffer\":111,\"core-util-is\":13,\"inherits\":7,\"stream\":131}],13:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return Buffer.isBuffer(arg);\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":111}],14:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],15:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":111}],16:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":8,\"./lib/_stream_passthrough.js\":9,\"./lib/_stream_readable.js\":10,\"./lib/_stream_transform.js\":11,\"./lib/_stream_writable.js\":12,\"stream\":131}],17:[function(require,module,exports){\nvar undefined = (void 0); // Paranoia\n\n// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n// create, and consume so much memory, that the browser appears frozen.\nvar MAX_ARRAY_LENGTH = 1e5;\n\n// Approximations of internal ECMAScript conversion functions\nvar ECMAScript = (function() {\n  // Stash a copy in case other scripts modify these\n  var opts = Object.prototype.toString,\n      ophop = Object.prototype.hasOwnProperty;\n\n  return {\n    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n    Class: function(v) { return opts.call(v).replace(/^\\[object *|\\]$/g, ''); },\n    HasProperty: function(o, p) { return p in o; },\n    HasOwnProperty: function(o, p) { return ophop.call(o, p); },\n    IsCallable: function(o) { return typeof o === 'function'; },\n    ToInt32: function(v) { return v >> 0; },\n    ToUint32: function(v) { return v >>> 0; }\n  };\n}());\n\n// Snapshot intrinsics\nvar LN2 = Math.LN2,\n    abs = Math.abs,\n    floor = Math.floor,\n    log = Math.log,\n    min = Math.min,\n    pow = Math.pow,\n    round = Math.round;\n\n// ES5: lock down object properties\nfunction configureProperties(obj) {\n  if (getOwnPropNames && defineProp) {\n    var props = getOwnPropNames(obj), i;\n    for (i = 0; i < props.length; i += 1) {\n      defineProp(obj, props[i], {\n        value: obj[props[i]],\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n}\n\n// emulate ES5 getter/setter API using legacy APIs\n// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\nvar defineProp\nif (Object.defineProperty && (function() {\n      try {\n        Object.defineProperty({}, 'x', {});\n        return true;\n      } catch (e) {\n        return false;\n      }\n    })()) {\n  defineProp = Object.defineProperty;\n} else {\n  defineProp = function(o, p, desc) {\n    if (!o === Object(o)) throw new TypeError(\"Object.defineProperty called on non-object\");\n    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }\n    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }\n    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }\n    return o;\n  };\n}\n\nvar getOwnPropNames = Object.getOwnPropertyNames || function (o) {\n  if (o !== Object(o)) throw new TypeError(\"Object.getOwnPropertyNames called on non-object\");\n  var props = [], p;\n  for (p in o) {\n    if (ECMAScript.HasOwnProperty(o, p)) {\n      props.push(p);\n    }\n  }\n  return props;\n};\n\n// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n// for index in 0 ... obj.length\nfunction makeArrayAccessors(obj) {\n  if (!defineProp) { return; }\n\n  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError(\"Array too large for polyfill\");\n\n  function makeArrayAccessor(index) {\n    defineProp(obj, index, {\n      'get': function() { return obj._getter(index); },\n      'set': function(v) { obj._setter(index, v); },\n      enumerable: true,\n      configurable: false\n    });\n  }\n\n  var i;\n  for (i = 0; i < obj.length; i += 1) {\n    makeArrayAccessor(i);\n  }\n}\n\n// Internal conversion functions:\n//    pack<Type>()   - take a number (interpreted as Type), output a byte array\n//    unpack<Type>() - take a byte array, output a Type-like number\n\nfunction as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\nfunction as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n\nfunction packI8(n) { return [n & 0xff]; }\nfunction unpackI8(bytes) { return as_signed(bytes[0], 8); }\n\nfunction packU8(n) { return [n & 0xff]; }\nfunction unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n\nfunction packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n\nfunction packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packIEEE754(v, ebits, fbits) {\n\n  var bias = (1 << (ebits - 1)) - 1,\n      s, e, f, ln,\n      i, bits, str, bytes;\n\n  function roundToEven(n) {\n    var w = floor(n), f = n - w;\n    if (f < 0.5)\n      return w;\n    if (f > 0.5)\n      return w + 1;\n    return w % 2 ? w + 1 : w;\n  }\n\n  // Compute sign, exponent, fraction\n  if (v !== v) {\n    // NaN\n    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n  } else if (v === Infinity || v === -Infinity) {\n    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n  } else if (v === 0) {\n    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n  } else {\n    s = v < 0;\n    v = abs(v);\n\n    if (v >= pow(2, 1 - bias)) {\n      e = min(floor(log(v) / LN2), 1023);\n      f = roundToEven(v / pow(2, e) * pow(2, fbits));\n      if (f / pow(2, fbits) >= 2) {\n        e = e + 1;\n        f = 1;\n      }\n      if (e > bias) {\n        // Overflow\n        e = (1 << ebits) - 1;\n        f = 0;\n      } else {\n        // Normalized\n        e = e + bias;\n        f = f - pow(2, fbits);\n      }\n    } else {\n      // Denormalized\n      e = 0;\n      f = roundToEven(v / pow(2, 1 - bias - fbits));\n    }\n  }\n\n  // Pack sign, exponent, fraction\n  bits = [];\n  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n  bits.push(s ? 1 : 0);\n  bits.reverse();\n  str = bits.join('');\n\n  // Bits to bytes\n  bytes = [];\n  while (str.length) {\n    bytes.push(parseInt(str.substring(0, 8), 2));\n    str = str.substring(8);\n  }\n  return bytes;\n}\n\nfunction unpackIEEE754(bytes, ebits, fbits) {\n\n  // Bytes to bits\n  var bits = [], i, j, b, str,\n      bias, s, e, f;\n\n  for (i = bytes.length; i; i -= 1) {\n    b = bytes[i - 1];\n    for (j = 8; j; j -= 1) {\n      bits.push(b % 2 ? 1 : 0); b = b >> 1;\n    }\n  }\n  bits.reverse();\n  str = bits.join('');\n\n  // Unpack sign, exponent, fraction\n  bias = (1 << (ebits - 1)) - 1;\n  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n  e = parseInt(str.substring(1, 1 + ebits), 2);\n  f = parseInt(str.substring(1 + ebits), 2);\n\n  // Produce number\n  if (e === (1 << ebits) - 1) {\n    return f !== 0 ? NaN : s * Infinity;\n  } else if (e > 0) {\n    // Normalized\n    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n  } else if (f !== 0) {\n    // Denormalized\n    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n  } else {\n    return s < 0 ? -0 : 0;\n  }\n}\n\nfunction unpackF64(b) { return unpackIEEE754(b, 11, 52); }\nfunction packF64(v) { return packIEEE754(v, 11, 52); }\nfunction unpackF32(b) { return unpackIEEE754(b, 8, 23); }\nfunction packF32(v) { return packIEEE754(v, 8, 23); }\n\n\n//\n// 3 The ArrayBuffer Type\n//\n\n(function() {\n\n  /** @constructor */\n  var ArrayBuffer = function ArrayBuffer(length) {\n    length = ECMAScript.ToInt32(length);\n    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');\n\n    this.byteLength = length;\n    this._bytes = [];\n    this._bytes.length = length;\n\n    var i;\n    for (i = 0; i < this.byteLength; i += 1) {\n      this._bytes[i] = 0;\n    }\n\n    configureProperties(this);\n  };\n\n  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;\n\n  //\n  // 4 The ArrayBufferView Type\n  //\n\n  // NOTE: this constructor is not exported\n  /** @constructor */\n  var ArrayBufferView = function ArrayBufferView() {\n    //this.buffer = null;\n    //this.byteOffset = 0;\n    //this.byteLength = 0;\n  };\n\n  //\n  // 5 The Typed Array View Types\n  //\n\n  function makeConstructor(bytesPerElement, pack, unpack) {\n    // Each TypedArray type requires a distinct constructor instance with\n    // identical logic, which this produces.\n\n    var ctor;\n    ctor = function(buffer, byteOffset, length) {\n      var array, sequence, i, s;\n\n      if (!arguments.length || typeof arguments[0] === 'number') {\n        // Constructor(unsigned long length)\n        this.length = ECMAScript.ToInt32(arguments[0]);\n        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');\n\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {\n        // Constructor(TypedArray array)\n        array = arguments[0];\n\n        this.length = array.length;\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          this._setter(i, array._getter(i));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(sequence<type> array)\n        sequence = arguments[0];\n\n        this.length = ECMAScript.ToUint32(sequence.length);\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          s = sequence[i];\n          this._setter(i, Number(s));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(ArrayBuffer buffer,\n        //             optional unsigned long byteOffset, optional unsigned long length)\n        this.buffer = buffer;\n\n        this.byteOffset = ECMAScript.ToUint32(byteOffset);\n        if (this.byteOffset > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset out of range\");\n        }\n\n        if (this.byteOffset % this.BYTES_PER_ELEMENT) {\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          throw new RangeError(\"ArrayBuffer length minus the byteOffset is not a multiple of the element size.\");\n        }\n\n        if (arguments.length < 3) {\n          this.byteLength = this.buffer.byteLength - this.byteOffset;\n\n          if (this.byteLength % this.BYTES_PER_ELEMENT) {\n            throw new RangeError(\"length of buffer minus byteOffset not a multiple of the element size\");\n          }\n          this.length = this.byteLength / this.BYTES_PER_ELEMENT;\n        } else {\n          this.length = ECMAScript.ToUint32(length);\n          this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        }\n\n        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n\n      this.constructor = ctor;\n\n      configureProperties(this);\n      makeArrayAccessors(this);\n    };\n\n    ctor.prototype = new ArrayBufferView();\n    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;\n    ctor.prototype._pack = pack;\n    ctor.prototype._unpack = unpack;\n    ctor.BYTES_PER_ELEMENT = bytesPerElement;\n\n    // getter type (unsigned long index);\n    ctor.prototype._getter = function(index) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = [], i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    };\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    ctor.prototype.get = ctor.prototype._getter;\n\n    // setter void (unsigned long index, type value);\n    ctor.prototype._setter = function(index, value) {\n      if (arguments.length < 2) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = this._pack(value), i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    };\n\n    // void set(TypedArray array, optional unsigned long offset);\n    // void set(sequence<type> array, optional unsigned long offset);\n    ctor.prototype.set = function(index, value) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n      var array, sequence, offset, len,\n          i, s, d,\n          byteOffset, byteLength, tmp;\n\n      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + array.length > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset;\n               i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ECMAScript.ToUint32(sequence.length);\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + len > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n    };\n\n    // TypedArray subarray(long begin, optional long end);\n    ctor.prototype.subarray = function(start, end) {\n      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n      start = ECMAScript.ToInt32(start);\n      end = ECMAScript.ToInt32(end);\n\n      if (arguments.length < 1) { start = 0; }\n      if (arguments.length < 2) { end = this.length; }\n\n      if (start < 0) { start = this.length + start; }\n      if (end < 0) { end = this.length + end; }\n\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n\n      return new this.constructor(\n        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    };\n\n    return ctor;\n  }\n\n  var Int8Array = makeConstructor(1, packI8, unpackI8);\n  var Uint8Array = makeConstructor(1, packU8, unpackU8);\n  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);\n  var Int16Array = makeConstructor(2, packI16, unpackI16);\n  var Uint16Array = makeConstructor(2, packU16, unpackU16);\n  var Int32Array = makeConstructor(4, packI32, unpackI32);\n  var Uint32Array = makeConstructor(4, packU32, unpackU32);\n  var Float32Array = makeConstructor(4, packF32, unpackF32);\n  var Float64Array = makeConstructor(8, packF64, unpackF64);\n\n  exports.Int8Array = exports.Int8Array || Int8Array;\n  exports.Uint8Array = exports.Uint8Array || Uint8Array;\n  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;\n  exports.Int16Array = exports.Int16Array || Int16Array;\n  exports.Uint16Array = exports.Uint16Array || Uint16Array;\n  exports.Int32Array = exports.Int32Array || Int32Array;\n  exports.Uint32Array = exports.Uint32Array || Uint32Array;\n  exports.Float32Array = exports.Float32Array || Float32Array;\n  exports.Float64Array = exports.Float64Array || Float64Array;\n}());\n\n//\n// 6 The DataView View Type\n//\n\n(function() {\n  function r(array, index) {\n    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];\n  }\n\n  var IS_BIG_ENDIAN = (function() {\n    var u16array = new(exports.Uint16Array)([0x1234]),\n        u8array = new(exports.Uint8Array)(u16array.buffer);\n    return r(u8array, 0) === 0x12;\n  }());\n\n  // Constructor(ArrayBuffer buffer,\n  //             optional unsigned long byteOffset,\n  //             optional unsigned long byteLength)\n  /** @constructor */\n  var DataView = function DataView(buffer, byteOffset, byteLength) {\n    if (arguments.length === 0) {\n      buffer = new exports.ArrayBuffer(0);\n    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {\n      throw new TypeError(\"TypeError\");\n    }\n\n    this.buffer = buffer || new exports.ArrayBuffer(0);\n\n    this.byteOffset = ECMAScript.ToUint32(byteOffset);\n    if (this.byteOffset > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset out of range\");\n    }\n\n    if (arguments.length < 3) {\n      this.byteLength = this.buffer.byteLength - this.byteOffset;\n    } else {\n      this.byteLength = ECMAScript.ToUint32(byteLength);\n    }\n\n    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n    }\n\n    configureProperties(this);\n  };\n\n  function makeGetter(arrayType) {\n    return function(byteOffset, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n      byteOffset += this.byteOffset;\n\n      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n          bytes = [], i;\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(uint8Array, i));\n      }\n\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);\n    };\n  }\n\n  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);\n  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);\n  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);\n  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);\n  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);\n  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);\n  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);\n  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);\n\n  function makeSetter(arrayType) {\n    return function(byteOffset, value, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n\n      // Get bytes\n      var typeArray = new arrayType([value]),\n          byteArray = new exports.Uint8Array(typeArray.buffer),\n          bytes = [], i, byteView;\n\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(byteArray, i));\n      }\n\n      // Flip if necessary\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      // Write them\n      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n      byteView.set(bytes);\n    };\n  }\n\n  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);\n  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);\n  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);\n  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);\n  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);\n  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);\n  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);\n  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);\n\n  exports.DataView = exports.DataView || DataView;\n\n}());\n\n},{}],18:[function(require,module,exports){\nvar prr = require('prr')\n\nfunction init (type, message, cause) {\n  prr(this, {\n      type    : type\n    , name    : type\n      // can be passed just a 'cause'\n    , cause   : typeof message != 'string' ? message : cause\n    , message : !!message && typeof message != 'string' ? message.message : message\n\n  }, 'ewr')\n}\n\n// generic prototype, not intended to be actually used - helpful for `instanceof`\nfunction CustomError (message, cause) {\n  Error.call(this)\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, arguments.callee)\n  init.call(this, 'CustomError', message, cause)\n}\n\nCustomError.prototype = new Error()\n\nfunction createError (errno, type, proto) {\n  var err = function (message, cause) {\n    init.call(this, type, message, cause)\n    //TODO: the specificity here is stupid, errno should be available everywhere\n    if (type == 'FilesystemError') {\n      this.code    = this.cause.code\n      this.path    = this.cause.path\n      this.errno   = this.cause.errno\n      this.message =\n        (errno.errno[this.cause.errno]\n          ? errno.errno[this.cause.errno].description\n          : this.cause.message)\n        + (this.cause.path ? ' [' + this.cause.path + ']' : '')\n    }\n    Error.call(this)\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(this, arguments.callee)\n  }\n  err.prototype = !!proto ? new proto() : new CustomError()\n  return err\n}\n\nmodule.exports = function (errno) {\n  var ce = function (type, proto) {\n    return createError(errno, type, proto)\n  }\n  return {\n      CustomError     : CustomError\n    , FilesystemError : ce('FilesystemError')\n    , createError     : ce\n  }\n}\n\n},{\"prr\":20}],19:[function(require,module,exports){\nvar all = module.exports.all = [\n {\n  \"errno\": -1,\n  \"code\": \"UNKNOWN\",\n  \"description\": \"unknown error\"\n },\n {\n  \"errno\": 0,\n  \"code\": \"OK\",\n  \"description\": \"success\"\n },\n {\n  \"errno\": 1,\n  \"code\": \"EOF\",\n  \"description\": \"end of file\"\n },\n {\n  \"errno\": 2,\n  \"code\": \"EADDRINFO\",\n  \"description\": \"getaddrinfo error\"\n },\n {\n  \"errno\": 3,\n  \"code\": \"EACCES\",\n  \"description\": \"permission denied\"\n },\n {\n  \"errno\": 4,\n  \"code\": \"EAGAIN\",\n  \"description\": \"resource temporarily unavailable\"\n },\n {\n  \"errno\": 5,\n  \"code\": \"EADDRINUSE\",\n  \"description\": \"address already in use\"\n },\n {\n  \"errno\": 6,\n  \"code\": \"EADDRNOTAVAIL\",\n  \"description\": \"address not available\"\n },\n {\n  \"errno\": 7,\n  \"code\": \"EAFNOSUPPORT\",\n  \"description\": \"address family not supported\"\n },\n {\n  \"errno\": 8,\n  \"code\": \"EALREADY\",\n  \"description\": \"connection already in progress\"\n },\n {\n  \"errno\": 9,\n  \"code\": \"EBADF\",\n  \"description\": \"bad file descriptor\"\n },\n {\n  \"errno\": 10,\n  \"code\": \"EBUSY\",\n  \"description\": \"resource busy or locked\"\n },\n {\n  \"errno\": 11,\n  \"code\": \"ECONNABORTED\",\n  \"description\": \"software caused connection abort\"\n },\n {\n  \"errno\": 12,\n  \"code\": \"ECONNREFUSED\",\n  \"description\": \"connection refused\"\n },\n {\n  \"errno\": 13,\n  \"code\": \"ECONNRESET\",\n  \"description\": \"connection reset by peer\"\n },\n {\n  \"errno\": 14,\n  \"code\": \"EDESTADDRREQ\",\n  \"description\": \"destination address required\"\n },\n {\n  \"errno\": 15,\n  \"code\": \"EFAULT\",\n  \"description\": \"bad address in system call argument\"\n },\n {\n  \"errno\": 16,\n  \"code\": \"EHOSTUNREACH\",\n  \"description\": \"host is unreachable\"\n },\n {\n  \"errno\": 17,\n  \"code\": \"EINTR\",\n  \"description\": \"interrupted system call\"\n },\n {\n  \"errno\": 18,\n  \"code\": \"EINVAL\",\n  \"description\": \"invalid argument\"\n },\n {\n  \"errno\": 19,\n  \"code\": \"EISCONN\",\n  \"description\": \"socket is already connected\"\n },\n {\n  \"errno\": 20,\n  \"code\": \"EMFILE\",\n  \"description\": \"too many open files\"\n },\n {\n  \"errno\": 21,\n  \"code\": \"EMSGSIZE\",\n  \"description\": \"message too long\"\n },\n {\n  \"errno\": 22,\n  \"code\": \"ENETDOWN\",\n  \"description\": \"network is down\"\n },\n {\n  \"errno\": 23,\n  \"code\": \"ENETUNREACH\",\n  \"description\": \"network is unreachable\"\n },\n {\n  \"errno\": 24,\n  \"code\": \"ENFILE\",\n  \"description\": \"file table overflow\"\n },\n {\n  \"errno\": 25,\n  \"code\": \"ENOBUFS\",\n  \"description\": \"no buffer space available\"\n },\n {\n  \"errno\": 26,\n  \"code\": \"ENOMEM\",\n  \"description\": \"not enough memory\"\n },\n {\n  \"errno\": 27,\n  \"code\": \"ENOTDIR\",\n  \"description\": \"not a directory\"\n },\n {\n  \"errno\": 28,\n  \"code\": \"EISDIR\",\n  \"description\": \"illegal operation on a directory\"\n },\n {\n  \"errno\": 29,\n  \"code\": \"ENONET\",\n  \"description\": \"machine is not on the network\"\n },\n {\n  \"errno\": 31,\n  \"code\": \"ENOTCONN\",\n  \"description\": \"socket is not connected\"\n },\n {\n  \"errno\": 32,\n  \"code\": \"ENOTSOCK\",\n  \"description\": \"socket operation on non-socket\"\n },\n {\n  \"errno\": 33,\n  \"code\": \"ENOTSUP\",\n  \"description\": \"operation not supported on socket\"\n },\n {\n  \"errno\": 34,\n  \"code\": \"ENOENT\",\n  \"description\": \"no such file or directory\"\n },\n {\n  \"errno\": 35,\n  \"code\": \"ENOSYS\",\n  \"description\": \"function not implemented\"\n },\n {\n  \"errno\": 36,\n  \"code\": \"EPIPE\",\n  \"description\": \"broken pipe\"\n },\n {\n  \"errno\": 37,\n  \"code\": \"EPROTO\",\n  \"description\": \"protocol error\"\n },\n {\n  \"errno\": 38,\n  \"code\": \"EPROTONOSUPPORT\",\n  \"description\": \"protocol not supported\"\n },\n {\n  \"errno\": 39,\n  \"code\": \"EPROTOTYPE\",\n  \"description\": \"protocol wrong type for socket\"\n },\n {\n  \"errno\": 40,\n  \"code\": \"ETIMEDOUT\",\n  \"description\": \"connection timed out\"\n },\n {\n  \"errno\": 41,\n  \"code\": \"ECHARSET\",\n  \"description\": \"invalid Unicode character\"\n },\n {\n  \"errno\": 42,\n  \"code\": \"EAIFAMNOSUPPORT\",\n  \"description\": \"address family for hostname not supported\"\n },\n {\n  \"errno\": 44,\n  \"code\": \"EAISERVICE\",\n  \"description\": \"servname not supported for ai_socktype\"\n },\n {\n  \"errno\": 45,\n  \"code\": \"EAISOCKTYPE\",\n  \"description\": \"ai_socktype not supported\"\n },\n {\n  \"errno\": 46,\n  \"code\": \"ESHUTDOWN\",\n  \"description\": \"cannot send after transport endpoint shutdown\"\n },\n {\n  \"errno\": 47,\n  \"code\": \"EEXIST\",\n  \"description\": \"file already exists\"\n },\n {\n  \"errno\": 48,\n  \"code\": \"ESRCH\",\n  \"description\": \"no such process\"\n },\n {\n  \"errno\": 49,\n  \"code\": \"ENAMETOOLONG\",\n  \"description\": \"name too long\"\n },\n {\n  \"errno\": 50,\n  \"code\": \"EPERM\",\n  \"description\": \"operation not permitted\"\n },\n {\n  \"errno\": 51,\n  \"code\": \"ELOOP\",\n  \"description\": \"too many symbolic links encountered\"\n },\n {\n  \"errno\": 52,\n  \"code\": \"EXDEV\",\n  \"description\": \"cross-device link not permitted\"\n },\n {\n  \"errno\": 53,\n  \"code\": \"ENOTEMPTY\",\n  \"description\": \"directory not empty\"\n },\n {\n  \"errno\": 54,\n  \"code\": \"ENOSPC\",\n  \"description\": \"no space left on device\"\n },\n {\n  \"errno\": 55,\n  \"code\": \"EIO\",\n  \"description\": \"i/o error\"\n },\n {\n  \"errno\": 56,\n  \"code\": \"EROFS\",\n  \"description\": \"read-only file system\"\n },\n {\n  \"errno\": 57,\n  \"code\": \"ENODEV\",\n  \"description\": \"no such device\"\n },\n {\n  \"errno\": 58,\n  \"code\": \"ESPIPE\",\n  \"description\": \"invalid seek\"\n },\n {\n  \"errno\": 59,\n  \"code\": \"ECANCELED\",\n  \"description\": \"operation canceled\"\n }\n]\n\n\nmodule.exports.errno = {\n    '-1': all[0]\n  , '0': all[1]\n  , '1': all[2]\n  , '2': all[3]\n  , '3': all[4]\n  , '4': all[5]\n  , '5': all[6]\n  , '6': all[7]\n  , '7': all[8]\n  , '8': all[9]\n  , '9': all[10]\n  , '10': all[11]\n  , '11': all[12]\n  , '12': all[13]\n  , '13': all[14]\n  , '14': all[15]\n  , '15': all[16]\n  , '16': all[17]\n  , '17': all[18]\n  , '18': all[19]\n  , '19': all[20]\n  , '20': all[21]\n  , '21': all[22]\n  , '22': all[23]\n  , '23': all[24]\n  , '24': all[25]\n  , '25': all[26]\n  , '26': all[27]\n  , '27': all[28]\n  , '28': all[29]\n  , '29': all[30]\n  , '31': all[31]\n  , '32': all[32]\n  , '33': all[33]\n  , '34': all[34]\n  , '35': all[35]\n  , '36': all[36]\n  , '37': all[37]\n  , '38': all[38]\n  , '39': all[39]\n  , '40': all[40]\n  , '41': all[41]\n  , '42': all[42]\n  , '44': all[43]\n  , '45': all[44]\n  , '46': all[45]\n  , '47': all[46]\n  , '48': all[47]\n  , '49': all[48]\n  , '50': all[49]\n  , '51': all[50]\n  , '52': all[51]\n  , '53': all[52]\n  , '54': all[53]\n  , '55': all[54]\n  , '56': all[55]\n  , '57': all[56]\n  , '58': all[57]\n  , '59': all[58]\n}\n\n\nmodule.exports.code = {\n    'UNKNOWN': all[0]\n  , 'OK': all[1]\n  , 'EOF': all[2]\n  , 'EADDRINFO': all[3]\n  , 'EACCES': all[4]\n  , 'EAGAIN': all[5]\n  , 'EADDRINUSE': all[6]\n  , 'EADDRNOTAVAIL': all[7]\n  , 'EAFNOSUPPORT': all[8]\n  , 'EALREADY': all[9]\n  , 'EBADF': all[10]\n  , 'EBUSY': all[11]\n  , 'ECONNABORTED': all[12]\n  , 'ECONNREFUSED': all[13]\n  , 'ECONNRESET': all[14]\n  , 'EDESTADDRREQ': all[15]\n  , 'EFAULT': all[16]\n  , 'EHOSTUNREACH': all[17]\n  , 'EINTR': all[18]\n  , 'EINVAL': all[19]\n  , 'EISCONN': all[20]\n  , 'EMFILE': all[21]\n  , 'EMSGSIZE': all[22]\n  , 'ENETDOWN': all[23]\n  , 'ENETUNREACH': all[24]\n  , 'ENFILE': all[25]\n  , 'ENOBUFS': all[26]\n  , 'ENOMEM': all[27]\n  , 'ENOTDIR': all[28]\n  , 'EISDIR': all[29]\n  , 'ENONET': all[30]\n  , 'ENOTCONN': all[31]\n  , 'ENOTSOCK': all[32]\n  , 'ENOTSUP': all[33]\n  , 'ENOENT': all[34]\n  , 'ENOSYS': all[35]\n  , 'EPIPE': all[36]\n  , 'EPROTO': all[37]\n  , 'EPROTONOSUPPORT': all[38]\n  , 'EPROTOTYPE': all[39]\n  , 'ETIMEDOUT': all[40]\n  , 'ECHARSET': all[41]\n  , 'EAIFAMNOSUPPORT': all[42]\n  , 'EAISERVICE': all[43]\n  , 'EAISOCKTYPE': all[44]\n  , 'ESHUTDOWN': all[45]\n  , 'EEXIST': all[46]\n  , 'ESRCH': all[47]\n  , 'ENAMETOOLONG': all[48]\n  , 'EPERM': all[49]\n  , 'ELOOP': all[50]\n  , 'EXDEV': all[51]\n  , 'ENOTEMPTY': all[52]\n  , 'ENOSPC': all[53]\n  , 'EIO': all[54]\n  , 'EROFS': all[55]\n  , 'ENODEV': all[56]\n  , 'ESPIPE': all[57]\n  , 'ECANCELED': all[58]\n}\n\n\nmodule.exports.custom = require(\"./custom\")(module.exports)\nmodule.exports.create = module.exports.custom.createError\n},{\"./custom\":18}],20:[function(require,module,exports){\n/*!\n  * prr\n  * (c) 2013 Rod Vagg <rod@vagg.org>\n  * https://github.com/rvagg/prr\n  * License: MIT\n  */\n\n(function (name, context, definition) {\n  if (typeof module != 'undefined' && module.exports)\n    module.exports = definition()\n  else\n    context[name] = definition()\n})('prr', this, function() {\n\n  var setProperty = typeof Object.defineProperty == 'function'\n      ? function (obj, key, options) {\n          Object.defineProperty(obj, key, options)\n          return obj\n        }\n      : function (obj, key, options) { // < es5\n          obj[key] = options.value\n          return obj\n        }\n\n    , makeOptions = function (value, options) {\n        var oo = typeof options == 'object'\n          , os = !oo && typeof options == 'string'\n          , op = function (p) {\n              return oo\n                ? !!options[p]\n                : os\n                  ? options.indexOf(p[0]) > -1\n                  : false\n            }\n\n        return {\n            enumerable   : op('enumerable')\n          , configurable : op('configurable')\n          , writable     : op('writable')\n          , value        : value\n        }\n      }\n\n    , prr = function (obj, key, value, options) {\n        var k\n\n        options = makeOptions(value, options)\n\n        if (typeof key == 'object') {\n          for (k in key) {\n            if (Object.hasOwnProperty.call(key, k)) {\n              options.value = key[k]\n              setProperty(obj, k, options)\n            }\n          }\n          return obj\n        }\n\n        return setProperty(obj, key, options)\n      }\n\n  return prr\n})\n},{}],21:[function(require,module,exports){\n(function (process,Buffer){\nvar Writable = require('readable-stream/writable');\nvar Readable = require('readable-stream/readable');\nvar Duplex = require('readable-stream/duplex');\n\nvar DUMMY = new Buffer(0);\nvar noop = function() {};\n\nvar toFunction = function(fn) {\n\tif (typeof fn === 'function') return fn;\n\treturn function(cb) {\n\t\tcb(null, fn);\n\t};\n};\n\nvar onreadable = function(rs, init) {\n\tvar reading = false;\n\tvar destroyed = false;\n\n\trs._read = function() {\n\t\treading = true;\n\t};\n\n\trs.destroy = function() {\n\t\tdestroyed = true;\n\t};\n\n\tinit(function(err, source) {\n\t\tif (err) return rs.emit('error', err);\n\n\t\tvar fwd = function() {\n\t\t\tvar data;\n\t\t\twhile ((data = source.read()) !== null) {\n\t\t\t\treading = false;\n\t\t\t\trs.push(data);\n\t\t\t}\n\t\t};\n\n\t\tsource.on('readable', function() {\n\t\t\tif (reading) fwd();\n\t\t});\n\n\t\tsource.on('end', function() {\n\t\t\tfwd();\n\t\t\trs.push(null);\n\t\t});\n\n\t\tsource.on('error', function(err) {\n\t\t\trs.emit('error', err);\n\t\t});\n\n\t\tsource.on('close', function() {\n\t\t\tfwd();\n\t\t\tprocess.nextTick(function() {\n\t\t\t\trs.emit('close');\n\t\t\t});\n\t\t});\n\n\t\trs._read = function() {\n\t\t\treading = true;\n\t\t\tfwd();\n\t\t};\n\n\t\trs.destroy = function() {\n\t\t\tif (destroyed) return;\n\t\t\tdestroyed = true;\n\t\t\tif (source.destroy) source.destroy();\n\t\t};\n\n\t\tif (destroyed) {\n\t\t\tdestroyed = false;\n\t\t\trs.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tif (reading) fwd();\n\t});\n\n\treturn rs;\n};\n\nvar onwritable = function(ws, init) {\n\tvar ready = noop;\n\tvar destroyed = false;\n\n\tws._write = function(data, enc, cb) {\n\t\tready = cb;\n\t};\n\n\tws.destroy = function() {\n\t\tdestroyed = true;\n\t};\n\n\tws.write(DUMMY);\n\n\tinit(function(err, source) {\n\t\tif (err) return ws.emit('error', err);\n\n\t\tsource.on('close', function() {\n\t\t\tws.emit('close');\n\t\t});\n\n\t\tsource.on('error', function(err) {\n\t\t\tws.emit('error', err);\n\t\t});\n\n\t\tws._write = function(data, enc, cb) {\n\t\t\tif (data === DUMMY) return cb();\n\t\t\tsource.write(data, enc, cb);\n\t\t};\n\n\t\tvar emit = ws.emit;\n\n\t\tsource.on('finish', function() {\n\t\t\temit.call(ws, 'finish');\n\t\t});\n\n\t\tws.destroy = function() {\n\t\t\tif (destroyed) return;\n\t\t\tdestroyed = true;\n\t\t\tif (source.destroy) source.destroy();\n\t\t};\n\n\t\tws.emit = function(name) {\n\t\t\tif (name !== 'finish') return emit.apply(ws, arguments);\n\t\t\tsource.end();\n\t\t};\n\n\t\tif (destroyed) {\n\t\t\tdestroyed = false;\n\t\t\tws.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tready();\n\t});\n\n\treturn ws;\n};\n\nexports.readable = function(opts, init) {\n\tif (arguments.length === 1) return exports.readable(null, opts);\n\tif (!opts) opts = {};\n\treturn onreadable(new Readable(opts), toFunction(init));\n};\n\nexports.writable = function(opts, init) {\n\tif (arguments.length === 1) return exports.writable(null, opts);\n\tif (!opts) opts = {};\n\treturn onwritable(new Writable(opts), toFunction(init));\n};\n\nexports.duplex = function(opts, initWritable, initReadable) {\n\tif (arguments.length === 2) return exports.duplex(null, opts, initWritable);\n\tif (!opts) opts = {};\n\tvar dupl = new Duplex(opts);\n\tonwritable(dupl, toFunction(initWritable));\n\tonreadable(dupl, toFunction(initReadable));\n\treturn dupl;\n};\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":119,\"buffer\":111,\"readable-stream/duplex\":22,\"readable-stream/readable\":32,\"readable-stream/writable\":33}],22:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":23}],23:[function(require,module,exports){\narguments[4][8][0].apply(exports,arguments)\n},{\"./_stream_readable\":25,\"./_stream_writable\":27,\"_process\":119,\"core-util-is\":28,\"dup\":8,\"inherits\":29}],24:[function(require,module,exports){\narguments[4][9][0].apply(exports,arguments)\n},{\"./_stream_transform\":26,\"core-util-is\":28,\"dup\":9,\"inherits\":29}],25:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n  var ret;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    ret = null;\n\n    // In cases where the decoder did not receive enough data\n    // to produce a full chunk, then immediately received an\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n    // howMuchToRead will see this and coerce the amount to\n    // read to zero (because it's looking at the length of the\n    // first <Buffer > in state.buffer), and we'll end up here.\n    //\n    // This can only happen via state.decoder -- no other venue\n    // exists for pushing a zero-length chunk into state.buffer\n    // and triggering this behavior. In this case, we return our\n    // remaining data and end the stream, if appropriate.\n    if (state.length > 0 && state.decoder) {\n      ret = fromList(n, state);\n      state.length -= ret.length;\n    }\n\n    if (state.length === 0)\n      endReadable(this);\n\n    return ret;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    //if (state.objectMode && util.isNullOrUndefined(chunk))\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"_process\":119,\"buffer\":111,\"core-util-is\":28,\"events\":115,\"inherits\":29,\"isarray\":30,\"stream\":131,\"string_decoder/\":31}],26:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":23,\"core-util-is\":28,\"inherits\":29}],27:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":23,\"_process\":119,\"buffer\":111,\"core-util-is\":28,\"inherits\":29,\"stream\":131}],28:[function(require,module,exports){\narguments[4][13][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":13}],29:[function(require,module,exports){\narguments[4][7][0].apply(exports,arguments)\n},{\"dup\":7}],30:[function(require,module,exports){\narguments[4][14][0].apply(exports,arguments)\n},{\"dup\":14}],31:[function(require,module,exports){\narguments[4][15][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":15}],32:[function(require,module,exports){\nvar Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":23,\"./lib/_stream_passthrough.js\":24,\"./lib/_stream_readable.js\":25,\"./lib/_stream_transform.js\":26,\"./lib/_stream_writable.js\":27,\"stream\":131}],33:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":27}],34:[function(require,module,exports){\n(function (process,Buffer){\nvar Writable = require('readable-stream/writable');\nvar Readable = require('readable-stream/readable');\nvar peek = require('level-peek');\nvar util = require('util');\nvar once = require('once');\n\nvar EMPTY = new Buffer(0);\nvar ENCODER = {\n\tencode: function(data) {\n\t\treturn typeof data === 'string' ? data = new Buffer(data) : data;\n\t},\n\tdecode: function(data) {\n\t\treturn Buffer.isBuffer(data) ? data : new Buffer(data);\n\t},\n\tbuffer: true,\n\ttype: 'raw'\n};\n\nvar noop = function() {};\n\nvar pad = function(n) {\n\tn = n.toString(16);\n\treturn '00000000'.slice(0, -n.length)+n;\n};\n\nvar expand = function(buf, len) {\n\tvar tmp = new Buffer(len);\n\tbuf.copy(tmp);\n\treturn tmp;\n};\n\nmodule.exports = function(db, opts) {\n\tif (!opts) opts = {};\n\n\tvar blobs = {};\n\n\tvar blockSize = opts.blockSize || 65536;\n\tvar maxBatch = opts.batch || 100;\n\tvar blank = new Buffer(blockSize);\n\n\tdb.put('\\x00', 'ignore', noop); // memdown#12 workaround\n\n\tvar reservations = {};\n\tvar mutateBlock = function(key, offset, block, append, cb) {\n\t\tvar release = function() {\n\t\t\tif (!--reservations[key].locks) delete reservations[key];\n\t\t};\n\n\t\tvar onreservation = function(r) {\n\t\t\tr.locks++;\n\n\t\t\tif (!r.block && !offset) {\n\t\t\t\tr.block = block;\n\t\t\t\tcb(null, r.block, release);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!r.block) r.block = new Buffer(blockSize);\n\t\t\tif (r.block.length < offset + block.length) r.block = expand(r.block, offset + block.length);\n\n\t\t\tblock.copy(r.block, offset);\n\n\t\t\tif (!append && offset + block.length < r.block.length) r.block = r.block.slice(0, offset+block.length);\n\t\t\tcb(null, r.block, release);\n\t\t};\n\n\t\tif (reservations[key]) return onreservation(reservations[key]);\n\n\t\tdb.get(key, {valueEncoding:ENCODER}, function(err, block) {\n\t\t\tif (err && !err.notFound) return cb(err);\n\t\t\tif (!reservations[key]) reservations[key] = {locks:0, block:block};\n\t\t\tonreservation(reservations[key]);\n\t\t});\n\t};\n\n\tvar WriteStream = function(name, opts) {\n\t\tif (!(this instanceof WriteStream)) return new WriteStream(name, opts);\n\t\tif (!opts) opts = {};\n\n\t\tthis.name = name;\n\t\tthis.blocks = [];\n\t\tthis.batch = [];\n\t\tthis.bytesWritten = 0;\n\t\tthis.truncate = !opts.append;\n\t\tthis.append = opts.append;\n\n\t\tthis._shouldInitAppend = this.append && opts.start === undefined;\n\t\tthis._destroyed = false;\n\t\tthis._init(opts.start || 0);\n\n\t\tWritable.call(this);\n\t};\n\n\tutil.inherits(WriteStream, Writable);\n\n\tWriteStream.prototype._init = function(start) {\n\t\tthis.blockIndex = (start / blockSize) | 0;\n\t\tthis.blockOffset = start - this.blockIndex * blockSize;\n\t\tthis.blockLength = this.blockOffset;\n\t};\n\n\tWriteStream.prototype._flush = function(cb) {\n\t\tif (!this.batch.length) return cb();\n\n\t\tvar key = this.batch[this.batch.length-1].key;\n\t\tvar batch = this.batch;\n\t\tthis.batch = [];\n\n\t\tif (!this.truncate) return db.batch(batch, cb);\n\t\tthis.truncate = false;\n\t\tthis._truncate(batch, key, cb);\n\t};\n\n\tWriteStream.prototype._truncate = function(batch, key, cb) {\n\t\tcb = once(cb);\n\n\t\tvar dels = [];\n\t\tvar keys = db.createKeyStream({\n\t\t\tstart: key,\n\t\t\tend: this.name+'\\xff\\xff'\n\t\t});\n\n\t\tkeys.on('error', cb);\n\n\t\tkeys.on('data', function(key) {\n\t\t\tdels.push({type:'del', key:key});\n\t\t});\n\n\t\tkeys.on('end', function() {\n\t\t\tdels.push.apply(dels, batch);\n\t\t\tdb.batch(dels, cb);\n\t\t});\n\t};\n\n\tWriteStream.prototype._writeBlock = function(cb) {\n\t\tvar block = this.blocks.length === 1 ? this.blocks[0] : Buffer.concat(this.blocks, this.blockLength - this.blockOffset);\n\t\tvar index = this.blockIndex;\n\t\tvar offset = this.blockOffset;\n\t\tvar self = this;\n\n\t\tthis.blockOffset = 0;\n\t\tthis.blockLength = 0;\n\t\tthis.blockIndex++;\n\t\tthis.blocks = [];\n\n\t\tvar key = this.name+'\\xff'+pad(index);\n\n\t\tvar append = function(block, force, cb) {\n\t\t\tif (block.length) {\n\t\t\t\tself.batch.push({\n\t\t\t\t\ttype: 'put',\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: block,\n\t\t\t\t\tvalueEncoding: ENCODER\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!force && self.batch.length < maxBatch) return cb();\n\t\t\treturn self._flush(cb);\n\t\t};\n\n\t\tif (!offset && block.length === blockSize) return append(block, false, cb);\n\t\tif (!offset && !this.append) return append(block, false, cb);\n\n\t\t// partial write\n\t\tmutateBlock(key, offset, block, this.append, function(err, block, release) {\n\t\t\tif (err) return cb(err);\n\t\t\tappend(block, true, function(err) {\n\t\t\t\trelease();\n\t\t\t\tcb(err);\n\t\t\t});\n\t\t});\n\t};\n\n\tWriteStream.prototype._initAppend = function(data, enc, cb) {\n\t\tvar self = this;\n\t\tthis._shouldInitAppend = false;\n\t\tblobs.size(this.name, function(err, size) {\n\t\t\tif (err) return cb(err);\n\t\t\tself._init(size);\n\t\t\tself._write(data, enc, cb);\n\t\t});\n\t};\n\n\tWriteStream.prototype._write = function(data, enc, cb) {\n\t\tif (!data.length || this._destroyed) return cb();\n\t\tif (this._shouldInitAppend) return this._initAppend(data, enc, cb);\n\n\t\tvar self = this;\n\t\tvar overflow;\n\t\tvar free = blockSize - this.blockLength;\n\n\t\tvar done = function(err) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (overflow) return self._write(overflow, enc, cb);\n\t\t\tcb();\n\t\t};\n\n\t\tif (data.length > free) {\n\t\t\toverflow = data.slice(free);\n\t\t\tdata = data.slice(0, free);\n\t\t}\n\n\t\tthis.bytesWritten += data.length;\n\t\tthis.blockLength += data.length;\n\t\tthis.blocks.push(data);\n\n\t\tif (data.length < free) return done();\n\t\tthis._writeBlock(done);\n\t};\n\n\tWriteStream.prototype.destroy = function() {\n\t\tif (this._destroyed) return;\n\t\tthis._destroyed = true;\n\t\tprocess.nextTick(this.emit.bind(this, 'close'));\n\t};\n\n\tWriteStream.prototype.end = function(data) {\n\t\tvar self = this;\n\t\tvar args = arguments;\n\n\t\tif (data && typeof data !== 'function') {\n\t\t\tthis.write(data);\n\t\t\tdata = EMPTY;\n\t\t}\n\n\t\tthis.write(EMPTY, function() {\n\t\t\tself._writeBlock(function(err) {\n\t\t\t\tif (err) return self.emit('error', err);\n\t\t\t\tself._flush(function(err) {\n\t\t\t\t\tif (err) return self.emit('error', err);\n\t\t\t\t\tWritable.prototype.end.apply(self, args);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\tvar ReadStream = function(name, opts) {\n\t\tif (!opts) opts = {};\n\n\t\tvar self = this;\n\n\t\tvar start = opts.start || 0;\n\t\tvar blockIndex = (start / blockSize) | 0;\n\t\tvar blockOffset = start - blockIndex * blockSize;\n\t\tvar key = name+'\\xff'+pad(blockIndex);\n\n\t\tthis.name = name;\n\t\tthis._missing = (typeof opts.end === 'number' ? opts.end : Infinity) - start + 1;\n\t\tthis._paused = false;\n\t\tthis._destroyed = false;\n\n\t\tthis._reader = db.createReadStream({\n\t\t\tstart: key,\n\t\t\tend: name+'\\xff\\xff',\n\t\t\tvalueEncoding: ENCODER\n\t\t});\n\n\t\tvar onblock = function(val) {\n\t\t\tkey = name+'\\xff'+pad(++blockIndex);\n\n\t\t\tif (!self._missing) return false;\n\n\t\t\tif (blockOffset) {\n\t\t\t\tval = val.slice(blockOffset);\n\t\t\t\tblockOffset = 0;\n\t\t\t\tif (!val.length) return true;\n\t\t\t}\n\n\t\t\tif (val.length > self._missing) val = val.slice(0, self._missing);\n\n\t\t\tself._missing -= val.length;\n\t\t\tself._pause(!self.push(val));\n\n\t\t\treturn !!self._missing;\n\t\t};\n\n\t\tthis._reader.on('data', function(data) {\n\t\t\twhile (data.key > key) {\n\t\t\t\tif (!onblock(blank)) return;\n\t\t\t}\n\n\t\t\tonblock(data.value);\n\t\t});\n\n\t\tthis._reader.on('error', function(err) {\n\t\t\tself.emit('error', err);\n\t\t});\n\n\t\tthis._reader.on('end', function() {\n\t\t\tself.push(null);\n\t\t});\n\n\t\tReadable.call(this);\n\t};\n\n\tutil.inherits(ReadStream, Readable);\n\n\tReadStream.prototype.destroy = function() {\n\t\tif (this._destroyed) return;\n\t\tthis._destroyed = true;\n\t\tthis._reader.destroy();\n\t\tprocess.nextTick(this.emit.bind(this, 'close'));\n\t};\n\n\tReadStream.prototype._pause = function(paused) {\n\t\tif (this._paused === paused) return;\n\t\tthis._paused = paused;\n\t\tif (this._paused) this._reader.pause();\n\t\telse this._reader.resume();\n\t};\n\n\tReadStream.prototype._read = function() {\n\t\tthis._pause(false);\n\t};\n\n\tblobs.remove = function(name, cb) {\n\t\tcb = once(cb || noop);\n\n\t\tvar batch = [];\n\t\tvar keys = db.createKeyStream({\n\t\t\tstart: name+'\\xff',\n\t\t\tend: name+'\\xff\\xff'\n\t\t});\n\n\t\tkeys.on('error', cb);\n\n\t\tkeys.on('data', function(key) {\n\t\t\tbatch.push({type:'del', key:key});\n\t\t});\n\n\t\tkeys.on('end', function() {\n\t\t\tdb.batch(batch, cb);\n\t\t});\n\t};\n\n\tblobs.size = function(name, cb) {\n\t\tpeek.last(db, {\n\t\t\tstart: name+'\\xff',\n\t\t\tend: name+'\\xff\\xff',\n\t\t\tvalueEncoding:ENCODER\n\t\t}, function(err, latest, val) {\n\t\t\tif (err && err.message === 'range not found') return cb(null, 0);\n\t\t\tif (err) return cb(err);\n\t\t\tif (latest.slice(0, name.length+1) !== name+'\\xff') return cb(null, 0);\n\n\t\t\tcb(null, parseInt(latest.toString().slice(name.length+1), 16) * blockSize + val.length);\n\t\t});\n\t};\n\n\tblobs.write = function(name, data, opts, cb) {\n\t\tif (typeof opts === 'function') return blobs.write(name, data, null, opts);\n\t\tif (!opts) opts = {};\n\t\tif (!cb) cb = noop;\n\n\t\tvar ws = blobs.createWriteStream(name, opts);\n\n\t\tws.on('error', cb);\n\t\tws.on('finish', function() {\n\t\t\tcb();\n\t\t});\n\n\t\tws.write(data);\n\t\tws.end();\n\t}\n\n\tblobs.read = function(name, opts, cb) {\n\t\tif (typeof opts === 'function') return blobs.read(name, null, opts);\n\t\tif (!opts) opts = {};\n\n\t\tvar rs = blobs.createReadStream(name, opts);\n\t\tvar list = [];\n\n\t\trs.on('error', cb);\n\t\trs.on('data', function(data) {\n\t\t\tlist.push(data);\n\t\t});\n\t\trs.on('end', function() {\n\t\t\tcb(null, list.length === 1 ? list[0] : Buffer.concat(list));\n\t\t});\n\t};\n\n\tblobs.createReadStream = function(name, opts) {\n\t\treturn new ReadStream(name, opts);\n\t};\n\n\tblobs.createWriteStream = function(name, opts) {\n\t\treturn new WriteStream(name, opts);\n\t};\n\n\treturn blobs;\n};\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":119,\"buffer\":111,\"level-peek\":46,\"once\":62,\"readable-stream/readable\":44,\"readable-stream/writable\":45,\"util\":134}],35:[function(require,module,exports){\narguments[4][8][0].apply(exports,arguments)\n},{\"./_stream_readable\":37,\"./_stream_writable\":39,\"_process\":119,\"core-util-is\":40,\"dup\":8,\"inherits\":41}],36:[function(require,module,exports){\narguments[4][9][0].apply(exports,arguments)\n},{\"./_stream_transform\":38,\"core-util-is\":40,\"dup\":9,\"inherits\":41}],37:[function(require,module,exports){\narguments[4][25][0].apply(exports,arguments)\n},{\"_process\":119,\"buffer\":111,\"core-util-is\":40,\"dup\":25,\"events\":115,\"inherits\":41,\"isarray\":42,\"stream\":131,\"string_decoder/\":43}],38:[function(require,module,exports){\narguments[4][26][0].apply(exports,arguments)\n},{\"./_stream_duplex\":35,\"core-util-is\":40,\"dup\":26,\"inherits\":41}],39:[function(require,module,exports){\narguments[4][27][0].apply(exports,arguments)\n},{\"./_stream_duplex\":35,\"_process\":119,\"buffer\":111,\"core-util-is\":40,\"dup\":27,\"inherits\":41,\"stream\":131}],40:[function(require,module,exports){\narguments[4][13][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":13}],41:[function(require,module,exports){\narguments[4][7][0].apply(exports,arguments)\n},{\"dup\":7}],42:[function(require,module,exports){\narguments[4][14][0].apply(exports,arguments)\n},{\"dup\":14}],43:[function(require,module,exports){\narguments[4][15][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":15}],44:[function(require,module,exports){\narguments[4][32][0].apply(exports,arguments)\n},{\"./lib/_stream_duplex.js\":35,\"./lib/_stream_passthrough.js\":36,\"./lib/_stream_readable.js\":37,\"./lib/_stream_transform.js\":38,\"./lib/_stream_writable.js\":39,\"dup\":32,\"stream\":131}],45:[function(require,module,exports){\narguments[4][33][0].apply(exports,arguments)\n},{\"./lib/_stream_writable.js\":39,\"dup\":33}],46:[function(require,module,exports){\nvar fixRange = require('level-fix-range')\n//get the first/last record in a range\n\nexports = module.exports = peek\nexports.first    = first\nexports.last     = last\n\nfunction once(emitter, events, listener) {\n  var remove = []\n  events.forEach(function (e) {\n    function onEvent (arg) {\n      if(listener(e, arg) === false) return\n      remove.forEach(function (r) {\n        r()\n      })\n    }\n    emitter.on(e, onEvent)\n    remove.push(function () {\n      emitter.removeListener(e, onEvent)\n    })\n  })\n  return emitter\n}\n\n\nfunction peek (db, opts, cb) {\n  opts.limit = opts.reverse ? 2 : 1\n  var stream = once(db.createReadStream(opts), \n    ['data', 'error', 'end'],\n    function (event, data) {\n      if(opts.reverse && data && opts.start \n        && (data.key.toString() > opts.start))\n        return false\n      if(event == 'error') cb(data)\n      else if(event == 'end') cb(new Error('range not found'), null, null)\n      else cb(null, data.key, data.value)\n    })\n}\n\nfunction first (db, opts, cb) {\n  if (!cb) {\n    cb = opts;\n    opts = {};\n  }\n  opts.reverse = false\n  return peek(db, fixRange(opts), cb)  \n}\n\n//SO, this is pretty horrible,\n//but it's works around an issue here\n//https://github.com/rvagg/node-levelup/issues/110\n\nfunction last (db, opts, cb) {\n  if (!cb) {\n    cb = opts;\n    opts = {};\n  }\n  var start = opts.start\n  opts.reverse = true\n  return peek(db, fixRange(opts), function (err, key, value) {\n    if(err) {\n      var _start = opts.start\n      opts.start = null\n      peek (db, opts, function (_, key, value) {\n        if(!key) return cb(err, null, null)\n        var _key = key.toString()\n        if(_key <= _start && (!opts.end || _key >= opts.end))\n          cb(_, key, value)\n        else cb(err, null, null)\n      })\n    }\n    else cb(err, key, value)\n  })\n}\n\n\n},{\"level-fix-range\":47}],47:[function(require,module,exports){\n\nmodule.exports = \nfunction fixRange(opts) {\n  var reverse = opts.reverse\n  var end     = opts.end\n  var start   = opts.start\n\n  var range = [start, end]\n  if(start != null && end != null)\n    range.sort()\n  if(reverse)\n    range = range.reverse()\n\n  opts.start   = range[0]\n  opts.end     = range[1]\n  return opts\n}\n\n\n},{}],48:[function(require,module,exports){\nfunction addOperation (type, key, value, options) {\n  var operation = {\n    type: type,\n    key: key,\n    value: value,\n    options: options\n  }\n\n  if (options && options.prefix) {\n    operation.prefix = options.prefix\n    delete options.prefix\n  }\n\n  this._operations.push(operation)\n\n  return this\n}\n\nfunction Batch(sdb) {\n  this._operations = []\n  this._sdb = sdb\n\n  this.put = addOperation.bind(this, 'put')\n  this.del = addOperation.bind(this, 'del')\n}\n\nvar B = Batch.prototype\n\n\nB.clear = function () {\n  this._operations = []\n}\n\nB.write = function (cb) {\n  this._sdb.batch(this._operations, cb)\n}\n\nmodule.exports = Batch\n\n},{}],49:[function(require,module,exports){\n(function (process){\nvar EventEmitter = require('events').EventEmitter\nvar next         = process.nextTick\nvar SubDb        = require('./sub')\nvar Batch        = require('./batch')\nvar fixRange     = require('level-fix-range')\n\nvar Hooks   = require('level-hooks')\n\nmodule.exports   = function (_db, options) {\n  function DB () {}\n  DB.prototype = _db\n  var db = new DB()\n\n  if (db.sublevel) return db\n\n  options = options || {}\n\n  //use \\xff (255) as the seperator,\n  //so that sections of the database will sort after the regular keys\n  var sep = options.sep = options.sep || '\\xff'\n  db._options = options\n\n  Hooks(db)\n\n  db.sublevels = {}\n\n  db.sublevel = function (prefix, options) {\n    if(db.sublevels[prefix])\n      return db.sublevels[prefix]\n    return new SubDb(db, prefix, options || this._options)\n  }\n\n  db.methods = {}\n\n  db.prefix = function (key) {\n    return '' + (key || '')\n  }\n\n  db.pre = function (range, hook) {\n    if(!hook)\n      hook = range, range = {\n        max  : sep\n      }\n    return db.hooks.pre(range, hook)\n  }\n\n  db.post = function (range, hook) {\n    if(!hook)\n      hook = range, range = {\n        max : sep\n      }\n    return db.hooks.post(range, hook)\n  }\n\n  function safeRange(fun) {\n    return function (opts) {\n      opts = opts || {}\n      opts = fixRange(opts)\n\n      if(opts.reverse) opts.start = opts.start || sep\n      else             opts.end   = opts.end || sep\n\n      return fun.call(db, opts)\n    }\n  }\n\n  db.readStream =\n  db.createReadStream  = safeRange(db.createReadStream)\n  db.keyStream =\n  db.createKeyStream   = safeRange(db.createKeyStream)\n  db.valuesStream =\n  db.createValueStream = safeRange(db.createValueStream)\n\n  var batch = db.batch\n  db.batch = function (changes, opts, cb) {\n    if(!Array.isArray(changes))\n      return new Batch(db)\n    changes.forEach(function (e) {\n      if(e.prefix) {\n        if('function' === typeof e.prefix.prefix)\n          e.key = e.prefix.prefix(e.key)\n        else if('string'  === typeof e.prefix)\n          e.key = e.prefix + e.key\n      }\n    })\n    batch.call(db, changes, opts, cb)\n  }\n  return db\n}\n\n\n}).call(this,require('_process'))\n},{\"./batch\":48,\"./sub\":60,\"_process\":119,\"events\":115,\"level-fix-range\":50,\"level-hooks\":52}],50:[function(require,module,exports){\nvar clone = require('clone')\n\nmodule.exports = \nfunction fixRange(opts) {\n  opts = clone(opts)\n\n  var reverse = opts.reverse\n  var end     = opts.max || opts.end\n  var start   = opts.min || opts.start\n\n  var range = [start, end]\n  if(start != null && end != null)\n    range.sort()\n  if(reverse)\n    range = range.reverse()\n\n  opts.start   = range[0]\n  opts.end     = range[1]\n\n  delete opts.min\n  delete opts.max\n\n  return opts\n}\n\n},{\"clone\":51}],51:[function(require,module,exports){\n(function (Buffer){\n'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\n\n\nif (typeof module === 'object')\n  module.exports = clone;\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n      \n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":111}],52:[function(require,module,exports){\nvar ranges = require('string-range')\n\nmodule.exports = function (db) {\n\n  if(db.hooks) {\n    return     \n  }\n\n  var posthooks = []\n  var prehooks  = []\n\n  function getPrefix (p) {\n    return p && (\n        'string' ===   typeof p        ? p\n      : 'string' ===   typeof p.prefix ? p.prefix\n      : 'function' === typeof p.prefix ? p.prefix()\n      :                                  ''\n      )\n  }\n\n  function getKeyEncoding (db) {\n    if(db && db._getKeyEncoding)\n      return db._getKeyEncoding(db)\n  }\n\n  function getValueEncoding (db) {\n    if(db && db._getValueEncoding)\n      return db._getValueEncoding(db)\n  }\n\n  function remover (array, item) {\n    return function () {\n      var i = array.indexOf(item)\n      if(!~i) return false        \n      array.splice(i, 1)\n      return true\n    }\n  }\n\n  db.hooks = {\n    post: function (prefix, hook) {\n      if(!hook) hook = prefix, prefix = ''\n      var h = {test: ranges.checker(prefix), hook: hook}\n      posthooks.push(h)\n      return remover(posthooks, h)\n    },\n    pre: function (prefix, hook) {\n      if(!hook) hook = prefix, prefix = ''\n      var h = {\n        test: ranges.checker(prefix),\n        hook: hook,\n        safe: false !== prefix.safe\n      }\n      prehooks.push(h)\n      return remover(prehooks, h)\n    },\n    posthooks: posthooks,\n    prehooks: prehooks\n  }\n\n  //POST HOOKS\n\n  function each (e) {\n    if(e && e.type) {\n      posthooks.forEach(function (h) {\n        if(h.test(e.key)) h.hook(e)\n      })\n    }\n  }\n\n  db.on('put', function (key, val) {\n    each({type: 'put', key: key, value: val})\n  })\n  db.on('del', function (key, val) {\n    each({type: 'del', key: key, value: val})\n  })\n  db.on('batch', function onBatch (ary) {\n    ary.forEach(each)\n  })\n\n  //PRE HOOKS\n\n  var put = db.put\n  var del = db.del\n  var batch = db.batch\n\n  function callHooks (isBatch, b, opts, cb) {\n    try {\n    b.forEach(function hook(e, i) {\n      prehooks.forEach(function (h) {\n        if(h.test(String(e.key))) {\n          //optimize this?\n          //maybe faster to not create a new object each time?\n          //have one object and expose scope to it?\n          var context = {\n            add: function (ch, db) {\n              if(typeof ch === 'undefined') {\n                return this\n              }\n              if(ch === false)\n                return delete b[i]\n              var prefix = (\n                getPrefix(ch.prefix) || \n                getPrefix(db) || \n                h.prefix || ''\n              )  \n              //don't leave a circular json object there incase using multilevel.\n              if(prefix) ch.prefix = prefix\n              ch.key = prefix + ch.key\n              if(h.safe && h.test(String(ch.key))) {\n                //this usually means a stack overflow.\n                throw new Error('prehook cannot insert into own range')\n              }\n              var ke = ch.keyEncoding   || getKeyEncoding(ch.prefix)\n              var ve = ch.valueEncoding || getValueEncoding(ch.prefix)\n              if(ke) ch.keyEncoding = ke\n              if(ve) ch.valueEncoding = ve\n\n              b.push(ch)\n              hook(ch, b.length - 1)\n              return this\n            },\n            put: function (ch, db) {\n              if('object' === typeof ch) ch.type = 'put'\n              return this.add(ch, db)\n            },\n            del: function (ch, db) {\n              if('object' === typeof ch) ch.type = 'del'\n              return this.add(ch, db)\n            },\n            veto: function () {\n              return this.add(false)\n            }\n          }\n          h.hook.call(context, e, context.add, b)\n        }\n      })\n    })\n    } catch (err) {\n      return (cb || opts)(err)\n    }\n    b = b.filter(function (e) {\n      return e && e.type //filter out empty items\n    })\n\n    if(b.length == 1 && !isBatch) {\n      var change = b[0]\n      return change.type == 'put' \n        ? put.call(db, change.key, change.value, opts, cb) \n        : del.call(db, change.key, opts, cb)  \n    }\n    return batch.call(db, b, opts, cb)\n  }\n\n  db.put = function (key, value, opts, cb ) {\n    var batch = [{key: key, value: value, type: 'put'}]\n    return callHooks(false, batch, opts, cb)\n  }\n\n  db.del = function (key, opts, cb) {\n    var batch = [{key: key, type: 'del'}]\n    return callHooks(false, batch, opts, cb)\n  }\n\n  db.batch = function (batch, opts, cb) {\n    return callHooks(true, batch, opts, cb)\n  }\n}\n\n},{\"string-range\":53}],53:[function(require,module,exports){\n\n//force to a valid range\nvar range = exports.range = function (obj) {\n  return null == obj ? {} : 'string' === typeof range ? {\n      min: range, max: range + '\\xff'\n    } :  obj\n}\n\n//turn into a sub range.\nvar prefix = exports.prefix = function (range, within, term) {\n  range = exports.range(range)\n  var _range = {}\n  term = term || '\\xff'\n  if(range instanceof RegExp || 'function' == typeof range) {\n    _range.min = within\n    _range.max   = within + term,\n    _range.inner = function (k) {\n      var j = k.substring(within.length)\n      if(range.test)\n        return range.test(j)\n      return range(j)\n    }\n  }\n  else if('object' === typeof range) {\n    _range.min = within + (range.min || range.start || '')\n    _range.max = within + (range.max || range.end   || (term || '~'))\n    _range.reverse = !!range.reverse\n  }\n  return _range\n}\n\n//return a function that checks a range\nvar checker = exports.checker = function (range) {\n  if(!range) range = {}\n\n  if ('string' === typeof range)\n    return function (key) {\n      return key.indexOf(range) == 0\n    }\n  else if(range instanceof RegExp)\n    return function (key) {\n      return range.test(key)\n    }\n  else if('object' === typeof range)\n    return function (key) {\n      var min = range.min || range.start\n      var max = range.max || range.end\n\n      // fixes keys passed as ints from sublevels\n      key = String(key)\n\n      return (\n        !min || key >= min\n      ) && (\n        !max || key <= max\n      ) && (\n        !range.inner || (\n          range.inner.test \n            ? range.inner.test(key)\n            : range.inner(key)\n        )\n      )\n    }\n  else if('function' === typeof range)\n    return range\n}\n//check if a key is within a range.\nvar satifies = exports.satisfies = function (key, range) {\n  return checker(range)(key)\n}\n\n\n\n},{}],54:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === \"object\" ||\n        typeof source === \"function\")\n}\n\n},{}],55:[function(require,module,exports){\nvar Keys = require(\"object-keys\")\nvar hasKeys = require(\"./has-keys\")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{\"./has-keys\":54,\"object-keys\":56}],56:[function(require,module,exports){\nmodule.exports = Object.keys || require('./shim');\n\n\n},{\"./shim\":59}],57:[function(require,module,exports){\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n},{}],58:[function(require,module,exports){\n\n/**!\n * is\n * the definitive JavaScript type testing library\n * \n * @copyright 2013 Enrico Marino\n * @license MIT\n */\n\nvar objProto = Object.prototype;\nvar owns = objProto.hasOwnProperty;\nvar toString = objProto.toString;\nvar isActualNaN = function (value) {\n  return value !== value;\n};\nvar NON_HOST_TYPES = {\n  \"boolean\": 1,\n  \"number\": 1,\n  \"string\": 1,\n  \"undefined\": 1\n};\n\n/**\n * Expose `is`\n */\n\nvar is = module.exports = {};\n\n/**\n * Test general.\n */\n\n/**\n * is.type\n * Test if `value` is a type of `type`.\n *\n * @param {Mixed} value value to test\n * @param {String} type type\n * @return {Boolean} true if `value` is a type of `type`, false otherwise\n * @api public\n */\n\nis.a =\nis.type = function (value, type) {\n  return typeof value === type;\n};\n\n/**\n * is.defined\n * Test if `value` is defined.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if 'value' is defined, false otherwise\n * @api public\n */\n\nis.defined = function (value) {\n  return value !== undefined;\n};\n\n/**\n * is.empty\n * Test if `value` is empty.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is empty, false otherwise\n * @api public\n */\n\nis.empty = function (value) {\n  var type = toString.call(value);\n  var key;\n\n  if ('[object Array]' === type || '[object Arguments]' === type) {\n    return value.length === 0;\n  }\n\n  if ('[object Object]' === type) {\n    for (key in value) if (owns.call(value, key)) return false;\n    return true;\n  }\n\n  if ('[object String]' === type) {\n    return '' === value;\n  }\n\n  return false;\n};\n\n/**\n * is.equal\n * Test if `value` is equal to `other`.\n *\n * @param {Mixed} value value to test\n * @param {Mixed} other value to compare with\n * @return {Boolean} true if `value` is equal to `other`, false otherwise\n */\n\nis.equal = function (value, other) {\n  var type = toString.call(value)\n  var key;\n\n  if (type !== toString.call(other)) {\n    return false;\n  }\n\n  if ('[object Object]' === type) {\n    for (key in value) {\n      if (!is.equal(value[key], other[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if ('[object Array]' === type) {\n    key = value.length;\n    if (key !== other.length) {\n      return false;\n    }\n    while (--key) {\n      if (!is.equal(value[key], other[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if ('[object Function]' === type) {\n    return value.prototype === other.prototype;\n  }\n\n  if ('[object Date]' === type) {\n    return value.getTime() === other.getTime();\n  }\n\n  return value === other;\n};\n\n/**\n * is.hosted\n * Test if `value` is hosted by `host`.\n *\n * @param {Mixed} value to test\n * @param {Mixed} host host to test with\n * @return {Boolean} true if `value` is hosted by `host`, false otherwise\n * @api public\n */\n\nis.hosted = function (value, host) {\n  var type = typeof host[value];\n  return type === 'object' ? !!host[value] : !NON_HOST_TYPES[type];\n};\n\n/**\n * is.instance\n * Test if `value` is an instance of `constructor`.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an instance of `constructor`\n * @api public\n */\n\nis.instance = is['instanceof'] = function (value, constructor) {\n  return value instanceof constructor;\n};\n\n/**\n * is.null\n * Test if `value` is null.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is null, false otherwise\n * @api public\n */\n\nis['null'] = function (value) {\n  return value === null;\n};\n\n/**\n * is.undefined\n * Test if `value` is undefined.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is undefined, false otherwise\n * @api public\n */\n\nis.undefined = function (value) {\n  return value === undefined;\n};\n\n/**\n * Test arguments.\n */\n\n/**\n * is.arguments\n * Test if `value` is an arguments object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */\n\nis.arguments = function (value) {\n  var isStandardArguments = '[object Arguments]' === toString.call(value);\n  var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);\n  return isStandardArguments || isOldArguments;\n};\n\n/**\n * Test array.\n */\n\n/**\n * is.array\n * Test if 'value' is an array.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an array, false otherwise\n * @api public\n */\n\nis.array = function (value) {\n  return '[object Array]' === toString.call(value);\n};\n\n/**\n * is.arguments.empty\n * Test if `value` is an empty arguments object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an empty arguments object, false otherwise\n * @api public\n */\nis.arguments.empty = function (value) {\n  return is.arguments(value) && value.length === 0;\n};\n\n/**\n * is.array.empty\n * Test if `value` is an empty array.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an empty array, false otherwise\n * @api public\n */\nis.array.empty = function (value) {\n  return is.array(value) && value.length === 0;\n};\n\n/**\n * is.arraylike\n * Test if `value` is an arraylike object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */\n\nis.arraylike = function (value) {\n  return !!value && !is.boolean(value)\n    && owns.call(value, 'length')\n    && isFinite(value.length)\n    && is.number(value.length)\n    && value.length >= 0;\n};\n\n/**\n * Test boolean.\n */\n\n/**\n * is.boolean\n * Test if `value` is a boolean.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a boolean, false otherwise\n * @api public\n */\n\nis.boolean = function (value) {\n  return '[object Boolean]' === toString.call(value);\n};\n\n/**\n * is.false\n * Test if `value` is false.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is false, false otherwise\n * @api public\n */\n\nis['false'] = function (value) {\n  return is.boolean(value) && (value === false || value.valueOf() === false);\n};\n\n/**\n * is.true\n * Test if `value` is true.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is true, false otherwise\n * @api public\n */\n\nis['true'] = function (value) {\n  return is.boolean(value) && (value === true || value.valueOf() === true);\n};\n\n/**\n * Test date.\n */\n\n/**\n * is.date\n * Test if `value` is a date.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a date, false otherwise\n * @api public\n */\n\nis.date = function (value) {\n  return '[object Date]' === toString.call(value);\n};\n\n/**\n * Test element.\n */\n\n/**\n * is.element\n * Test if `value` is an html element.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an HTML Element, false otherwise\n * @api public\n */\n\nis.element = function (value) {\n  return value !== undefined\n    && typeof HTMLElement !== 'undefined'\n    && value instanceof HTMLElement\n    && value.nodeType === 1;\n};\n\n/**\n * Test error.\n */\n\n/**\n * is.error\n * Test if `value` is an error object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an error object, false otherwise\n * @api public\n */\n\nis.error = function (value) {\n  return '[object Error]' === toString.call(value);\n};\n\n/**\n * Test function.\n */\n\n/**\n * is.fn / is.function (deprecated)\n * Test if `value` is a function.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a function, false otherwise\n * @api public\n */\n\nis.fn = is['function'] = function (value) {\n  var isAlert = typeof window !== 'undefined' && value === window.alert;\n  return isAlert || '[object Function]' === toString.call(value);\n};\n\n/**\n * Test number.\n */\n\n/**\n * is.number\n * Test if `value` is a number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a number, false otherwise\n * @api public\n */\n\nis.number = function (value) {\n  return '[object Number]' === toString.call(value);\n};\n\n/**\n * is.infinite\n * Test if `value` is positive or negative infinity.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise\n * @api public\n */\nis.infinite = function (value) {\n  return value === Infinity || value === -Infinity;\n};\n\n/**\n * is.decimal\n * Test if `value` is a decimal number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a decimal number, false otherwise\n * @api public\n */\n\nis.decimal = function (value) {\n  return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;\n};\n\n/**\n * is.divisibleBy\n * Test if `value` is divisible by `n`.\n *\n * @param {Number} value value to test\n * @param {Number} n dividend\n * @return {Boolean} true if `value` is divisible by `n`, false otherwise\n * @api public\n */\n\nis.divisibleBy = function (value, n) {\n  var isDividendInfinite = is.infinite(value);\n  var isDivisorInfinite = is.infinite(n);\n  var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;\n  return isDividendInfinite || isDivisorInfinite || (isNonZeroNumber && value % n === 0);\n};\n\n/**\n * is.int\n * Test if `value` is an integer.\n *\n * @param value to test\n * @return {Boolean} true if `value` is an integer, false otherwise\n * @api public\n */\n\nis.int = function (value) {\n  return is.number(value) && !isActualNaN(value) && value % 1 === 0;\n};\n\n/**\n * is.maximum\n * Test if `value` is greater than 'others' values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is greater than `others` values\n * @api public\n */\n\nis.maximum = function (value, others) {\n  if (isActualNaN(value)) {\n    throw new TypeError('NaN is not a valid value');\n  } else if (!is.arraylike(others)) {\n    throw new TypeError('second argument must be array-like');\n  }\n  var len = others.length;\n\n  while (--len >= 0) {\n    if (value < others[len]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * is.minimum\n * Test if `value` is less than `others` values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is less than `others` values\n * @api public\n */\n\nis.minimum = function (value, others) {\n  if (isActualNaN(value)) {\n    throw new TypeError('NaN is not a valid value');\n  } else if (!is.arraylike(others)) {\n    throw new TypeError('second argument must be array-like');\n  }\n  var len = others.length;\n\n  while (--len >= 0) {\n    if (value > others[len]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * is.nan\n * Test if `value` is not a number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is not a number, false otherwise\n * @api public\n */\n\nis.nan = function (value) {\n  return !is.number(value) || value !== value;\n};\n\n/**\n * is.even\n * Test if `value` is an even number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an even number, false otherwise\n * @api public\n */\n\nis.even = function (value) {\n  return is.infinite(value) || (is.number(value) && value === value && value % 2 === 0);\n};\n\n/**\n * is.odd\n * Test if `value` is an odd number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an odd number, false otherwise\n * @api public\n */\n\nis.odd = function (value) {\n  return is.infinite(value) || (is.number(value) && value === value && value % 2 !== 0);\n};\n\n/**\n * is.ge\n * Test if `value` is greater than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */\n\nis.ge = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value >= other;\n};\n\n/**\n * is.gt\n * Test if `value` is greater than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */\n\nis.gt = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value > other;\n};\n\n/**\n * is.le\n * Test if `value` is less than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if 'value' is less than or equal to 'other'\n * @api public\n */\n\nis.le = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value <= other;\n};\n\n/**\n * is.lt\n * Test if `value` is less than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if `value` is less than `other`\n * @api public\n */\n\nis.lt = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value < other;\n};\n\n/**\n * is.within\n * Test if `value` is within `start` and `finish`.\n *\n * @param {Number} value value to test\n * @param {Number} start lower bound\n * @param {Number} finish upper bound\n * @return {Boolean} true if 'value' is is within 'start' and 'finish'\n * @api public\n */\nis.within = function (value, start, finish) {\n  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {\n    throw new TypeError('NaN is not a valid value');\n  } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {\n    throw new TypeError('all arguments must be numbers');\n  }\n  var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);\n  return isAnyInfinite || (value >= start && value <= finish);\n};\n\n/**\n * Test object.\n */\n\n/**\n * is.object\n * Test if `value` is an object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an object, false otherwise\n * @api public\n */\n\nis.object = function (value) {\n  return value && '[object Object]' === toString.call(value);\n};\n\n/**\n * is.hash\n * Test if `value` is a hash - a plain object literal.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a hash, false otherwise\n * @api public\n */\n\nis.hash = function (value) {\n  return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;\n};\n\n/**\n * Test regexp.\n */\n\n/**\n * is.regexp\n * Test if `value` is a regular expression.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a regexp, false otherwise\n * @api public\n */\n\nis.regexp = function (value) {\n  return '[object RegExp]' === toString.call(value);\n};\n\n/**\n * Test string.\n */\n\n/**\n * is.string\n * Test if `value` is a string.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if 'value' is a string, false otherwise\n * @api public\n */\n\nis.string = function (value) {\n  return '[object String]' === toString.call(value);\n};\n\n\n},{}],59:[function(require,module,exports){\n(function () {\n\t\"use strict\";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\tis = require('is'),\n\t\tforEach = require('foreach'),\n\t\thasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),\n\t\tdontEnums = [\n\t\t\t\"toString\",\n\t\t\t\"toLocaleString\",\n\t\t\t\"valueOf\",\n\t\t\t\"hasOwnProperty\",\n\t\t\t\"isPrototypeOf\",\n\t\t\t\"propertyIsEnumerable\",\n\t\t\t\"constructor\"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tif (!is.object(object) && !is.array(object)) {\n\t\t\tthrow new TypeError(\"Object.keys called on a non-object\");\n\t\t}\n\n\t\tvar name, theKeys = [];\n\t\tfor (name in object) {\n\t\t\tif (has.call(object, name)) {\n\t\t\t\ttheKeys.push(name);\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{\"foreach\":57,\"is\":58}],60:[function(require,module,exports){\nvar EventEmitter = require('events').EventEmitter\nvar inherits     = require('util').inherits\nvar ranges       = require('string-range')\nvar fixRange     = require('level-fix-range')\nvar xtend        = require('xtend')\nvar Batch        = require('./batch')\n\ninherits(SubDB, EventEmitter)\n\nfunction SubDB (db, prefix, options) {\n  if('string' === typeof options) {\n    console.error('db.sublevel(name, seperator<string>) is depreciated')\n    console.error('use db.sublevel(name, {sep: separator})) if you must')\n    options = {sep: options}\n  }\n  if(!(this instanceof SubDB)) return new SubDB(db, prefix, options)\n  if(!db)     throw new Error('must provide db')\n  if(!prefix) throw new Error('must provide prefix')\n\n  options = options || {}\n  options.sep = options.sep || '\\xff'\n\n  this._parent = db\n  this._options = options\n  this.options = options\n  this._prefix = prefix\n  this._root = root(this)\n  db.sublevels[prefix] = this\n  this.sublevels = {}\n  this.methods = {}\n  var self = this\n  this.hooks = {\n    pre: function () {\n      return self.pre.apply(self, arguments)\n    },\n    post: function () {\n      return self.post.apply(self, arguments)\n    }\n  }\n}\n\nvar SDB = SubDB.prototype\n\nSDB._key = function (key) {\n  var sep = this._options.sep\n  return sep\n    + this._prefix\n    + sep\n    + key\n}\n\nSDB._getOptsAndCb = function (opts, cb) {\n  if (typeof opts == 'function') {\n    cb = opts\n    opts = {}\n  }\n  return { opts: xtend(opts, this._options), cb: cb }\n}\n\nSDB.sublevel = function (prefix, options) {\n  if(this.sublevels[prefix])\n    return this.sublevels[prefix]\n  return new SubDB(this, prefix, options || this._options)\n}\n\nSDB.put = function (key, value, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb)\n  this._root.put(this.prefix(key), value, res.opts, res.cb)\n}\n\nSDB.get = function (key, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb)\n  this._root.get(this.prefix(key), res.opts, res.cb)\n}\n\nSDB.del = function (key, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb)\n  this._root.del(this.prefix(key), res.opts, res.cb)\n}\n\nSDB.batch = function (changes, opts, cb) {\n  if(!Array.isArray(changes))\n    return new Batch(this)\n  var self = this,\n      res = this._getOptsAndCb(opts, cb)\n  changes.forEach(function (ch) {\n\n    //OH YEAH, WE NEED TO VALIDATE THAT UPDATING THIS KEY/PREFIX IS ALLOWED\n    if('string' === typeof ch.prefix)\n      ch.key = ch.prefix + ch.key\n    else\n      ch.key = (ch.prefix || self).prefix(ch.key)\n\n    if(ch.prefix) ch.prefix = null\n  })\n  this._root.batch(changes, res.opts, res.cb)\n}\n\nSDB._getKeyEncoding = function () {\n  if(this.options.keyEncoding)\n    return this.options.keyEncoding\n  if(this._parent && this._parent._getKeyEncoding)\n    return this._parent._getKeyEncoding()\n}\n\nSDB._getValueEncoding = function () {\n  if(this.options.valueEncoding)\n    return this.options.valueEncoding\n  if(this._parent && this._parent._getValueEncoding)\n    return this._parent._getValueEncoding()\n}\n\nSDB.prefix = function (key) {\n  var sep = this._options.sep\n  return this._parent.prefix() + sep + this._prefix + sep + (key || '')\n}\n\nSDB.keyStream =\nSDB.createKeyStream = function (opts) {\n  opts = opts || {}\n  opts.keys = true\n  opts.values = false\n  return this.createReadStream(opts)\n}\n\nSDB.valueStream =\nSDB.createValueStream = function (opts) {\n  opts = opts || {}\n  opts.keys = false\n  opts.values = true\n  opts.keys = false\n  return this.createReadStream(opts)\n}\n\nfunction selectivelyMerge(_opts, opts) {\n  [ 'valueEncoding'\n  , 'encoding'\n  , 'keyEncoding'\n  , 'reverse'\n  , 'values'\n  , 'keys'\n  , 'limit'\n  , 'fillCache'\n  ]\n  .forEach(function (k) {\n    if (opts.hasOwnProperty(k)) _opts[k] = opts[k]\n  })\n}\n\nSDB.readStream =\nSDB.createReadStream = function (opts) {\n  opts = opts || {}\n  var r = root(this)\n  var p = this.prefix()\n\n  var _opts = ranges.prefix(opts, p)\n  selectivelyMerge(_opts, xtend(opts, this._options))\n\n  var s = r.createReadStream(_opts)\n\n  if(_opts.values === false) {\n    var read = s.read\n    if (read) {\n      s.read = function (size) {\n        var val = read.call(this, size)\n        if (val) val = val.substring(p.length)\n        return val\n      }\n    } else {\n      var emit = s.emit\n      s.emit = function (event, val) {\n        if(event === 'data') {\n          emit.call(this, 'data', val.substring(p.length))\n        } else\n          emit.call(this, event, val)\n      }\n    }\n    return s\n  } else if(_opts.keys === false)\n    return s\n  else {\n    var read = s.read\n    if (read) {\n      s.read = function (size) {\n        var d = read.call(this, size)\n        if (d) d.key = d.key.substring(p.length)\n        return d\n      }\n    } else {\n      s.on('data', function (d) {\n        //mutate the prefix!\n        //this doesn't work for createKeyStream admittedly.\n        d.key = d.key.substring(p.length)\n      })\n    }\n    return s\n  }\n}\n\n\nSDB.writeStream =\nSDB.createWriteStream = function () {\n  var r = root(this)\n  var p = this.prefix()\n  var ws = r.createWriteStream.apply(r, arguments)\n  var write = ws.write\n\n  var encoding = this._options.encoding\n  var valueEncoding = this._options.valueEncoding\n  var keyEncoding = this._options.keyEncoding\n\n  // slight optimization, if no encoding was specified at all,\n  // which will be the case most times, make write not check at all\n  var nocheck = !encoding && !valueEncoding && !keyEncoding\n\n  ws.write = nocheck\n    ? function (data) {\n        data.key = p + data.key\n        return write.call(ws, data)\n      }\n    : function (data) {\n        data.key = p + data.key\n\n        // not merging all options here since this happens on every write and things could get slowed down\n        // at this point we only consider encoding important to propagate\n        if (encoding && typeof data.encoding === 'undefined')\n          data.encoding = encoding\n        if (valueEncoding && typeof data.valueEncoding === 'undefined')\n          data.valueEncoding = valueEncoding\n        if (keyEncoding && typeof data.keyEncoding === 'undefined')\n          data.keyEncoding = keyEncoding\n\n        return write.call(ws, data)\n      }\n  return ws\n}\n\nSDB.approximateSize = function () {\n  var r = root(db)\n  return r.approximateSize.apply(r, arguments)\n}\n\nfunction root(db) {\n  if(!db._parent) return db\n  return root(db._parent)\n}\n\nSDB.pre = function (range, hook) {\n  if(!hook) hook = range, range = null\n  range = ranges.prefix(range, this.prefix(), this._options.sep)\n  var r = root(this._parent)\n  var p = this.prefix()\n  return r.hooks.pre(fixRange(range), function (ch, add, batch) {\n    hook({\n      key: ch.key.substring(p.length),\n      value: ch.value,\n      type: ch.type\n    }, function (ch, _p) {\n      //maybe remove the second add arg now\n      //that op can have prefix?\n      add(ch, ch.prefix ? _p : (_p || p))\n    }, batch)\n  })\n}\n\nSDB.post = function (range, hook) {\n  if(!hook) hook = range, range = null\n  var r = root(this._parent)\n  var p = this.prefix()\n  range = ranges.prefix(range, p, this._options.sep)\n  return r.hooks.post(fixRange(range), function (data) {\n    hook({key: data.key.substring(p.length), value: data.value, type: data.type})\n  })\n}\n\nvar exports = module.exports = SubDB\n\n\n},{\"./batch\":48,\"events\":115,\"level-fix-range\":50,\"string-range\":53,\"util\":134,\"xtend\":55}],61:[function(require,module,exports){\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n},{}],62:[function(require,module,exports){\nvar wrappy = require('wrappy')\nmodule.exports = wrappy(once)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\n},{\"wrappy\":61}],63:[function(require,module,exports){\narguments[4][54][0].apply(exports,arguments)\n},{\"dup\":54}],64:[function(require,module,exports){\nvar hasKeys = require(\"./has-keys\")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{\"./has-keys\":63}],65:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar once = require('once');\nvar concat = require('concat-stream');\nvar stat = require('./stat');\nvar xtend = require('xtend');\nvar errno = require('./errno');\n\nvar ROOT = stat({\n\ttype: 'directory',\n\tmode: 0777,\n\tsize: 4096\n});\n\nvar normalize = function(key) {\n\tkey = key[0] === '/' ? key : '/' + key;\n\tkey = path.normalize(key);\n\tif (key === '/') return key;\n\treturn key[key.length-1] === '/' ? key.slice(0, -1) : key;\n};\n\nvar prefix = function(key) {\n\tvar depth = key.split('/').length.toString(36);\n\treturn '0000000000'.slice(depth.length)+depth+key;\n};\n\nmodule.exports = function(db) {\n\tvar that = {};\n\n\tthat.normalize = normalize;\n\n\tthat.get = function(key, cb) {\n\t\tkey = normalize(key);\n\t\tif (key === '/') return process.nextTick(cb.bind(null, null, ROOT, '/'));\n\t\tdb.get(prefix(key), {valueEncoding:'json'}, function(err, doc) {\n\t\t\tif (err && err.notFound) return cb(errno.ENOENT(key), null, key);\n\t\t\tif (err) return cb(err, null, key);\n\t\t\tcb(null, stat(doc), key);\n\t\t});\n\t};\n\n\tthat.writable = function(key, cb) {\n\t\tkey = normalize(key);\n\t\tif (key === '/') return process.nextTick(cb.bind(null, errno.EPERM(key)));\n\t\tthat.follow(path.dirname(key), function(err, parent) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (!parent.isDirectory()) return cb(errno.ENOTDIR(key));\n\t\t\tcb(null, key);\n\t\t});\n\t};\n\n\tthat.list = function(key, cb) {\n\t\tkey = normalize(key);\n\n\t\tvar start = prefix(key === '/' ? key : key + '/');\n\t\tvar keys = db.createKeyStream({start: start, end: start+'\\xff'});\n\n\t\tcb = once(cb);\n\n\t\tkeys.on('error', cb);\n\t\tkeys.pipe(concat({encoding:'object'}, function(files) {\n\t\t\tfiles = files.map(function(file) {\n\t\t\t\treturn file.split('/').pop();\n\t\t\t});\n\n\t\t\tcb(null, files);\n\t\t}));\n\t};\n\n\tvar resolve = function(dir, cb) {\n\t\tvar root = '/';\n\t\tvar parts = dir.split('/').slice(1);\n\n\t\tvar loop = function() {\n\t\t\tthat.get(path.join(root, parts.shift()), function(err, doc, key) {\n\t\t\t\tif (err) return cb(err, doc, dir);\n\t\t\t\troot = doc.target || key;\n\t\t\t\tif (!parts.length) return cb(null, doc, key);\n\t\t\t\tloop();\n\t\t\t});\n\t\t};\n\n\t\tloop();\n\t};\n\n\tthat.follow = function(key, cb) {\n\t\tresolve(normalize(key), function loop(err, doc, key) {\n\t\t\tif (err) return cb(err, null, key);\n\t\t\tif (doc.target) return that.get(doc.target, loop);\n\t\t\tcb(null, stat(doc), key);\n\t\t});\n\t};\n\n\tthat.update = function(key, opts, cb) {\n\t\tthat.get(key, function(err, doc, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (key === '/') return cb(errno.EPERM(key));\n\t\t\tthat.put(key, xtend(doc, opts), cb);\n\t\t});\n\t};\n\n\tthat.put = function(key, opts, cb) {\n\t\tthat.writable(key, function(err, key) {\n\t\t\tif (err) return cb(err);\n\t\t\tdb.put(prefix(key), stat(opts), {valueEncoding:'json'}, cb);\n\t\t});\n\t};\n\n\tthat.del = function(key, cb) {\n\t\tkey = normalize(key);\n\t\tif (key === '/') return process.nextTick(cb.bind(null, errno.EPERM(key)));\n\t\tdb.del(prefix(key), cb);\n\t};\n\n\treturn that;\n};\n}).call(this,require('_process'))\n},{\"./errno\":4,\"./stat\":66,\"_process\":119,\"concat-stream\":6,\"once\":62,\"path\":118,\"xtend\":64}],66:[function(require,module,exports){\nvar toDate = function(date) {\n\tif (!date) return new Date();\n\tif (typeof date === 'string') return new Date(date);\n\treturn date;\n};\n\nvar Stat = function(opts) {\n\tthis.uid = opts.uid || 0;\n\tthis.gid = opts.gid || 0;\n\tthis.mode = opts.mode || 0;\n\tthis.size = opts.size || 0;\n\tthis.mtime = toDate(opts.mtime);\n\tthis.atime = toDate(opts.atime);\n\tthis.ctime = toDate(opts.ctime);\n\tthis.type = opts.type;\n\tthis.target = opts.target;\n\tthis.link = opts.link;\n\tthis.blob = opts.blob;\n};\n\nStat.prototype.isDirectory = function() {\n\treturn this.type === 'directory';\n};\n\nStat.prototype.isFile = function() {\n\treturn this.type === 'file';\n};\n\nStat.prototype.isBlockDevice = function() {\n\treturn false;\n};\n\nStat.prototype.isCharacterDevice = function() {\n\treturn false;\n};\n\nStat.prototype.isSymbolicLink = function() {\n\treturn this.type === 'symlink';\n};\n\nStat.prototype.isFIFO = function() {\n\treturn false;\n};\n\nStat.prototype.isSocket = function() {\n\treturn false;\n};\n\nmodule.exports = function(opts) {\n\treturn new Stat(opts);\n};\n},{}],67:[function(require,module,exports){\nvar events = require('events');\n\nmodule.exports = function() {\n\tvar listeners = {};\n\tvar that = new events.EventEmitter();\n\n\tthat.watch = function(key, cb) {\n\t\tif (!listeners[key]) {\n\t\t\tlisteners[key] = new events.EventEmitter();\n\t\t\tlisteners[key].setMaxListeners(0);\n\t\t}\n\n\t\tif (cb) listeners[key].on('change', cb);\n\t\treturn listeners[key];\n\t};\n\n\tthat.watcher = function(key, cb) {\n\t\tvar watcher = new events.EventEmitter();\n\t\tvar onchange = function() {\n\t\t\twatcher.emit('change', 'change', key);\n\t\t};\n\n\t\tthat.watch(key, onchange);\n\t\tif (cb) watcher.on('change', cb);\n\t\twatcher.close = function() {\n\t\t\tthat.unwatch(key, onchange);\n\t\t};\n\n\t\treturn watcher;\n\t};\n\n\tthat.unwatch = function(key, cb) {\n\t\tif (!listeners[key]) return;\n\t\tif (cb) listeners[key].removeListener('change', cb);\n\t\telse listeners[key].removeAllListeners('change');\n\t\tif (!listeners[key].listeners('change').length) delete listeners[key];;\n\t};\n\n\tthat.change = function(key) {\n\t\tif (listeners[key]) listeners[key].emit('change');\n\t\tthat.emit('change', key);\n\t};\n\n\tthat.cb = function(key, cb) {\n\t\treturn function(err, val) {\n\t\t\tif (key) that.change(key);\n\t\t\tif (cb) cb(err, val);\n\t\t};\n\t};\n\n\treturn that;\n};\n},{\"events\":115}],68:[function(require,module,exports){\n(function (Buffer){\nmodule.exports = Level\n\nvar IDB = require('idb-wrapper')\nvar AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN\nvar util = require('util')\nvar Iterator = require('./iterator')\nvar isBuffer = require('isbuffer')\nvar xtend = require('xtend')\nvar toBuffer = require('typedarray-to-buffer')\n\nfunction Level(location) {\n  if (!(this instanceof Level)) return new Level(location)\n  if (!location) throw new Error(\"constructor requires at least a location argument\")\n  this.IDBOptions = {}\n  this.location = location\n}\n\nutil.inherits(Level, AbstractLevelDOWN)\n\nLevel.prototype._open = function(options, callback) {\n  var self = this\n    \n  var idbOpts = {\n    storeName: this.location,\n    autoIncrement: false,\n    keyPath: null,\n    onStoreReady: function () {\n      callback && callback(null, self.idb)\n    }, \n    onError: function(err) {\n      callback && callback(err)\n    }\n  }\n  \n  xtend(idbOpts, options)\n  this.IDBOptions = idbOpts\n  this.idb = new IDB(idbOpts)\n}\n\nLevel.prototype._get = function (key, options, callback) {\n  this.idb.get(key, function (value) {\n    if (value === undefined) {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return callback(new Error('NotFound'))\n    }\n    // by default return buffers, unless explicitly told not to\n    var asBuffer = true\n    if (options.asBuffer === false) asBuffer = false\n    if (options.raw) asBuffer = false\n    if (asBuffer) {\n      if (value instanceof Uint8Array) value = toBuffer(value)\n      else value = new Buffer(String(value))\n    }\n    return callback(null, value, key)\n  }, callback)\n}\n\nLevel.prototype._del = function(id, options, callback) {\n  this.idb.remove(id, callback, callback)\n}\n\nLevel.prototype._put = function (key, value, options, callback) {\n  if (value instanceof ArrayBuffer) {\n    value = toBuffer(new Uint8Array(value))\n  }\n  var obj = this.convertEncoding(key, value, options)\n  if (Buffer.isBuffer(obj.value)) {\n    obj.value = new Uint8Array(value.toArrayBuffer())\n  }\n  this.idb.put(obj.key, obj.value, function() { callback() }, callback)\n}\n\nLevel.prototype.convertEncoding = function(key, value, options) {\n  if (options.raw) return {key: key, value: value}\n  if (value) {\n    var stringed = value.toString()\n    if (stringed === 'NaN') value = 'NaN'\n  }\n  var valEnc = options.valueEncoding\n  var obj = {key: key, value: value}\n  if (value && (!valEnc || valEnc !== 'binary')) {\n    if (typeof obj.value !== 'object') {\n      obj.value = stringed\n    }\n  }\n  return obj\n}\n\nLevel.prototype.iterator = function (options) {\n  if (typeof options !== 'object') options = {}\n  return new Iterator(this.idb, options)\n}\n\nLevel.prototype._batch = function (array, options, callback) {\n  var op\n  var i\n  var k\n  var copiedOp\n  var currentOp\n  var modified = []\n  \n  if (array.length === 0) return setTimeout(callback, 0)\n  \n  for (i = 0; i < array.length; i++) {\n    copiedOp = {}\n    currentOp = array[i]\n    modified[i] = copiedOp\n    \n    var converted = this.convertEncoding(currentOp.key, currentOp.value, options)\n    currentOp.key = converted.key\n    currentOp.value = converted.value\n\n    for (k in currentOp) {\n      if (k === 'type' && currentOp[k] == 'del') {\n        copiedOp[k] = 'remove'\n      } else {\n        copiedOp[k] = currentOp[k]\n      }\n    }\n  }\n\n  return this.idb.batch(modified, function(){ callback() }, callback)\n}\n\nLevel.prototype._close = function (callback) {\n  this.idb.db.close()\n  callback()\n}\n\nLevel.prototype._approximateSize = function (start, end, callback) {\n  var err = new Error('Not implemented')\n  if (callback)\n    return callback(err)\n\n  throw err\n}\n\nLevel.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nLevel.destroy = function (db, callback) {\n  if (typeof db === 'object') {\n    var prefix = db.IDBOptions.storePrefix || 'IDBWrapper-'\n    var dbname = db.location\n  } else {\n    var prefix = 'IDBWrapper-'\n    var dbname = db\n  }\n  var request = indexedDB.deleteDatabase(prefix + dbname)\n  request.onsuccess = function() {\n    callback()\n  }\n  request.onerror = function(err) {\n    callback(err)\n  }\n}\n\nvar checkKeyValue = Level.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined)\n    return new Error(type + ' cannot be `null` or `undefined`')\n  if (obj === null || obj === undefined)\n    return new Error(type + ' cannot be `null` or `undefined`')\n  if (isBuffer(obj) && obj.byteLength === 0)\n    return new Error(type + ' cannot be an empty ArrayBuffer')\n  if (String(obj) === '')\n    return new Error(type + ' cannot be an empty String')\n  if (obj.length === 0)\n    return new Error(type + ' cannot be an empty Array')\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./iterator\":69,\"abstract-leveldown\":72,\"buffer\":111,\"idb-wrapper\":74,\"isbuffer\":75,\"typedarray-to-buffer\":77,\"util\":134,\"xtend\":79}],69:[function(require,module,exports){\nvar util = require('util')\nvar AbstractIterator  = require('abstract-leveldown').AbstractIterator\nvar ltgt = require('ltgt')\n\nmodule.exports = Iterator\n\nfunction Iterator (db, options) {\n  if (!options) options = {}\n  this.options = options\n  AbstractIterator.call(this, db)\n  this._order = options.reverse ? 'DESC': 'ASC'\n  this._limit = options.limit\n  this._count = 0\n  this._done  = false\n  var lower = ltgt.lowerBound(options)\n  var upper = ltgt.upperBound(options)\n  this._keyRange = lower || upper ? this.db.makeKeyRange({\n    lower: lower,\n    upper: upper,\n    excludeLower: ltgt.lowerBoundExclusive(options),\n    excludeUpper: ltgt.upperBoundExclusive(options)\n  }) : null\n  this.callback = null\n}\n\nutil.inherits(Iterator, AbstractIterator)\n\nIterator.prototype.createIterator = function() {\n  var self = this\n\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments)\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function(err) { console.log('horrible error', err) },\n  })\n}\n\n// TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don't know how\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback()\n    this.callback = false\n    return\n  }\n  var shouldCall = true\n\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit)\n    shouldCall = false\n\n  if (shouldCall) this.callback(false, cursor.key, cursor.value)\n  if (cursor) cursor['continue']()\n}\n\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error('next() requires a callback argument')\n  if (!this._started) {\n    this.createIterator()\n    this._started = true\n  }\n  this.callback = callback\n}\n\n},{\"abstract-leveldown\":72,\"ltgt\":76,\"util\":134}],70:[function(require,module,exports){\n(function (process){\n/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractChainedBatch (db) {\n  this._db         = db\n  this._operations = []\n  this._written    = false\n}\n\nAbstractChainedBatch.prototype._checkWritten = function () {\n  if (this._written)\n    throw new Error('write() already called on this batch')\n}\n\nAbstractChainedBatch.prototype.put = function (key, value) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, 'key', this._db._isBuffer)\n  if (err) throw err\n  err = this._db._checkKeyValue(value, 'value', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n  if (!this._db._isBuffer(value)) value = String(value)\n\n  if (typeof this._put == 'function' )\n    this._put(key, value)\n  else\n    this._operations.push({ type: 'put', key: key, value: value })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.del = function (key) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, 'key', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n\n  if (typeof this._del == 'function' )\n    this._del(key)\n  else\n    this._operations.push({ type: 'del', key: key })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.clear = function () {\n  this._checkWritten()\n\n  this._operations = []\n\n  if (typeof this._clear == 'function' )\n    this._clear()\n\n  return this\n}\n\nAbstractChainedBatch.prototype.write = function (options, callback) {\n  this._checkWritten()\n\n  if (typeof options == 'function')\n    callback = options\n  if (typeof callback != 'function')\n    throw new Error('write() requires a callback argument')\n  if (typeof options != 'object')\n    options = {}\n\n  this._written = true\n\n  if (typeof this._write == 'function' )\n    return this._write(callback)\n\n  if (typeof this._db._batch == 'function')\n    return this._db._batch(this._operations, options, callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractChainedBatch\n}).call(this,require('_process'))\n},{\"_process\":119}],71:[function(require,module,exports){\n(function (process){\n/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractIterator (db) {\n  this.db = db\n  this._ended = false\n  this._nexting = false\n}\n\nAbstractIterator.prototype.next = function (callback) {\n  var self = this\n\n  if (typeof callback != 'function')\n    throw new Error('next() requires a callback argument')\n\n  if (self._ended)\n    return callback(new Error('cannot call next() after end()'))\n  if (self._nexting)\n    return callback(new Error('cannot call next() before previous next() has completed'))\n\n  self._nexting = true\n  if (typeof self._next == 'function') {\n    return self._next(function () {\n      self._nexting = false\n      callback.apply(null, arguments)\n    })\n  }\n\n  process.nextTick(function () {\n    self._nexting = false\n    callback()\n  })\n}\n\nAbstractIterator.prototype.end = function (callback) {\n  if (typeof callback != 'function')\n    throw new Error('end() requires a callback argument')\n\n  if (this._ended)\n    return callback(new Error('end() already called on iterator'))\n\n  this._ended = true\n\n  if (typeof this._end == 'function')\n    return this._end(callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractIterator\n\n}).call(this,require('_process'))\n},{\"_process\":119}],72:[function(require,module,exports){\n(function (process,Buffer){\n/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nvar xtend                = require('xtend')\n  , AbstractIterator     = require('./abstract-iterator')\n  , AbstractChainedBatch = require('./abstract-chained-batch')\n\nfunction AbstractLevelDOWN (location) {\n  if (!arguments.length || location === undefined)\n    throw new Error('constructor requires at least a location argument')\n\n  if (typeof location != 'string')\n    throw new Error('constructor requires a location string argument')\n\n  this.location = location\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  if (typeof options == 'function')\n    callback = options\n\n  if (typeof callback != 'function')\n    throw new Error('open() requires a callback argument')\n\n  if (typeof options != 'object')\n    options = {}\n\n  if (typeof this._open == 'function')\n    return this._open(options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  if (typeof callback != 'function')\n    throw new Error('close() requires a callback argument')\n\n  if (typeof this._close == 'function')\n    return this._close(callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var err\n\n  if (typeof options == 'function')\n    callback = options\n\n  if (typeof callback != 'function')\n    throw new Error('get() requires a callback argument')\n\n  if (err = this._checkKeyValue(key, 'key', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  if (typeof options != 'object')\n    options = {}\n\n  if (typeof this._get == 'function')\n    return this._get(key, options, callback)\n\n  process.nextTick(function () { callback(new Error('NotFound')) })\n}\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  var err\n\n  if (typeof options == 'function')\n    callback = options\n\n  if (typeof callback != 'function')\n    throw new Error('put() requires a callback argument')\n\n  if (err = this._checkKeyValue(key, 'key', this._isBuffer))\n    return callback(err)\n\n  if (err = this._checkKeyValue(value, 'value', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  // coerce value to string in node, don't touch it in browser\n  // (indexeddb can store any JS type)\n  if (!this._isBuffer(value) && !process.browser)\n    value = String(value)\n\n  if (typeof options != 'object')\n    options = {}\n\n  if (typeof this._put == 'function')\n    return this._put(key, value, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  var err\n\n  if (typeof options == 'function')\n    callback = options\n\n  if (typeof callback != 'function')\n    throw new Error('del() requires a callback argument')\n\n  if (err = this._checkKeyValue(key, 'key', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  if (typeof options != 'object')\n    options = {}\n\n  if (typeof this._del == 'function')\n    return this._del(key, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length)\n    return this._chainedBatch()\n\n  if (typeof options == 'function')\n    callback = options\n\n  if (typeof callback != 'function')\n    throw new Error('batch(array) requires a callback argument')\n\n  if (!Array.isArray(array))\n    return callback(new Error('batch(array) requires an array argument'))\n\n  if (typeof options != 'object')\n    options = {}\n\n  var i = 0\n    , l = array.length\n    , e\n    , err\n\n  for (; i < l; i++) {\n    e = array[i]\n    if (typeof e != 'object')\n      continue\n\n    if (err = this._checkKeyValue(e.type, 'type', this._isBuffer))\n      return callback(err)\n\n    if (err = this._checkKeyValue(e.key, 'key', this._isBuffer))\n      return callback(err)\n\n    if (e.type == 'put') {\n      if (err = this._checkKeyValue(e.value, 'value', this._isBuffer))\n        return callback(err)\n    }\n  }\n\n  if (typeof this._batch == 'function')\n    return this._batch(array, options, callback)\n\n  process.nextTick(callback)\n}\n\n//TODO: remove from here, not a necessary primitive\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (   start == null\n      || end == null\n      || typeof start == 'function'\n      || typeof end == 'function') {\n    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')\n  }\n\n  if (typeof callback != 'function')\n    throw new Error('approximateSize() requires a callback argument')\n\n  if (!this._isBuffer(start))\n    start = String(start)\n\n  if (!this._isBuffer(end))\n    end = String(end)\n\n  if (typeof this._approximateSize == 'function')\n    return this._approximateSize(start, end, callback)\n\n  process.nextTick(function () {\n    callback(null, 0)\n  })\n}\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  var self = this\n\n  options = xtend(options)\n\n  ;[ 'start', 'end', 'gt', 'gte', 'lt', 'lte' ].forEach(function (o) {\n    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)\n      delete options[o]\n  })\n\n  options.reverse = !!options.reverse\n\n  // fix `start` so it takes into account gt, gte, lt, lte as appropriate\n  if (options.reverse && options.lt)\n    options.start = options.lt\n  if (options.reverse && options.lte)\n    options.start = options.lte\n  if (!options.reverse && options.gt)\n    options.start = options.gt\n  if (!options.reverse && options.gte)\n    options.start = options.gte\n\n  if ((options.reverse && options.lt && !options.lte)\n    || (!options.reverse && options.gt && !options.gte))\n    options.exclusiveStart = true // start should *not* include matching key\n\n  return options\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != 'object')\n    options = {}\n\n  options = this._setupIteratorOptions(options)\n\n  if (typeof this._iterator == 'function')\n    return this._iterator(options)\n\n  return new AbstractIterator(this)\n}\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this)\n}\n\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nAbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {\n\n  if (obj === null || obj === undefined)\n    return new Error(type + ' cannot be `null` or `undefined`')\n\n  if (this._isBuffer(obj)) {\n    if (obj.length === 0)\n      return new Error(type + ' cannot be an empty Buffer')\n  } else if (String(obj) === '')\n    return new Error(type + ' cannot be an empty String')\n}\n\nmodule.exports.AbstractLevelDOWN    = AbstractLevelDOWN\nmodule.exports.AbstractIterator     = AbstractIterator\nmodule.exports.AbstractChainedBatch = AbstractChainedBatch\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"./abstract-chained-batch\":70,\"./abstract-iterator\":71,\"_process\":119,\"buffer\":111,\"xtend\":73}],73:[function(require,module,exports){\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{}],74:[function(require,module,exports){\n/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Copyright (c) 2011 - 2013 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT (X11) license\n */\n\n(function (name, definition, global) {\n  if (typeof define === 'function') {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {\n    },\n    onError: defaultErrorHandler,\n    indexes: []\n  };\n\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.4.1\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n      // create a store for customers with an additional index over the\n      // `lastname` property.\n      var myCustomerStore = new IDBStore({\n        dbVersion: 1,\n        storeName: 'customer-index',\n        keyPath: 'customerid',\n        autoIncrement: true,\n        onStoreReady: populateTable,\n        indexes: [\n          { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n        ]\n      });\n   * @example\n      // create a generic store\n      var myCustomerStore = new IDBStore({\n        storeName: 'my-data-store',\n        onStoreReady: function(){\n          // start working with the store.\n        }\n      });\n   */\n  var IDBStore = function (kwArgs, onStoreReady) {\n\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n    onStoreReady && (this.onStoreReady = onStoreReady);\n\n    var env = typeof window == 'object' ? window : self;\n    this.idb = env.indexedDB || env.webkitIndexedDB || env.mozIndexedDB;\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n    this.features = {\n      hasAutoIncrement: !env.mozIndexedDB\n    };\n\n    this.consts = {\n      'READ_ONLY':         'readonly',\n      'READ_WRITE':        'readwrite',\n      'VERSION_CHANGE':    'versionchange',\n      'NEXT':              'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV':              'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n\n    this.openDB();\n  };\n\n  IDBStore.prototype = /** @lends IDBStore */ {\n\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @type IDBStore\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type String\n     */\n    version: '1.4.1',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type Object\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type String\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type Number\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type Object\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type String\n     */\n    storeName: null,\n\n    /**\n     * The key path\n     *\n     * @type String\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type Boolean\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type Array\n     */\n    indexes: null,\n\n    /**\n     * A hashmap of features of the used IDB implementation\n     *\n     * @type Object\n     * @proprty {Boolean} autoIncrement If the implementation supports\n     *  native auto increment\n     */\n    features: null,\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type Function\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type Function\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type Number\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (error) {\n\n        var gotVersionErr = false;\n        if ('error' in error.target) {\n          gotVersionErr = error.target.error.name == 'VersionError';\n        } else if ('errorCode' in error.target) {\n          gotVersionErr = error.target.errorCode == 12;\n        }\n\n        if (gotVersionErr) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if(this.db){\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if(typeof this.db.version == 'string'){\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n\n        if(!this.db.objectStoreNames.contains(this.storeName)){\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Something is wrong with the IndexedDB implementation in this browser. Please upgrade your browser.'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName);\n\n        // check indexes\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function(/* IDBVersionChangeEvent */ event){\n\n        this.db = event.target.result;\n\n        if(this.db.objectStoreNames.contains(this.storeName)){\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = { autoIncrement: this.autoIncrement };\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function(_indexName){\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     */\n    deleteDatabase: function () {\n      if (this.idb.deleteDatabase) {\n        this.idb.deleteDatabase(this.dbName);\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n        // Storing an object, using inline keys (the default scenario):\n        var myCustomer = {\n          customerid: 2346223,\n          lastname: 'Doe',\n          firstname: 'John'\n        };\n        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n        // Note that passing success- and error-handlers is optional.\n     * @example\n        // Storing an object, using out-of-line keys:\n       var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n       };\n       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n      // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) { // in-line keys\n        this._addIdPropertyIfNeeded(value);\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else { // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      putRequest.onerror = onError;\n\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n      \n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getRequest.onerror = onError;\n\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      deleteRequest.onerror = onError;\n\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      if(Object.prototype.toString.call(dataArray) != '[object Array]'){\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      \n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n\n      var onItemSuccess = function () {\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n          if (this.keyPath !== null) { // in-line keys\n            this._addIdPropertyIfNeeded(value);\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else { // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function(item){\n        return { type: 'put', value: item };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function(key){\n        return { type: 'remove', key: key };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) {  }, arrayType);\n\n     // this is what the `data` array will be like:\n\n     // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n       [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n\n     // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n       [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n\n     // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n       [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      arrayType || (arrayType = 'sparse');\n\n      if(Object.prototype.toString.call(keyArray) != '[object Array]'){\n        onError(new Error('keyArray argument must be of type Array.'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n        count--;\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var getAllRequest = store.getAll();\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var cursorRequest = store.openCursor();\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        }\n        else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      clearRequest.onerror = onError;\n\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (!this.features.hasAutoIncrement && typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {Object} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        }\n        // Compound keys\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath;\n\n          // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          }\n\n          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n          if ( ! (typeof act.contains == 'function' || typeof act.indexOf == 'function') ) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i<m; i++) {\n            if ( ! ( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler\n      }, options || {});\n\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          onItem(cursor.value, cursor, cursorTransaction);\n          if (options.autoContinue) {\n            cursor['continue']();\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific query options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [];\n      options = options || {};\n      options.onEnd = function () {\n        onSuccess(result);\n      };\n      return this.iterate(function (item) {\n        result.push(item);\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n\n      var onError = options.onError || defaultErrorHandler;\n\n      var hasSuccess = false,\n          result = null;\n\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var countRequest = cursorTarget.count(options.keyRange);\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n      countRequest.onError = onError;\n\n      return cursorTransaction;\n    },\n\n    /**************/\n    /* key ranges */\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {Object} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function(options){\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != 'undefined',\n          hasUpper = typeof options.upper != 'undefined',\n          isOnly = typeof options.only != 'undefined';\n\n      switch(true){\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n\n      return keyRange;\n\n    }\n\n  };\n\n  /** helpers **/\n\n  var noop = function () {\n  };\n  var empty = {};\n  var mixin = function (target, source) {\n    var name, s;\n    for (name in source) {\n      s = source[name];\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n    return target;\n  };\n\n  IDBStore.version = IDBStore.prototype.version;\n\n  return IDBStore;\n\n}, this);\n\n},{}],75:[function(require,module,exports){\nvar Buffer = require('buffer').Buffer;\n\nmodule.exports = isBuffer;\n\nfunction isBuffer (o) {\n  return Buffer.isBuffer(o)\n    || /\\[object (.+Array|Array.+)\\]/.test(Object.prototype.toString.call(o));\n}\n\n},{\"buffer\":111}],76:[function(require,module,exports){\n(function (Buffer){\n\nexports.compare = function (a, b) {\n\n  if(Buffer.isBuffer(a)) {\n    var l = Math.min(a.length, b.length)\n    for(var i = 0; i < l; i++) {\n      var cmp = a[i] - b[i]\n      if(cmp) return cmp\n    }\n    return a.length - b.length\n  }\n\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\nfunction has(obj, key) {\n  return Object.hasOwnProperty.call(obj, key)\n}\n\n// to be compatible with the current abstract-leveldown tests\n// nullish or empty strings.\n// I could use !!val but I want to permit numbers and booleans,\n// if possible.\n\nfunction isDef (val) {\n  return val !== undefined && val !== ''\n}\n\nfunction has (range, name) {\n  return Object.hasOwnProperty.call(range, name)\n}\n\nfunction hasKey(range, name) {\n  return Object.hasOwnProperty.call(range, name) && name\n}\n\nvar lowerBoundKey = exports.lowerBoundKey = function (range) {\n    return (\n       hasKey(range, 'gt')\n    || hasKey(range, 'gte')\n    || hasKey(range, 'min')\n    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))\n    || undefined\n    )\n}\n\nvar lowerBound = exports.lowerBound = function (range) {\n  var k = lowerBoundKey(range)\n  return k && range[k]\n  return (\n      has(range, 'gt')                      ? range.gt\n    : has(range, 'gte')                     ? range.gte\n    : has(range, 'min')                     ? range.min\n    : has(range, 'start') && !range.reverse ? range.start\n    : has(range, 'end')   && range.reverse  ? range.end\n    :                                         undefined\n  )\n}\n\nexports.lowerBoundInclusive = function (range) {\n  return has(range, 'gt') ? false : true\n}\n\nexports.upperBoundInclusive =\n  function (range) {\n    return has(range, 'lt') || !range.minEx ? false : true\n  }\n\nvar lowerBoundExclusive = exports.lowerBoundExclusive =\n  function (range) {\n    return has(range, 'gt') || range.minEx ? true : false\n  }\n\nvar upperBoundExclusive = exports.upperBoundExclusive =\n  function (range) {\n    return has(range, 'lt') ? true : false\n  }\n\nvar upperBoundKey = exports.upperBoundKey = function (range) {\n    return (\n       hasKey(range, 'lt')\n    || hasKey(range, 'lte')\n    || hasKey(range, 'max')\n    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))\n    || undefined\n    )\n}\n\nvar upperBound = exports.upperBound = function (range) {\n  var k = upperBoundKey(range)\n  return k && range[k]\n}\n\nfunction id (e) { return e }\n\nexports.toLtgt = function (range, _range, map, lower, upper) {\n  _range = _range || {}\n  map = map || id\n  var defaults = arguments.length > 3\n  var lb = exports.lowerBoundKey(range)\n  var ub = exports.upperBoundKey(range)\n  if(lb) {\n    if(lb === 'gt') _range.gt = map(range.gt)\n    else            _range.gte = map(range[lb])\n  }\n  else if(defaults)\n    _range.gte = lower\n\n  if(ub) {\n    if(ub === 'lt') _range.lt = map(range.lt)\n    else            _range.lte = map(range[ub])\n  }\n  else if(defaults)\n    _range.lte = upper\n\n  _range.reverse = !!range.reverse\n\n  return _range\n}\n\nexports.contains = function (range, key, compare) {\n  compare = compare || exports.compare\n\n  var lb = lowerBound(range)\n  if(isDef(lb)) {\n    var cmp = compare(key, lb)\n    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))\n      return false\n  }\n\n  var ub = upperBound(range)\n  if(isDef(ub)) {\n    var cmp = compare(key, ub)\n    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))\n      return false\n  }\n\n  return true\n}\n\nexports.filter = function (range, compare) {\n  return function (key) {\n    return exports.contains(range, key, compare)\n  }\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":111}],77:[function(require,module,exports){\n(function (Buffer){\n/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nmodule.exports = function (arr) {\n  if (typeof Buffer._augment === 'function' && Buffer.TYPED_ARRAY_SUPPORT) {\n    // If `Buffer` is from the `buffer` module and this browser supports typed arrays,\n    // then augment it with all the `Buffer` methods.\n    return Buffer._augment(arr)\n  } else {\n    // Otherwise, fallback to creating a `Buffer` with a copy.\n    return new Buffer(arr)\n  }\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":111}],78:[function(require,module,exports){\narguments[4][54][0].apply(exports,arguments)\n},{\"dup\":54}],79:[function(require,module,exports){\narguments[4][55][0].apply(exports,arguments)\n},{\"./has-keys\":78,\"dup\":55,\"object-keys\":81}],80:[function(require,module,exports){\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\tvar isFunc = (typeof fn === 'function' && !(fn instanceof RegExp)) || toString.call(fn) === '[object Function]';\n\tif (!isFunc && typeof window !== 'undefined') {\n\t\tisFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;\n\t}\n\treturn isFunc;\n};\n\nmodule.exports = function forEach(obj, fn) {\n\tif (!isFunction(fn)) {\n\t\tthrow new TypeError('iterator must be a function');\n\t}\n\tvar i, k,\n\t\tisString = typeof obj === 'string',\n\t\tl = obj.length,\n\t\tcontext = arguments.length > 2 ? arguments[2] : null;\n\tif (l === +l) {\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (context === null) {\n\t\t\t\tfn(isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t} else {\n\t\t\t\tfn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (hasOwn.call(obj, k)) {\n\t\t\t\tif (context === null) {\n\t\t\t\t\tfn(obj[k], k, obj);\n\t\t\t\t} else {\n\t\t\t\t\tfn.call(context, obj[k], k, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n},{}],81:[function(require,module,exports){\narguments[4][56][0].apply(exports,arguments)\n},{\"./shim\":83,\"dup\":56}],82:[function(require,module,exports){\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toString.call(value);\n\tvar isArguments = str === '[object Arguments]';\n\tif (!isArguments) {\n\t\tisArguments = str !== '[object Array]'\n\t\t\t&& value !== null\n\t\t\t&& typeof value === 'object'\n\t\t\t&& typeof value.length === 'number'\n\t\t\t&& value.length >= 0\n\t\t\t&& toString.call(value.callee) === '[object Function]';\n\t}\n\treturn isArguments;\n};\n\n\n},{}],83:[function(require,module,exports){\n(function () {\n\t\"use strict\";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\ttoString = Object.prototype.toString,\n\t\tforEach = require('./foreach'),\n\t\tisArgs = require('./isArguments'),\n\t\thasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),\n\t\thasProtoEnumBug = (function () {}).propertyIsEnumerable('prototype'),\n\t\tdontEnums = [\n\t\t\t\"toString\",\n\t\t\t\"toLocaleString\",\n\t\t\t\"valueOf\",\n\t\t\t\"hasOwnProperty\",\n\t\t\t\"isPrototypeOf\",\n\t\t\t\"propertyIsEnumerable\",\n\t\t\t\"constructor\"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object',\n\t\t\tisFunction = toString.call(object) === '[object Function]',\n\t\t\tisArguments = isArgs(object),\n\t\t\ttheKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError(\"Object.keys called on a non-object\");\n\t\t}\n\n\t\tif (isArguments) {\n\t\t\tforEach(object, function (value) {\n\t\t\t\ttheKeys.push(value);\n\t\t\t});\n\t\t} else {\n\t\t\tvar name,\n\t\t\t\tskipProto = hasProtoEnumBug && isFunction;\n\n\t\t\tfor (name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar ctor = object.constructor,\n\t\t\t\tskipConstructor = ctor && ctor.prototype === object;\n\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (!(skipConstructor && dontEnum === 'constructor') && has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{\"./foreach\":80,\"./isArguments\":82}],84:[function(require,module,exports){\n/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n\nvar util          = require('./util')\n  , WriteError    = require('./errors').WriteError\n\n  , getOptions    = util.getOptions\n  , dispatchError = util.dispatchError\n\nfunction Batch (levelup) {\n  this._levelup = levelup\n  this.batch = levelup.db.batch()\n  this.ops = []\n}\n\nBatch.prototype.put = function (key_, value_, options) {\n  options = getOptions(this._levelup, options)\n\n  var key   = util.encodeKey(key_, options)\n    , value = util.encodeValue(value_, options)\n\n  try {\n    this.batch.put(key, value)\n  } catch (e) {\n    throw new WriteError(e)\n  }\n  this.ops.push({ type : 'put', key : key, value : value })\n\n  return this\n}\n\nBatch.prototype.del = function (key_, options) {\n  options = getOptions(this._levelup, options)\n\n  var key = util.encodeKey(key_, options)\n\n  try {\n    this.batch.del(key)\n  } catch (err) {\n    throw new WriteError(err)\n  }\n  this.ops.push({ type : 'del', key : key })\n\n  return this\n}\n\nBatch.prototype.clear = function () {\n  try {\n    this.batch.clear()\n  } catch (err) {\n    throw new WriteError(err)\n  }\n\n  this.ops = []\n  return this\n}\n\nBatch.prototype.write = function (callback) {\n  var levelup = this._levelup\n    , ops     = this.ops\n\n  try {\n    this.batch.write(function (err) {\n      if (err)\n        return dispatchError(levelup, new WriteError(err), callback)\n      levelup.emit('batch', ops)\n      if (callback)\n        callback()\n    })\n  } catch (err) {\n    throw new WriteError(err)\n  }\n}\n\nmodule.exports = Batch\n\n},{\"./errors\":85,\"./util\":88}],85:[function(require,module,exports){\n/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n\nvar createError   = require('errno').create\n  , LevelUPError  = createError('LevelUPError')\n  , NotFoundError = createError('NotFoundError', LevelUPError)\n\nNotFoundError.prototype.notFound = true\nNotFoundError.prototype.status   = 404\n\nmodule.exports = {\n    LevelUPError        : LevelUPError\n  , InitializationError : createError('InitializationError', LevelUPError)\n  , OpenError           : createError('OpenError', LevelUPError)\n  , ReadError           : createError('ReadError', LevelUPError)\n  , WriteError          : createError('WriteError', LevelUPError)\n  , NotFoundError       : NotFoundError\n  , EncodingError       : createError('EncodingError', LevelUPError)\n}\n\n},{\"errno\":96}],86:[function(require,module,exports){\n(function (process){\n/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n\nvar EventEmitter   = require('events').EventEmitter\n  , inherits       = require('util').inherits\n  , extend         = require('xtend')\n  , prr            = require('prr')\n  , DeferredLevelDOWN = require('deferred-leveldown')\n\n  , WriteError     = require('./errors').WriteError\n  , ReadError      = require('./errors').ReadError\n  , NotFoundError  = require('./errors').NotFoundError\n  , OpenError      = require('./errors').OpenError\n  , EncodingError  = require('./errors').EncodingError\n  , InitializationError = require('./errors').InitializationError\n\n  , ReadStream     = require('./read-stream')\n  , WriteStream    = require('./write-stream')\n  , util           = require('./util')\n  , Batch          = require('./batch')\n\n  , getOptions     = util.getOptions\n  , defaultOptions = util.defaultOptions\n  , getLevelDOWN   = util.getLevelDOWN\n  , dispatchError  = util.dispatchError\n\nfunction getCallback (options, callback) {\n  return typeof options == 'function' ? options : callback\n}\n\n// Possible LevelUP#_status values:\n//  - 'new'     - newly created, not opened or closed\n//  - 'opening' - waiting for the database to be opened, post open()\n//  - 'open'    - successfully opened the database, available for use\n//  - 'closing' - waiting for the database to be closed, post close()\n//  - 'closed'  - database has been successfully closed, should not be\n//                 used except for another open() operation\n\nfunction LevelUP (location, options, callback) {\n  if (!(this instanceof LevelUP))\n    return new LevelUP(location, options, callback)\n\n  var error\n\n  EventEmitter.call(this)\n  this.setMaxListeners(Infinity)\n\n  if (typeof location == 'function') {\n    options = typeof options == 'object' ? options : {}\n    options.db = location\n    location = null\n  } else if (typeof location == 'object' && typeof location.db == 'function') {\n    options = location\n    location = null\n  }\n\n  if (typeof options == 'function') {\n    callback = options\n    options  = {}\n  }\n\n  if ((!options || typeof options.db != 'function') && typeof location != 'string') {\n    error = new InitializationError(\n        'Must provide a location for the database')\n    if (callback) {\n      return process.nextTick(function () {\n        callback(error)\n      })\n    }\n    throw error\n  }\n\n  options      = getOptions(this, options)\n  this.options = extend(defaultOptions, options)\n  this._status = 'new'\n  // set this.location as enumerable but not configurable or writable\n  prr(this, 'location', location, 'e')\n\n  this.open(callback)\n}\n\ninherits(LevelUP, EventEmitter)\n\nLevelUP.prototype.open = function (callback) {\n  var self = this\n    , dbFactory\n    , db\n\n  if (this.isOpen()) {\n    if (callback)\n      process.nextTick(function () { callback(null, self) })\n    return this\n  }\n\n  if (this._isOpening()) {\n    return callback && this.once(\n        'open'\n      , function () { callback(null, self) }\n    )\n  }\n\n  this.emit('opening')\n\n  this._status = 'opening'\n  this.db      = new DeferredLevelDOWN(this.location)\n  dbFactory    = this.options.db || getLevelDOWN()\n  db           = dbFactory(this.location)\n\n  db.open(this.options, function (err) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback)\n    } else {\n      self.db.setDb(db)\n      self.db = db\n      self._status = 'open'\n      if (callback)\n        callback(null, self)\n      self.emit('open')\n      self.emit('ready')\n    }\n  })\n}\n\nLevelUP.prototype.close = function (callback) {\n  var self = this\n\n  if (this.isOpen()) {\n    this._status = 'closing'\n    this.db.close(function () {\n      self._status = 'closed'\n      self.emit('closed')\n      if (callback)\n        callback.apply(null, arguments)\n    })\n    this.emit('closing')\n    this.db = null\n  } else if (this._status == 'closed' && callback) {\n    return process.nextTick(callback)\n  } else if (this._status == 'closing' && callback) {\n    this.once('closed', callback)\n  } else if (this._isOpening()) {\n    this.once('open', function () {\n      self.close(callback)\n    })\n  }\n}\n\nLevelUP.prototype.isOpen = function () {\n  return this._status == 'open'\n}\n\nLevelUP.prototype._isOpening = function () {\n  return this._status == 'opening'\n}\n\nLevelUP.prototype.isClosed = function () {\n  return (/^clos/).test(this._status)\n}\n\nLevelUP.prototype.get = function (key_, options, callback) {\n  var self = this\n    , key\n\n  callback = getCallback(options, callback)\n\n  if (typeof callback != 'function') {\n    return dispatchError(\n        this\n      , new ReadError('get() requires key and callback arguments')\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new ReadError('Database is not open')\n      , callback\n    )\n  }\n\n  options = util.getOptions(this, options)\n  key = util.encodeKey(key_, options)\n\n  options.asBuffer = util.isValueAsBuffer(options)\n\n  this.db.get(key, options, function (err, value) {\n    if (err) {\n      if ((/notfound/i).test(err)) {\n        err = new NotFoundError(\n            'Key not found in database [' + key_ + ']', err)\n      } else {\n        err = new ReadError(err)\n      }\n      return dispatchError(self, err, callback)\n    }\n    if (callback) {\n      try {\n        value = util.decodeValue(value, options)\n      } catch (e) {\n        return callback(new EncodingError(e))\n      }\n      callback(null, value)\n    }\n  })\n}\n\nLevelUP.prototype.put = function (key_, value_, options, callback) {\n  var self = this\n    , key\n    , value\n\n  callback = getCallback(options, callback)\n\n  if (key_ === null || key_ === undefined\n        || value_ === null || value_ === undefined) {\n    return dispatchError(\n        this\n       , new WriteError('put() requires key and value arguments')\n       , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError('Database is not open')\n      , callback\n    )\n  }\n\n  options = getOptions(this, options)\n  key     = util.encodeKey(key_, options)\n  value   = util.encodeValue(value_, options)\n\n  this.db.put(key, value, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit('put', key_, value_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\nLevelUP.prototype.del = function (key_, options, callback) {\n  var self = this\n    , key\n\n  callback = getCallback(options, callback)\n\n  if (key_ === null || key_ === undefined) {\n    return dispatchError(\n        this\n      , new WriteError('del() requires a key argument')\n      , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError('Database is not open')\n      , callback\n    )\n  }\n\n  options = getOptions(this, options)\n  key     = util.encodeKey(key_, options)\n\n  this.db.del(key, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit('del', key_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\nLevelUP.prototype.batch = function (arr_, options, callback) {\n  var self = this\n    , keyEnc\n    , valueEnc\n    , arr\n\n  if (!arguments.length)\n    return new Batch(this)\n\n  callback = getCallback(options, callback)\n\n  if (!Array.isArray(arr_)) {\n    return dispatchError(\n        this\n      , new WriteError('batch() requires an array argument')\n      , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError('Database is not open')\n      , callback\n    )\n  }\n\n  options  = getOptions(this, options)\n  keyEnc   = options.keyEncoding\n  valueEnc = options.valueEncoding\n\n  arr = arr_.map(function (e) {\n    if (e.type === undefined || e.key === undefined)\n      return {}\n\n    // inherit encoding\n    var kEnc = e.keyEncoding || keyEnc\n      , vEnc = e.valueEncoding || e.encoding || valueEnc\n      , o\n\n    // If we're not dealing with plain utf8 strings or plain\n    // Buffers then we have to do some work on the array to\n    // encode the keys and/or values. This includes JSON types.\n\n    if (kEnc != 'utf8' && kEnc != 'binary'\n        || vEnc != 'utf8' && vEnc != 'binary') {\n      o = {\n          type: e.type\n        , key: util.encodeKey(e.key, options, e)\n      }\n\n      if (e.value !== undefined)\n        o.value = util.encodeValue(e.value, options, e)\n\n      return o\n    } else {\n      return e\n    }\n  })\n\n  this.db.batch(arr, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit('batch', arr_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\n// DEPRECATED: prefer accessing LevelDOWN for this: db.db.approximateSize()\nLevelUP.prototype.approximateSize = function (start_, end_, callback) {\n  var self = this\n    , start\n    , end\n\n  if (start_ === null || start_ === undefined\n        || end_ === null || end_ === undefined\n        || typeof callback != 'function') {\n    return dispatchError(\n        this\n      , new ReadError('approximateSize() requires start, end and callback arguments')\n      , callback\n    )\n  }\n\n  start = util.encodeKey(start_, this.options)\n  end   = util.encodeKey(end_, this.options)\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError('Database is not open')\n      , callback\n    )\n  }\n\n  this.db.approximateSize(start, end, function (err, size) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback)\n    } else if (callback) {\n      callback(null, size)\n    }\n  })\n}\n\nLevelUP.prototype.readStream =\nLevelUP.prototype.createReadStream = function (options) {\n  var self = this\n  options = extend(this.options, options)\n  return new ReadStream(\n      options\n    , this\n    , function (options) {\n        return self.db.iterator(options)\n      }\n  )\n}\n\nLevelUP.prototype.keyStream =\nLevelUP.prototype.createKeyStream = function (options) {\n  return this.createReadStream(extend(options, { keys: true, values: false }))\n}\n\nLevelUP.prototype.valueStream =\nLevelUP.prototype.createValueStream = function (options) {\n  return this.createReadStream(extend(options, { keys: false, values: true }))\n}\n\nLevelUP.prototype.writeStream =\nLevelUP.prototype.createWriteStream = function (options) {\n  return new WriteStream(extend(options), this)\n}\n\nLevelUP.prototype.toString = function () {\n  return 'LevelUP'\n}\n\nfunction utilStatic (name) {\n  return function (location, callback) {\n    getLevelDOWN()[name](location, callback || function () {})\n  }\n}\n\nmodule.exports         = LevelUP\nmodule.exports.copy    = util.copy\n// DEPRECATED: prefer accessing LevelDOWN for this: require('leveldown').destroy()\nmodule.exports.destroy = utilStatic('destroy')\n// DEPRECATED: prefer accessing LevelDOWN for this: require('leveldown').repair()\nmodule.exports.repair  = utilStatic('repair')\n\n}).call(this,require('_process'))\n},{\"./batch\":84,\"./errors\":85,\"./read-stream\":87,\"./util\":88,\"./write-stream\":89,\"_process\":119,\"deferred-leveldown\":91,\"events\":115,\"prr\":97,\"util\":134,\"xtend\":108}],87:[function(require,module,exports){\n/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n\n// NOTE: we are fixed to readable-stream@1.0.x for now\n// for pure Streams2 across Node versions\nvar Readable      = require('readable-stream').Readable\n  , inherits      = require('util').inherits\n  , extend        = require('xtend')\n  , EncodingError = require('./errors').EncodingError\n  , util          = require('./util')\n\n  , defaultOptions = { keys: true, values: true }\n\n  , makeKeyValueData = function (key, value) {\n      return {\n          key: util.decodeKey(key, this._options)\n        , value: util.decodeValue(value, this._options)\n      }\n    }\n  , makeKeyData = function (key) {\n      return util.decodeKey(key, this._options)\n    }\n  , makeValueData = function (_, value) {\n      return util.decodeValue(value, this._options)\n    }\n  , makeNoData = function () { return null }\n\nfunction ReadStream (options, db, iteratorFactory) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(options, db, iteratorFactory)\n\n  Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark })\n\n  // purely to keep `db` around until we're done so it's not GCed if the user doesn't keep a ref\n  this._db = db\n\n  options = this._options = extend(defaultOptions, options)\n\n  this._keyEncoding   = options.keyEncoding   || options.encoding\n  this._valueEncoding = options.valueEncoding || options.encoding\n\n  if (typeof this._options.start != 'undefined')\n    this._options.start = util.encodeKey(this._options.start, this._options)\n  if (typeof this._options.end != 'undefined')\n    this._options.end = util.encodeKey(this._options.end, this._options)\n  if (typeof this._options.limit != 'number')\n    this._options.limit = -1\n\n  this._options.keyAsBuffer   = util.isKeyAsBuffer(this._options)\n\n  this._options.valueAsBuffer = util.isValueAsBuffer(this._options)\n\n  this._makeData = this._options.keys && this._options.values\n    ? makeKeyValueData : this._options.keys\n      ? makeKeyData : this._options.values\n        ? makeValueData : makeNoData\n\n  var self = this\n  if (!this._db.isOpen()) {\n    this._db.once('ready', function () {\n      if (!self._destroyed) {\n        self._iterator = iteratorFactory(self._options)\n      }\n    })\n  } else\n    this._iterator = iteratorFactory(this._options)\n}\n\ninherits(ReadStream, Readable)\n\nReadStream.prototype._read = function read () {\n  var self = this\n  if (!self._db.isOpen()) {\n    return self._db.once('ready', function () { read.call(self) })\n  }\n  if (self._destroyed)\n    return\n \n  self._iterator.next(function(err, key, value) {\n    if (err || (key === undefined && value === undefined)) {\n      if (!err && !self._destroyed)\n        self.push(null)\n      return self._cleanup(err)\n    }\n\n    try {\n      value = self._makeData(key, value)\n    } catch (e) {\n      return self._cleanup(new EncodingError(e))\n    }\n    if (!self._destroyed)\n      self.push(value)\n  })\n}\n\nReadStream.prototype._cleanup = function (err) {\n  if (this._destroyed)\n    return\n\n  this._destroyed = true\n\n  var self = this\n  if (err)\n    self.emit('error', err)\n\n  if (self._iterator) {\n    self._iterator.end(function () {\n      self._iterator = null\n      self.emit('close')\n    })\n  } else {\n    self.emit('close')\n  }\n}\n\nReadStream.prototype.destroy = function () {\n  this._cleanup()\n}\n\nReadStream.prototype.toString = function () {\n  return 'LevelUP.ReadStream'\n}\n\nmodule.exports = ReadStream\n\n},{\"./errors\":85,\"./util\":88,\"readable-stream\":107,\"util\":134,\"xtend\":108}],88:[function(require,module,exports){\n(function (process,Buffer){\n/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n\nvar extend        = require('xtend')\n  , LevelUPError  = require('./errors').LevelUPError\n\n  , encodingNames = [\n        'hex'\n      , 'utf8'\n      , 'utf-8'\n      , 'ascii'\n      , 'binary'\n      , 'base64'\n      , 'ucs2'\n      , 'ucs-2'\n      , 'utf16le'\n      , 'utf-16le'\n    ]\n\n  , defaultOptions = {\n        createIfMissing : true\n      , errorIfExists   : false\n      , keyEncoding     : 'utf8'\n      , valueEncoding   : 'utf8'\n      , compression     : true\n    }\n\n  , leveldown\n\n  , encodings = (function () {\n      function isBinary (data) {\n        return data === undefined || data === null || Buffer.isBuffer(data)\n      }\n\n      var encodings = {}\n      encodings.utf8 = encodings['utf-8'] = {\n          encode : function (data) {\n            return isBinary(data) ? data : String(data)\n          }\n        , decode : function (data) {\n          return data\n          }\n        , buffer : false\n        , type   : 'utf8'\n      }\n      encodings.json = {\n          encode : JSON.stringify\n        , decode : JSON.parse\n        , buffer : false\n        , type   : 'json'\n      }\n      encodingNames.forEach(function (type) {\n        if (encodings[type])\n          return\n        encodings[type] = {\n            encode : function (data) {\n              return isBinary(data) ? data : new Buffer(data, type)\n            }\n          , decode : function (buffer) {\n              return process.browser ? buffer.toString(type) : buffer;\n            }\n          , buffer : true\n          , type   : type // useful for debugging purposes\n        }\n      })\n      return encodings\n    })()\n\n  , encodingOpts = (function () {\n      var eo = {}\n      encodingNames.forEach(function (e) {\n        eo[e] = { valueEncoding : e }\n      })\n      return eo\n    }())\n\nfunction copy (srcdb, dstdb, callback) {\n  srcdb.readStream()\n    .pipe(dstdb.writeStream())\n    .on('close', callback ? callback : function () {})\n    .on('error', callback ? callback : function (err) { throw err })\n}\n\nfunction getOptions (levelup, options) {\n  var s = typeof options == 'string' // just an encoding\n  if (!s && options && options.encoding && !options.valueEncoding)\n    options.valueEncoding = options.encoding\n  return extend(\n      (levelup && levelup.options) || {}\n    , s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding]\n        : options\n  )\n}\n\nfunction getLevelDOWN () {\n  if (leveldown)\n    return leveldown\n\n  var requiredVersion       = require('../package.json').devDependencies.leveldown\n    , missingLevelDOWNError = 'Could not locate LevelDOWN, try `npm install leveldown`'\n    , leveldownVersion\n\n  try {\n    leveldownVersion = require('leveldown/package').version\n  } catch (e) {\n    throw new LevelUPError(missingLevelDOWNError)\n  }\n\n  if (!require('semver').satisfies(leveldownVersion, requiredVersion)) {\n    throw new LevelUPError(\n        'Installed version of LevelDOWN ('\n      + leveldownVersion\n      + ') does not match required version ('\n      + requiredVersion\n      + ')'\n    )\n  }\n\n  try {\n    return leveldown = require('leveldown')\n  } catch (e) {\n    throw new LevelUPError(missingLevelDOWNError)\n  }\n}\n\nfunction dispatchError (levelup, error, callback) {\n  return typeof callback == 'function'\n    ? callback(error)\n    : levelup.emit('error', error)\n}\n\nfunction getKeyEncoder (options, op) {\n  var type = ((op && op.keyEncoding) || options.keyEncoding) || 'utf8'\n  return encodings[type] || type\n}\n\nfunction getValueEncoder (options, op) {\n  var type = (((op && (op.valueEncoding || op.encoding))\n      || options.valueEncoding || options.encoding)) || 'utf8'\n  return encodings[type] || type\n}\n\nfunction encodeKey (key, options, op) {\n  return getKeyEncoder(options, op).encode(key)\n}\n\nfunction encodeValue (value, options, op) {\n  return getValueEncoder(options, op).encode(value)\n}\n\nfunction decodeKey (key, options) {\n  return getKeyEncoder(options).decode(key)\n}\n\nfunction decodeValue (value, options) {\n  return getValueEncoder(options).decode(value)\n}\n\nfunction isValueAsBuffer (options, op) {\n  return getValueEncoder(options, op).buffer\n}\n\nfunction isKeyAsBuffer (options, op) {\n  return getKeyEncoder(options, op).buffer\n}\n\nmodule.exports = {\n    defaultOptions  : defaultOptions\n  , copy            : copy\n  , getOptions      : getOptions\n  , getLevelDOWN    : getLevelDOWN\n  , dispatchError   : dispatchError\n  , encodeKey       : encodeKey\n  , encodeValue     : encodeValue\n  , isValueAsBuffer : isValueAsBuffer\n  , isKeyAsBuffer   : isKeyAsBuffer\n  , decodeValue     : decodeValue\n  , decodeKey       : decodeKey\n}\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"../package.json\":109,\"./errors\":85,\"_process\":119,\"buffer\":111,\"leveldown\":110,\"leveldown/package\":110,\"semver\":110,\"xtend\":108}],89:[function(require,module,exports){\n(function (process,global){\n/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n\nvar Stream       = require('stream').Stream\n  , inherits     = require('util').inherits\n  , extend       = require('xtend')\n  , bl           = require('bl')\n\n  , setImmediate = global.setImmediate || process.nextTick\n\n  , getOptions   = require('./util').getOptions\n\n  , defaultOptions = { type: 'put' }\n\nfunction WriteStream (options, db) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(options, db)\n\n  Stream.call(this)\n  this._options = extend(defaultOptions, getOptions(db, options))\n  this._db      = db\n  this._buffer  = []\n  this._status  = 'init'\n  this._end     = false\n  this.writable = true\n  this.readable = false\n\n  var self = this\n    , ready = function () {\n        if (!self.writable)\n          return\n        self._status = 'ready'\n        self.emit('ready')\n        self._process()\n      }\n\n  if (db.isOpen())\n    setImmediate(ready)\n  else\n    db.once('ready', ready)\n}\n\ninherits(WriteStream, Stream)\n\nWriteStream.prototype.write = function (data) {\n  if (!this.writable)\n    return false\n  this._buffer.push(data)\n  if (this._status != 'init')\n    this._processDelayed()\n  if (this._options.maxBufferLength &&\n      this._buffer.length > this._options.maxBufferLength) {\n    this._writeBlock = true\n    return false\n  }\n  return true\n}\n\nWriteStream.prototype.end = function (data) {\n  var self = this\n  if (data)\n    this.write(data)\n  setImmediate(function () {\n    self._end = true\n    self._process()\n  })\n}\n\nWriteStream.prototype.destroy = function () {\n  this.writable = false\n  this.end()\n}\n\nWriteStream.prototype.destroySoon = function () {\n  this.end()\n}\n\nWriteStream.prototype.add = function (entry) {\n  if (!entry.props)\n    return\n  if (entry.props.Directory)\n    entry.pipe(this._db.writeStream(this._options))\n  else if (entry.props.File || entry.File || entry.type == 'File')\n    this._write(entry)\n  return true\n}\n\nWriteStream.prototype._processDelayed = function () {\n  var self = this\n  setImmediate(function () {\n    self._process()\n  })\n}\n\nWriteStream.prototype._process = function () {\n  var buffer\n    , self = this\n\n    , cb = function (err) {\n        if (!self.writable)\n          return\n        if (self._status != 'closed')\n          self._status = 'ready'\n        if (err) {\n          self.writable = false\n          return self.emit('error', err)\n        }\n        self._process()\n      }\n\n  if (self._status != 'ready' && self.writable) {\n    if (self._buffer.length && self._status != 'closed')\n      self._processDelayed()\n    return\n  }\n\n  if (self._buffer.length && self.writable) {\n    self._status = 'writing'\n    buffer       = self._buffer\n    self._buffer = []\n\n    self._db.batch(buffer.map(function (d) {\n      return {\n          type          : d.type || self._options.type\n        , key           : d.key\n        , value         : d.value\n        , keyEncoding   : d.keyEncoding || self._options.keyEncoding\n        , valueEncoding : d.valueEncoding\n            || d.encoding\n            || self._options.valueEncoding\n      }\n    }), cb)\n\n    if (self._writeBlock) {\n      self._writeBlock = false\n      self.emit('drain')\n    }\n\n    // don't allow close until callback has returned\n    return\n  }\n\n  if (self._end && self._status != 'closed') {\n    self._status  = 'closed'\n    self.writable = false\n    self.emit('close')\n  }\n}\n\nWriteStream.prototype._write = function (entry) {\n  var key = entry.path || entry.props.path\n    , self = this\n\n  if (!key)\n    return\n\n  entry.pipe(bl(function (err, data) {\n    if (err) {\n      self.writable = false\n      return self.emit('error', err)\n    }\n\n    if (self._options.fstreamRoot &&\n        key.indexOf(self._options.fstreamRoot) > -1)\n      key = key.substr(self._options.fstreamRoot.length + 1)\n\n    self.write({ key: key, value: data.slice(0) })\n  }))\n}\n\nWriteStream.prototype.toString = function () {\n  return 'LevelUP.WriteStream'\n}\n\nmodule.exports = WriteStream\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./util\":88,\"_process\":119,\"bl\":90,\"stream\":131,\"util\":134,\"xtend\":108}],90:[function(require,module,exports){\n(function (Buffer){\nvar DuplexStream = require('readable-stream').Duplex\n  , util         = require('util')\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function (src) {\n      src.removeListener('error', piper)\n    })\n  }\n  else if (Buffer.isBuffer(callback))\n    this.append(callback)\n  else if (Array.isArray(callback)) {\n    callback.forEach(function (b) {\n      Buffer.isBuffer(b) && this.append(b)\n    }.bind(this))\n  }\n\n  DuplexStream.call(this)\n}\n\nutil.inherits(BufferList, DuplexStream)\n\nBufferList.prototype._offset = function (offset) {\n  var tot = 0, i = 0, _t\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\nBufferList.prototype.append = function (buf) {\n  this._bufs.push(Buffer.isBuffer(buf) ? buf : new Buffer(buf))\n  this.length += buf.length\n  return this\n}\n\nBufferList.prototype._write = function (buf, encoding, callback) {\n  this.append(buf)\n  if (callback)\n    callback()\n}\n\nBufferList.prototype._read = function (size) {\n  if (!this.length)\n    return this.push(null)\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\nBufferList.prototype.end = function (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\nBufferList.prototype.get = function (index) {\n  return this.slice(index, index + 1)[0]\n}\n\nBufferList.prototype.slice = function (start, end) {\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || new Buffer(0)\n  if (srcEnd <= 0)\n    return dst || new Buffer(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) // slice, just return a full concat\n      return Buffer.concat(this._bufs)\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = new Buffer(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      break\n    }\n\n    bufoff += l\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  return dst\n}\n\nBufferList.prototype.toString = function (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function (bytes) {\n  while (this._bufs.length) {\n    if (bytes > this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\nBufferList.prototype.duplicate = function () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\nBufferList.prototype.destroy = function () {\n  this._bufs.length = 0;\n  this.length = 0;\n  this.push(null);\n}\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\nmodule.exports = BufferList\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":111,\"readable-stream\":107,\"util\":134}],91:[function(require,module,exports){\n(function (process,Buffer){\nvar util              = require('util')\n  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN\n\nfunction DeferredLevelDOWN (location) {\n  AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '') // optional location, who cares?\n  this._db         = undefined\n  this._operations = []\n}\n\nutil.inherits(DeferredLevelDOWN, AbstractLevelDOWN)\n\n// called by LevelUP when we have a real DB to take its place\nDeferredLevelDOWN.prototype.setDb = function (db) {\n  this._db = db\n  this._operations.forEach(function (op) {\n    db[op.method].apply(db, op.args)\n  })\n}\n\nDeferredLevelDOWN.prototype._open = function (options, callback) {\n  return process.nextTick(callback)\n}\n\n// queue a new deferred operation\nDeferredLevelDOWN.prototype._operation = function (method, args) {\n  if (this._db)\n    return this._db[method].apply(this._db, args)\n  this._operations.push({ method: method, args: args })\n}\n\n// deferrables\n'put get del batch approximateSize'.split(' ').forEach(function (m) {\n  DeferredLevelDOWN.prototype['_' + m] = function () {\n    this._operation(m, arguments)\n  }\n})\n\nDeferredLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\n// don't need to implement this as LevelUP's ReadStream checks for 'ready' state\nDeferredLevelDOWN.prototype._iterator = function () {\n  throw new TypeError('not implemented')\n}\n\nmodule.exports = DeferredLevelDOWN\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":119,\"abstract-leveldown\":94,\"buffer\":111,\"util\":134}],92:[function(require,module,exports){\narguments[4][70][0].apply(exports,arguments)\n},{\"_process\":119,\"dup\":70}],93:[function(require,module,exports){\narguments[4][71][0].apply(exports,arguments)\n},{\"_process\":119,\"dup\":71}],94:[function(require,module,exports){\narguments[4][72][0].apply(exports,arguments)\n},{\"./abstract-chained-batch\":92,\"./abstract-iterator\":93,\"_process\":119,\"buffer\":111,\"dup\":72,\"xtend\":108}],95:[function(require,module,exports){\narguments[4][18][0].apply(exports,arguments)\n},{\"dup\":18,\"prr\":97}],96:[function(require,module,exports){\narguments[4][19][0].apply(exports,arguments)\n},{\"./custom\":95,\"dup\":19}],97:[function(require,module,exports){\narguments[4][20][0].apply(exports,arguments)\n},{\"dup\":20}],98:[function(require,module,exports){\narguments[4][8][0].apply(exports,arguments)\n},{\"./_stream_readable\":100,\"./_stream_writable\":102,\"_process\":119,\"core-util-is\":103,\"dup\":8,\"inherits\":104}],99:[function(require,module,exports){\narguments[4][9][0].apply(exports,arguments)\n},{\"./_stream_transform\":101,\"core-util-is\":103,\"dup\":9,\"inherits\":104}],100:[function(require,module,exports){\narguments[4][25][0].apply(exports,arguments)\n},{\"_process\":119,\"buffer\":111,\"core-util-is\":103,\"dup\":25,\"events\":115,\"inherits\":104,\"isarray\":105,\"stream\":131,\"string_decoder/\":106}],101:[function(require,module,exports){\narguments[4][26][0].apply(exports,arguments)\n},{\"./_stream_duplex\":98,\"core-util-is\":103,\"dup\":26,\"inherits\":104}],102:[function(require,module,exports){\narguments[4][27][0].apply(exports,arguments)\n},{\"./_stream_duplex\":98,\"_process\":119,\"buffer\":111,\"core-util-is\":103,\"dup\":27,\"inherits\":104,\"stream\":131}],103:[function(require,module,exports){\narguments[4][13][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":13}],104:[function(require,module,exports){\narguments[4][7][0].apply(exports,arguments)\n},{\"dup\":7}],105:[function(require,module,exports){\narguments[4][14][0].apply(exports,arguments)\n},{\"dup\":14}],106:[function(require,module,exports){\narguments[4][15][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":15}],107:[function(require,module,exports){\narguments[4][32][0].apply(exports,arguments)\n},{\"./lib/_stream_duplex.js\":98,\"./lib/_stream_passthrough.js\":99,\"./lib/_stream_readable.js\":100,\"./lib/_stream_transform.js\":101,\"./lib/_stream_writable.js\":102,\"dup\":32,\"stream\":131}],108:[function(require,module,exports){\narguments[4][73][0].apply(exports,arguments)\n},{\"dup\":73}],109:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"levelup\",\n  \"description\": \"Fast & simple storage - a Node.js-style LevelDB wrapper\",\n  \"version\": \"0.18.6\",\n  \"contributors\": [\n    {\n      \"name\": \"Rod Vagg\",\n      \"email\": \"r@va.gg\",\n      \"url\": \"https://github.com/rvagg\"\n    },\n    {\n      \"name\": \"John Chesley\",\n      \"email\": \"john@chesl.es\",\n      \"url\": \"https://github.com/chesles/\"\n    },\n    {\n      \"name\": \"Jake Verbaten\",\n      \"email\": \"raynos2@gmail.com\",\n      \"url\": \"https://github.com/raynos\"\n    },\n    {\n      \"name\": \"Dominic Tarr\",\n      \"email\": \"dominic.tarr@gmail.com\",\n      \"url\": \"https://github.com/dominictarr\"\n    },\n    {\n      \"name\": \"Max Ogden\",\n      \"email\": \"max@maxogden.com\",\n      \"url\": \"https://github.com/maxogden\"\n    },\n    {\n      \"name\": \"Lars-Magnus Skog\",\n      \"email\": \"lars.magnus.skog@gmail.com\",\n      \"url\": \"https://github.com/ralphtheninja\"\n    },\n    {\n      \"name\": \"David Bjrklund\",\n      \"email\": \"david.bjorklund@gmail.com\",\n      \"url\": \"https://github.com/kesla\"\n    },\n    {\n      \"name\": \"Julian Gruber\",\n      \"email\": \"julian@juliangruber.com\",\n      \"url\": \"https://github.com/juliangruber\"\n    },\n    {\n      \"name\": \"Paolo Fragomeni\",\n      \"email\": \"paolo@async.ly\",\n      \"url\": \"https://github.com/hij1nx\"\n    },\n    {\n      \"name\": \"Anton Whalley\",\n      \"email\": \"anton.whalley@nearform.com\",\n      \"url\": \"https://github.com/No9\"\n    },\n    {\n      \"name\": \"Matteo Collina\",\n      \"email\": \"matteo.collina@gmail.com\",\n      \"url\": \"https://github.com/mcollina\"\n    },\n    {\n      \"name\": \"Pedro Teixeira\",\n      \"email\": \"pedro.teixeira@gmail.com\",\n      \"url\": \"https://github.com/pgte\"\n    },\n    {\n      \"name\": \"James Halliday\",\n      \"email\": \"mail@substack.net\",\n      \"url\": \"https://github.com/substack\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/rvagg/node-levelup.git\"\n  },\n  \"homepage\": \"https://github.com/rvagg/node-levelup\",\n  \"keywords\": [\n    \"leveldb\",\n    \"stream\",\n    \"database\",\n    \"db\",\n    \"store\",\n    \"storage\",\n    \"json\"\n  ],\n  \"main\": \"lib/levelup.js\",\n  \"dependencies\": {\n    \"bl\": \"~0.8.1\",\n    \"deferred-leveldown\": \"~0.2.0\",\n    \"errno\": \"~0.1.1\",\n    \"prr\": \"~0.0.0\",\n    \"readable-stream\": \"~1.0.26\",\n    \"semver\": \"~2.3.1\",\n    \"xtend\": \"~3.0.0\"\n  },\n  \"devDependencies\": {\n    \"leveldown\": \"~0.10.0\",\n    \"bustermove\": \"*\",\n    \"tap\": \"*\",\n    \"referee\": \"*\",\n    \"rimraf\": \"*\",\n    \"async\": \"*\",\n    \"fstream\": \"*\",\n    \"tar\": \"*\",\n    \"mkfiletree\": \"*\",\n    \"readfiletree\": \"*\",\n    \"slow-stream\": \">=0.0.4\",\n    \"delayed\": \"*\",\n    \"boganipsum\": \"*\",\n    \"du\": \"*\",\n    \"memdown\": \"*\",\n    \"msgpack-js\": \"*\"\n  },\n  \"browser\": {\n    \"leveldown\": false,\n    \"leveldown/package\": false,\n    \"semver\": false\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*-test.js --stderr\",\n    \"functionaltests\": \"node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js\",\n    \"alltests\": \"npm test && npm run-script functionaltests\"\n  },\n  \"license\": \"MIT\",\n  \"gitHead\": \"213e989e2b75273e2b44c23f84f95e35bff7ea11\",\n  \"bugs\": {\n    \"url\": \"https://github.com/rvagg/node-levelup/issues\"\n  },\n  \"_id\": \"levelup@0.18.6\",\n  \"_shasum\": \"e6a01cb089616c8ecc0291c2a9bd3f0c44e3e5eb\",\n  \"_from\": \"levelup@^0.18.2\",\n  \"_npmVersion\": \"1.4.14\",\n  \"_npmUser\": {\n    \"name\": \"rvagg\",\n    \"email\": \"rod@vagg.org\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"rvagg\",\n      \"email\": \"rod@vagg.org\"\n    }\n  ],\n  \"dist\": {\n    \"shasum\": \"e6a01cb089616c8ecc0291c2a9bd3f0c44e3e5eb\",\n    \"tarball\": \"http://registry.npmjs.org/levelup/-/levelup-0.18.6.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/levelup/-/levelup-0.18.6.tgz\"\n}\n\n},{}],110:[function(require,module,exports){\n\n},{}],111:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar kMaxLength = 0x3fffffff\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Note:\n *\n * - Implementation must support adding new properties to `Uint8Array` instances.\n *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *    incorrect length in some situations.\n *\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will\n * get the Object implementation, which is slower but will work correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding) {\n  var self = this\n  if (!(self instanceof Buffer)) return new Buffer(subject, encoding)\n\n  var type = typeof subject\n  var length\n\n  if (type === 'number') {\n    length = +subject\n  } else if (type === 'string') {\n    length = Buffer.byteLength(subject, encoding)\n  } else if (type === 'object' && subject !== null) {\n    // assume object is array-like\n    if (subject.type === 'Buffer' && isArray(subject.data)) subject = subject.data\n    length = +subject.length\n  } else {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (length > kMaxLength) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' +\n      kMaxLength.toString(16) + ' bytes')\n  }\n\n  if (length < 0) length = 0\n  else length >>>= 0 // coerce to uint32\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    self = Buffer._augment(new Uint8Array(length)) // eslint-disable-line consistent-this\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    self.length = length\n    self._isBuffer = true\n  }\n\n  var i\n  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    self._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    if (Buffer.isBuffer(subject)) {\n      for (i = 0; i < length; i++) {\n        self[i] = subject.readUInt8(i)\n      }\n    } else {\n      for (i = 0; i < length; i++) {\n        self[i] = ((subject[i] % 256) + 256) % 256\n      }\n    }\n  } else if (type === 'string') {\n    self.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT) {\n    for (i = 0; i < length; i++) {\n      self[i] = 0\n    }\n  }\n\n  if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent\n\n  return self\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, totalLength) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (totalLength === undefined) {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nBuffer.byteLength = function byteLength (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    case 'hex':\n      ret = str.length >>> 1\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    default:\n      ret = str.length\n  }\n  return ret\n}\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function toString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start >>> 0\n  end = end === undefined || end === Infinity ? this.length : end >>> 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n  return charsWritten\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction utf16leWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n\n  if (length < 0 || offset < 0 || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new TypeError('Unknown encoding: ' + encoding)\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) >>> 0 & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) >>> 0 & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkInt(\n      this, value, offset, byteLength,\n      Math.pow(2, 8 * byteLength - 1) - 1,\n      -Math.pow(2, 8 * byteLength - 1)\n    )\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkInt(\n      this, value, offset, byteLength,\n      Math.pow(2, 8 * byteLength - 1) - 1,\n      -Math.pow(2, 8 * byteLength - 1)\n    )\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, target_start, start, end) {\n  var self = this // source\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (target_start >= target.length) target_start = target.length\n  if (!target_start) target_start = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || self.length === 0) return 0\n\n  // Fatal error conditions\n  if (target_start < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= self.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start\n  }\n\n  var len = end - start\n\n  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < len; i++) {\n      target[i + target_start] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-z\\-]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n  var i = 0\n\n  for (; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (leadSurrogate) {\n        // 2 leads in a row\n        if (codePoint < 0xDC00) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          leadSurrogate = codePoint\n          continue\n        } else {\n          // valid surrogate pair\n          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n          leadSurrogate = null\n        }\n      } else {\n        // no lead yet\n\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else {\n          // valid lead\n          leadSurrogate = codePoint\n          continue\n        }\n      }\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n      leadSurrogate = null\n    }\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x200000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n},{\"base64-js\":112,\"ieee754\":113,\"is-array\":114}],112:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],113:[function(require,module,exports){\nexports.read = function(buffer, offset, isLE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isLE ? (nBytes - 1) : 0,\n      d = isLE ? -1 : 1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isLE ? 0 : (nBytes - 1),\n      d = isLE ? 1 : -1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],114:[function(require,module,exports){\n\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n},{}],115:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],116:[function(require,module,exports){\narguments[4][7][0].apply(exports,arguments)\n},{\"dup\":7}],117:[function(require,module,exports){\narguments[4][14][0].apply(exports,arguments)\n},{\"dup\":14}],118:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":119}],119:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],120:[function(require,module,exports){\narguments[4][22][0].apply(exports,arguments)\n},{\"./lib/_stream_duplex.js\":121,\"dup\":22}],121:[function(require,module,exports){\narguments[4][8][0].apply(exports,arguments)\n},{\"./_stream_readable\":123,\"./_stream_writable\":125,\"_process\":119,\"core-util-is\":126,\"dup\":8,\"inherits\":116}],122:[function(require,module,exports){\narguments[4][9][0].apply(exports,arguments)\n},{\"./_stream_transform\":124,\"core-util-is\":126,\"dup\":9,\"inherits\":116}],123:[function(require,module,exports){\narguments[4][10][0].apply(exports,arguments)\n},{\"./_stream_duplex\":121,\"_process\":119,\"buffer\":111,\"core-util-is\":126,\"dup\":10,\"events\":115,\"inherits\":116,\"isarray\":117,\"stream\":131,\"string_decoder/\":132,\"util\":110}],124:[function(require,module,exports){\narguments[4][11][0].apply(exports,arguments)\n},{\"./_stream_duplex\":121,\"core-util-is\":126,\"dup\":11,\"inherits\":116}],125:[function(require,module,exports){\narguments[4][12][0].apply(exports,arguments)\n},{\"./_stream_duplex\":121,\"_process\":119,\"buffer\":111,\"core-util-is\":126,\"dup\":12,\"inherits\":116,\"stream\":131}],126:[function(require,module,exports){\narguments[4][13][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":13}],127:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":122}],128:[function(require,module,exports){\narguments[4][16][0].apply(exports,arguments)\n},{\"./lib/_stream_duplex.js\":121,\"./lib/_stream_passthrough.js\":122,\"./lib/_stream_readable.js\":123,\"./lib/_stream_transform.js\":124,\"./lib/_stream_writable.js\":125,\"dup\":16,\"stream\":131}],129:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":124}],130:[function(require,module,exports){\narguments[4][33][0].apply(exports,arguments)\n},{\"./lib/_stream_writable.js\":125,\"dup\":33}],131:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":115,\"inherits\":116,\"readable-stream/duplex.js\":120,\"readable-stream/passthrough.js\":127,\"readable-stream/readable.js\":128,\"readable-stream/transform.js\":129,\"readable-stream/writable.js\":130}],132:[function(require,module,exports){\narguments[4][15][0].apply(exports,arguments)\n},{\"buffer\":111,\"dup\":15}],133:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],134:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":133,\"_process\":119,\"inherits\":116}],135:[function(require,module,exports){\n(function (process,global){\n(function(global) {\n  'use strict';\n  if (global.$traceurRuntime) {\n    return;\n  }\n  var $Object = Object;\n  var $TypeError = TypeError;\n  var $create = $Object.create;\n  var $defineProperties = $Object.defineProperties;\n  var $defineProperty = $Object.defineProperty;\n  var $freeze = $Object.freeze;\n  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;\n  var $getOwnPropertyNames = $Object.getOwnPropertyNames;\n  var $keys = $Object.keys;\n  var $hasOwnProperty = $Object.prototype.hasOwnProperty;\n  var $toString = $Object.prototype.toString;\n  var $preventExtensions = Object.preventExtensions;\n  var $seal = Object.seal;\n  var $isExtensible = Object.isExtensible;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var method = nonEnum;\n  var counter = 0;\n  function newUniqueString() {\n    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';\n  }\n  var symbolInternalProperty = newUniqueString();\n  var symbolDescriptionProperty = newUniqueString();\n  var symbolDataProperty = newUniqueString();\n  var symbolValues = $create(null);\n  var privateNames = $create(null);\n  function isPrivateName(s) {\n    return privateNames[s];\n  }\n  function createPrivateName() {\n    var s = newUniqueString();\n    privateNames[s] = true;\n    return s;\n  }\n  function isShimSymbol(symbol) {\n    return typeof symbol === 'object' && symbol instanceof SymbolValue;\n  }\n  function typeOf(v) {\n    if (isShimSymbol(v))\n      return 'symbol';\n    return typeof v;\n  }\n  function Symbol(description) {\n    var value = new SymbolValue(description);\n    if (!(this instanceof Symbol))\n      return value;\n    throw new TypeError('Symbol cannot be new\\'ed');\n  }\n  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));\n  $defineProperty(Symbol.prototype, 'toString', method(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!getOption('symbols'))\n      return symbolValue[symbolInternalProperty];\n    if (!symbolValue)\n      throw TypeError('Conversion from symbol to string');\n    var desc = symbolValue[symbolDescriptionProperty];\n    if (desc === undefined)\n      desc = '';\n    return 'Symbol(' + desc + ')';\n  }));\n  $defineProperty(Symbol.prototype, 'valueOf', method(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!symbolValue)\n      throw TypeError('Conversion from symbol to string');\n    if (!getOption('symbols'))\n      return symbolValue[symbolInternalProperty];\n    return symbolValue;\n  }));\n  function SymbolValue(description) {\n    var key = newUniqueString();\n    $defineProperty(this, symbolDataProperty, {value: this});\n    $defineProperty(this, symbolInternalProperty, {value: key});\n    $defineProperty(this, symbolDescriptionProperty, {value: description});\n    freeze(this);\n    symbolValues[key] = this;\n  }\n  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));\n  $defineProperty(SymbolValue.prototype, 'toString', {\n    value: Symbol.prototype.toString,\n    enumerable: false\n  });\n  $defineProperty(SymbolValue.prototype, 'valueOf', {\n    value: Symbol.prototype.valueOf,\n    enumerable: false\n  });\n  var hashProperty = createPrivateName();\n  var hashPropertyDescriptor = {value: undefined};\n  var hashObjectProperties = {\n    hash: {value: undefined},\n    self: {value: undefined}\n  };\n  var hashCounter = 0;\n  function getOwnHashObject(object) {\n    var hashObject = object[hashProperty];\n    if (hashObject && hashObject.self === object)\n      return hashObject;\n    if ($isExtensible(object)) {\n      hashObjectProperties.hash.value = hashCounter++;\n      hashObjectProperties.self.value = object;\n      hashPropertyDescriptor.value = $create(null, hashObjectProperties);\n      $defineProperty(object, hashProperty, hashPropertyDescriptor);\n      return hashPropertyDescriptor.value;\n    }\n    return undefined;\n  }\n  function freeze(object) {\n    getOwnHashObject(object);\n    return $freeze.apply(this, arguments);\n  }\n  function preventExtensions(object) {\n    getOwnHashObject(object);\n    return $preventExtensions.apply(this, arguments);\n  }\n  function seal(object) {\n    getOwnHashObject(object);\n    return $seal.apply(this, arguments);\n  }\n  freeze(SymbolValue.prototype);\n  function isSymbolString(s) {\n    return symbolValues[s] || privateNames[s];\n  }\n  function toProperty(name) {\n    if (isShimSymbol(name))\n      return name[symbolInternalProperty];\n    return name;\n  }\n  function removeSymbolKeys(array) {\n    var rv = [];\n    for (var i = 0; i < array.length; i++) {\n      if (!isSymbolString(array[i])) {\n        rv.push(array[i]);\n      }\n    }\n    return rv;\n  }\n  function getOwnPropertyNames(object) {\n    return removeSymbolKeys($getOwnPropertyNames(object));\n  }\n  function keys(object) {\n    return removeSymbolKeys($keys(object));\n  }\n  function getOwnPropertySymbols(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var symbol = symbolValues[names[i]];\n      if (symbol) {\n        rv.push(symbol);\n      }\n    }\n    return rv;\n  }\n  function getOwnPropertyDescriptor(object, name) {\n    return $getOwnPropertyDescriptor(object, toProperty(name));\n  }\n  function hasOwnProperty(name) {\n    return $hasOwnProperty.call(this, toProperty(name));\n  }\n  function getOption(name) {\n    return global.traceur && global.traceur.options[name];\n  }\n  function defineProperty(object, name, descriptor) {\n    if (isShimSymbol(name)) {\n      name = name[symbolInternalProperty];\n    }\n    $defineProperty(object, name, descriptor);\n    return object;\n  }\n  function polyfillObject(Object) {\n    $defineProperty(Object, 'defineProperty', {value: defineProperty});\n    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});\n    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});\n    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});\n    $defineProperty(Object, 'freeze', {value: freeze});\n    $defineProperty(Object, 'preventExtensions', {value: preventExtensions});\n    $defineProperty(Object, 'seal', {value: seal});\n    $defineProperty(Object, 'keys', {value: keys});\n  }\n  function exportStar(object) {\n    for (var i = 1; i < arguments.length; i++) {\n      var names = $getOwnPropertyNames(arguments[i]);\n      for (var j = 0; j < names.length; j++) {\n        var name = names[j];\n        if (isSymbolString(name))\n          continue;\n        (function(mod, name) {\n          $defineProperty(object, name, {\n            get: function() {\n              return mod[name];\n            },\n            enumerable: true\n          });\n        })(arguments[i], names[j]);\n      }\n    }\n    return object;\n  }\n  function isObject(x) {\n    return x != null && (typeof x === 'object' || typeof x === 'function');\n  }\n  function toObject(x) {\n    if (x == null)\n      throw $TypeError();\n    return $Object(x);\n  }\n  function checkObjectCoercible(argument) {\n    if (argument == null) {\n      throw new TypeError('Value cannot be converted to an Object');\n    }\n    return argument;\n  }\n  function polyfillSymbol(global, Symbol) {\n    if (!global.Symbol) {\n      global.Symbol = Symbol;\n      Object.getOwnPropertySymbols = getOwnPropertySymbols;\n    }\n    if (!global.Symbol.iterator) {\n      global.Symbol.iterator = Symbol('Symbol.iterator');\n    }\n  }\n  function setupGlobals(global) {\n    polyfillSymbol(global, Symbol);\n    global.Reflect = global.Reflect || {};\n    global.Reflect.global = global.Reflect.global || global;\n    polyfillObject(global.Object);\n  }\n  setupGlobals(global);\n  global.$traceurRuntime = {\n    checkObjectCoercible: checkObjectCoercible,\n    createPrivateName: createPrivateName,\n    defineProperties: $defineProperties,\n    defineProperty: $defineProperty,\n    exportStar: exportStar,\n    getOwnHashObject: getOwnHashObject,\n    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n    getOwnPropertyNames: $getOwnPropertyNames,\n    isObject: isObject,\n    isPrivateName: isPrivateName,\n    isSymbolString: isSymbolString,\n    keys: $keys,\n    setupGlobals: setupGlobals,\n    toObject: toObject,\n    toProperty: toProperty,\n    typeof: typeOf\n  };\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);\n(function() {\n  'use strict';\n  var path;\n  function relativeRequire(callerPath, requiredPath) {\n    path = path || typeof require !== 'undefined' && require('path');\n    function isDirectory(path) {\n      return path.slice(-1) === '/';\n    }\n    function isAbsolute(path) {\n      return path[0] === '/';\n    }\n    function isRelative(path) {\n      return path[0] === '.';\n    }\n    if (isDirectory(requiredPath) || isAbsolute(requiredPath))\n      return;\n    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);\n  }\n  $traceurRuntime.require = relativeRequire;\n})();\n(function() {\n  'use strict';\n  function spread() {\n    var rv = [],\n        j = 0,\n        iterResult;\n    for (var i = 0; i < arguments.length; i++) {\n      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);\n      if (typeof valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)] !== 'function') {\n        throw new TypeError('Cannot spread non-iterable object.');\n      }\n      var iter = valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)]();\n      while (!(iterResult = iter.next()).done) {\n        rv[j++] = iterResult.value;\n      }\n    }\n    return rv;\n  }\n  $traceurRuntime.spread = spread;\n})();\n(function() {\n  'use strict';\n  var $Object = Object;\n  var $TypeError = TypeError;\n  var $create = $Object.create;\n  var $defineProperties = $traceurRuntime.defineProperties;\n  var $defineProperty = $traceurRuntime.defineProperty;\n  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;\n  var $getOwnPropertyNames = $traceurRuntime.getOwnPropertyNames;\n  var $getPrototypeOf = Object.getPrototypeOf;\n  var $__0 = Object,\n      getOwnPropertyNames = $__0.getOwnPropertyNames,\n      getOwnPropertySymbols = $__0.getOwnPropertySymbols;\n  function superDescriptor(homeObject, name) {\n    var proto = $getPrototypeOf(homeObject);\n    do {\n      var result = $getOwnPropertyDescriptor(proto, name);\n      if (result)\n        return result;\n      proto = $getPrototypeOf(proto);\n    } while (proto);\n    return undefined;\n  }\n  function superConstructor(ctor) {\n    return ctor.__proto__;\n  }\n  function superCall(self, homeObject, name, args) {\n    return superGet(self, homeObject, name).apply(self, args);\n  }\n  function superGet(self, homeObject, name) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      if (!descriptor.get)\n        return descriptor.value;\n      return descriptor.get.call(self);\n    }\n    return undefined;\n  }\n  function superSet(self, homeObject, name, value) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(self, value);\n      return value;\n    }\n    throw $TypeError((\"super has no setter '\" + name + \"'.\"));\n  }\n  function getDescriptors(object) {\n    var descriptors = {};\n    var names = getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      descriptors[name] = $getOwnPropertyDescriptor(object, name);\n    }\n    var symbols = getOwnPropertySymbols(object);\n    for (var i = 0; i < symbols.length; i++) {\n      var symbol = symbols[i];\n      descriptors[$traceurRuntime.toProperty(symbol)] = $getOwnPropertyDescriptor(object, $traceurRuntime.toProperty(symbol));\n    }\n    return descriptors;\n  }\n  function createClass(ctor, object, staticObject, superClass) {\n    $defineProperty(object, 'constructor', {\n      value: ctor,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n    if (arguments.length > 3) {\n      if (typeof superClass === 'function')\n        ctor.__proto__ = superClass;\n      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n    } else {\n      ctor.prototype = object;\n    }\n    $defineProperty(ctor, 'prototype', {\n      configurable: false,\n      writable: false\n    });\n    return $defineProperties(ctor, getDescriptors(staticObject));\n  }\n  function getProtoParent(superClass) {\n    if (typeof superClass === 'function') {\n      var prototype = superClass.prototype;\n      if ($Object(prototype) === prototype || prototype === null)\n        return superClass.prototype;\n      throw new $TypeError('super prototype must be an Object or null');\n    }\n    if (superClass === null)\n      return null;\n    throw new $TypeError((\"Super expression must either be null or a function, not \" + typeof superClass + \".\"));\n  }\n  function defaultSuperCall(self, homeObject, args) {\n    if ($getPrototypeOf(homeObject) !== null)\n      superCall(self, homeObject, 'constructor', args);\n  }\n  $traceurRuntime.createClass = createClass;\n  $traceurRuntime.defaultSuperCall = defaultSuperCall;\n  $traceurRuntime.superCall = superCall;\n  $traceurRuntime.superConstructor = superConstructor;\n  $traceurRuntime.superGet = superGet;\n  $traceurRuntime.superSet = superSet;\n})();\n(function() {\n  'use strict';\n  if (typeof $traceurRuntime !== 'object') {\n    throw new Error('traceur runtime not found.');\n  }\n  var createPrivateName = $traceurRuntime.createPrivateName;\n  var $defineProperties = $traceurRuntime.defineProperties;\n  var $defineProperty = $traceurRuntime.defineProperty;\n  var $create = Object.create;\n  var $TypeError = TypeError;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var ST_NEWBORN = 0;\n  var ST_EXECUTING = 1;\n  var ST_SUSPENDED = 2;\n  var ST_CLOSED = 3;\n  var END_STATE = -2;\n  var RETHROW_STATE = -3;\n  function getInternalError(state) {\n    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);\n  }\n  function GeneratorContext() {\n    this.state = 0;\n    this.GState = ST_NEWBORN;\n    this.storedException = undefined;\n    this.finallyFallThrough = undefined;\n    this.sent_ = undefined;\n    this.returnValue = undefined;\n    this.tryStack_ = [];\n  }\n  GeneratorContext.prototype = {\n    pushTry: function(catchState, finallyState) {\n      if (finallyState !== null) {\n        var finallyFallThrough = null;\n        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n          if (this.tryStack_[i].catch !== undefined) {\n            finallyFallThrough = this.tryStack_[i].catch;\n            break;\n          }\n        }\n        if (finallyFallThrough === null)\n          finallyFallThrough = RETHROW_STATE;\n        this.tryStack_.push({\n          finally: finallyState,\n          finallyFallThrough: finallyFallThrough\n        });\n      }\n      if (catchState !== null) {\n        this.tryStack_.push({catch: catchState});\n      }\n    },\n    popTry: function() {\n      this.tryStack_.pop();\n    },\n    get sent() {\n      this.maybeThrow();\n      return this.sent_;\n    },\n    set sent(v) {\n      this.sent_ = v;\n    },\n    get sentIgnoreThrow() {\n      return this.sent_;\n    },\n    maybeThrow: function() {\n      if (this.action === 'throw') {\n        this.action = 'next';\n        throw this.sent_;\n      }\n    },\n    end: function() {\n      switch (this.state) {\n        case END_STATE:\n          return this;\n        case RETHROW_STATE:\n          throw this.storedException;\n        default:\n          throw getInternalError(this.state);\n      }\n    },\n    handleException: function(ex) {\n      this.GState = ST_CLOSED;\n      this.state = END_STATE;\n      throw ex;\n    }\n  };\n  function nextOrThrow(ctx, moveNext, action, x) {\n    switch (ctx.GState) {\n      case ST_EXECUTING:\n        throw new Error((\"\\\"\" + action + \"\\\" on executing generator\"));\n      case ST_CLOSED:\n        if (action == 'next') {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n        throw x;\n      case ST_NEWBORN:\n        if (action === 'throw') {\n          ctx.GState = ST_CLOSED;\n          throw x;\n        }\n        if (x !== undefined)\n          throw $TypeError('Sent value to newborn generator');\n      case ST_SUSPENDED:\n        ctx.GState = ST_EXECUTING;\n        ctx.action = action;\n        ctx.sent = x;\n        var value = moveNext(ctx);\n        var done = value === ctx;\n        if (done)\n          value = ctx.returnValue;\n        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n        return {\n          value: value,\n          done: done\n        };\n    }\n  }\n  var ctxName = createPrivateName();\n  var moveNextName = createPrivateName();\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  $defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));\n  GeneratorFunctionPrototype.prototype = {\n    constructor: GeneratorFunctionPrototype,\n    next: function(v) {\n      return nextOrThrow(this[ctxName], this[moveNextName], 'next', v);\n    },\n    throw: function(v) {\n      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', v);\n    }\n  };\n  $defineProperties(GeneratorFunctionPrototype.prototype, {\n    constructor: {enumerable: false},\n    next: {enumerable: false},\n    throw: {enumerable: false}\n  });\n  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {\n    return this;\n  }));\n  function createGeneratorInstance(innerFunction, functionObject, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new GeneratorContext();\n    var object = $create(functionObject.prototype);\n    object[ctxName] = ctx;\n    object[moveNextName] = moveNext;\n    return object;\n  }\n  function initGeneratorFunction(functionObject) {\n    functionObject.prototype = $create(GeneratorFunctionPrototype.prototype);\n    functionObject.__proto__ = GeneratorFunctionPrototype;\n    return functionObject;\n  }\n  function AsyncFunctionContext() {\n    GeneratorContext.call(this);\n    this.err = undefined;\n    var ctx = this;\n    ctx.result = new Promise(function(resolve, reject) {\n      ctx.resolve = resolve;\n      ctx.reject = reject;\n    });\n  }\n  AsyncFunctionContext.prototype = $create(GeneratorContext.prototype);\n  AsyncFunctionContext.prototype.end = function() {\n    switch (this.state) {\n      case END_STATE:\n        this.resolve(this.returnValue);\n        break;\n      case RETHROW_STATE:\n        this.reject(this.storedException);\n        break;\n      default:\n        this.reject(getInternalError(this.state));\n    }\n  };\n  AsyncFunctionContext.prototype.handleException = function() {\n    this.state = RETHROW_STATE;\n  };\n  function asyncWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new AsyncFunctionContext();\n    ctx.createCallback = function(newState) {\n      return function(value) {\n        ctx.state = newState;\n        ctx.value = value;\n        moveNext(ctx);\n      };\n    };\n    ctx.errback = function(err) {\n      handleCatch(ctx, err);\n      moveNext(ctx);\n    };\n    moveNext(ctx);\n    return ctx.result;\n  }\n  function getMoveNext(innerFunction, self) {\n    return function(ctx) {\n      while (true) {\n        try {\n          return innerFunction.call(self, ctx);\n        } catch (ex) {\n          handleCatch(ctx, ex);\n        }\n      }\n    };\n  }\n  function handleCatch(ctx, ex) {\n    ctx.storedException = ex;\n    var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n    if (!last) {\n      ctx.handleException(ex);\n      return;\n    }\n    ctx.state = last.catch !== undefined ? last.catch : last.finally;\n    if (last.finallyFallThrough !== undefined)\n      ctx.finallyFallThrough = last.finallyFallThrough;\n  }\n  $traceurRuntime.asyncWrap = asyncWrap;\n  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;\n  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;\n})();\n(function() {\n  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme) {\n      out.push(opt_scheme, ':');\n    }\n    if (opt_domain) {\n      out.push('//');\n      if (opt_userInfo) {\n        out.push(opt_userInfo, '@');\n      }\n      out.push(opt_domain);\n      if (opt_port) {\n        out.push(':', opt_port);\n      }\n    }\n    if (opt_path) {\n      out.push(opt_path);\n    }\n    if (opt_queryData) {\n      out.push('?', opt_queryData);\n    }\n    if (opt_fragment) {\n      out.push('#', opt_fragment);\n    }\n    return out.join('');\n  }\n  ;\n  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\\\?([^#]*))?' + '(?:#(.*))?' + '$');\n  var ComponentIndex = {\n    SCHEME: 1,\n    USER_INFO: 2,\n    DOMAIN: 3,\n    PORT: 4,\n    PATH: 5,\n    QUERY_DATA: 6,\n    FRAGMENT: 7\n  };\n  function split(uri) {\n    return (uri.match(splitRe));\n  }\n  function removeDotSegments(path) {\n    if (path === '/')\n      return '/';\n    var leadingSlash = path[0] === '/' ? '/' : '';\n    var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n      var segment = segments[pos];\n      switch (segment) {\n        case '':\n        case '.':\n          break;\n        case '..':\n          if (out.length)\n            out.pop();\n          else\n            up++;\n          break;\n        default:\n          out.push(segment);\n      }\n    }\n    if (!leadingSlash) {\n      while (up-- > 0) {\n        out.unshift('..');\n      }\n      if (out.length === 0)\n        out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n  }\n  function joinAndCanonicalizePath(parts) {\n    var path = parts[ComponentIndex.PATH] || '';\n    path = removeDotSegments(path);\n    parts[ComponentIndex.PATH] = path;\n    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n  }\n  function canonicalizeUrl(url) {\n    var parts = split(url);\n    return joinAndCanonicalizePath(parts);\n  }\n  function resolveUrl(base, url) {\n    var parts = split(url);\n    var baseParts = split(base);\n    if (parts[ComponentIndex.SCHEME]) {\n      return joinAndCanonicalizePath(parts);\n    } else {\n      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n    }\n    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n      if (!parts[i]) {\n        parts[i] = baseParts[i];\n      }\n    }\n    if (parts[ComponentIndex.PATH][0] == '/') {\n      return joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[ComponentIndex.PATH];\n    var index = path.lastIndexOf('/');\n    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n    parts[ComponentIndex.PATH] = path;\n    return joinAndCanonicalizePath(parts);\n  }\n  function isAbsolute(name) {\n    if (!name)\n      return false;\n    if (name[0] === '/')\n      return true;\n    var parts = split(name);\n    if (parts[ComponentIndex.SCHEME])\n      return true;\n    return false;\n  }\n  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n  $traceurRuntime.isAbsolute = isAbsolute;\n  $traceurRuntime.removeDotSegments = removeDotSegments;\n  $traceurRuntime.resolveUrl = resolveUrl;\n})();\n(function() {\n  'use strict';\n  var types = {\n    any: {name: 'any'},\n    boolean: {name: 'boolean'},\n    number: {name: 'number'},\n    string: {name: 'string'},\n    symbol: {name: 'symbol'},\n    void: {name: 'void'}\n  };\n  var GenericType = function GenericType(type, argumentTypes) {\n    this.type = type;\n    this.argumentTypes = argumentTypes;\n  };\n  ($traceurRuntime.createClass)(GenericType, {}, {});\n  var typeRegister = Object.create(null);\n  function genericType(type) {\n    for (var argumentTypes = [],\n        $__1 = 1; $__1 < arguments.length; $__1++)\n      argumentTypes[$__1 - 1] = arguments[$__1];\n    var typeMap = typeRegister;\n    var key = $traceurRuntime.getOwnHashObject(type).hash;\n    if (!typeMap[key]) {\n      typeMap[key] = Object.create(null);\n    }\n    typeMap = typeMap[key];\n    for (var i = 0; i < argumentTypes.length - 1; i++) {\n      key = $traceurRuntime.getOwnHashObject(argumentTypes[i]).hash;\n      if (!typeMap[key]) {\n        typeMap[key] = Object.create(null);\n      }\n      typeMap = typeMap[key];\n    }\n    var tail = argumentTypes[argumentTypes.length - 1];\n    key = $traceurRuntime.getOwnHashObject(tail).hash;\n    if (!typeMap[key]) {\n      typeMap[key] = new GenericType(type, argumentTypes);\n    }\n    return typeMap[key];\n  }\n  $traceurRuntime.GenericType = GenericType;\n  $traceurRuntime.genericType = genericType;\n  $traceurRuntime.type = types;\n})();\n(function(global) {\n  'use strict';\n  var $__2 = $traceurRuntime,\n      canonicalizeUrl = $__2.canonicalizeUrl,\n      resolveUrl = $__2.resolveUrl,\n      isAbsolute = $__2.isAbsolute;\n  var moduleInstantiators = Object.create(null);\n  var baseURL;\n  if (global.location && global.location.href)\n    baseURL = resolveUrl(global.location.href, './');\n  else\n    baseURL = '';\n  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {\n    this.url = url;\n    this.value_ = uncoatedModule;\n  };\n  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});\n  var ModuleEvaluationError = function ModuleEvaluationError(erroneousModuleName, cause) {\n    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;\n    if (!(cause instanceof $ModuleEvaluationError) && cause.stack)\n      this.stack = this.stripStack(cause.stack);\n    else\n      this.stack = '';\n  };\n  var $ModuleEvaluationError = ModuleEvaluationError;\n  ($traceurRuntime.createClass)(ModuleEvaluationError, {\n    stripError: function(message) {\n      return message.replace(/.*Error:/, this.constructor.name + ':');\n    },\n    stripCause: function(cause) {\n      if (!cause)\n        return '';\n      if (!cause.message)\n        return cause + '';\n      return this.stripError(cause.message);\n    },\n    loadedBy: function(moduleName) {\n      this.stack += '\\n loaded by ' + moduleName;\n    },\n    stripStack: function(causeStack) {\n      var stack = [];\n      causeStack.split('\\n').some((function(frame) {\n        if (/UncoatedModuleInstantiator/.test(frame))\n          return true;\n        stack.push(frame);\n      }));\n      stack[0] = this.stripError(stack[0]);\n      return stack.join('\\n');\n    }\n  }, {}, Error);\n  function beforeLines(lines, number) {\n    var result = [];\n    var first = number - 3;\n    if (first < 0)\n      first = 0;\n    for (var i = first; i < number; i++) {\n      result.push(lines[i]);\n    }\n    return result;\n  }\n  function afterLines(lines, number) {\n    var last = number + 1;\n    if (last > lines.length - 1)\n      last = lines.length - 1;\n    var result = [];\n    for (var i = number; i <= last; i++) {\n      result.push(lines[i]);\n    }\n    return result;\n  }\n  function columnSpacing(columns) {\n    var result = '';\n    for (var i = 0; i < columns - 1; i++) {\n      result += '-';\n    }\n    return result;\n  }\n  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {\n    $traceurRuntime.superConstructor($UncoatedModuleInstantiator).call(this, url, null);\n    this.func = func;\n  };\n  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;\n  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {\n      if (this.value_)\n        return this.value_;\n      try {\n        var relativeRequire;\n        if (typeof $traceurRuntime !== undefined) {\n          relativeRequire = $traceurRuntime.require.bind(null, this.url);\n        }\n        return this.value_ = this.func.call(global, relativeRequire);\n      } catch (ex) {\n        if (ex instanceof ModuleEvaluationError) {\n          ex.loadedBy(this.url);\n          throw ex;\n        }\n        if (ex.stack) {\n          var lines = this.func.toString().split('\\n');\n          var evaled = [];\n          ex.stack.split('\\n').some(function(frame) {\n            if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)\n              return true;\n            var m = /(at\\s[^\\s]*\\s).*>:(\\d*):(\\d*)\\)/.exec(frame);\n            if (m) {\n              var line = parseInt(m[2], 10);\n              evaled = evaled.concat(beforeLines(lines, line));\n              evaled.push(columnSpacing(m[3]) + '^');\n              evaled = evaled.concat(afterLines(lines, line));\n              evaled.push('= = = = = = = = =');\n            } else {\n              evaled.push(frame);\n            }\n          });\n          ex.stack = evaled.join('\\n');\n        }\n        throw new ModuleEvaluationError(this.url, ex);\n      }\n    }}, {}, UncoatedModuleEntry);\n  function getUncoatedModuleInstantiator(name) {\n    if (!name)\n      return;\n    var url = ModuleStore.normalize(name);\n    return moduleInstantiators[url];\n  }\n  ;\n  var moduleInstances = Object.create(null);\n  var liveModuleSentinel = {};\n  function Module(uncoatedModule) {\n    var isLive = arguments[1];\n    var coatedModule = Object.create(null);\n    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {\n      var getter,\n          value;\n      if (isLive === liveModuleSentinel) {\n        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n        if (descr.get)\n          getter = descr.get;\n      }\n      if (!getter) {\n        value = uncoatedModule[name];\n        getter = function() {\n          return value;\n        };\n      }\n      Object.defineProperty(coatedModule, name, {\n        get: getter,\n        enumerable: true\n      });\n    }));\n    Object.preventExtensions(coatedModule);\n    return coatedModule;\n  }\n  var ModuleStore = {\n    normalize: function(name, refererName, refererAddress) {\n      if (typeof name !== 'string')\n        throw new TypeError('module name must be a string, not ' + typeof name);\n      if (isAbsolute(name))\n        return canonicalizeUrl(name);\n      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n        throw new Error('module name embeds /../: ' + name);\n      }\n      if (name[0] === '.' && refererName)\n        return resolveUrl(refererName, name);\n      return canonicalizeUrl(name);\n    },\n    get: function(normalizedName) {\n      var m = getUncoatedModuleInstantiator(normalizedName);\n      if (!m)\n        return undefined;\n      var moduleInstance = moduleInstances[m.url];\n      if (moduleInstance)\n        return moduleInstance;\n      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n      return moduleInstances[m.url] = moduleInstance;\n    },\n    set: function(normalizedName, module) {\n      normalizedName = String(normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {\n        return module;\n      }));\n      moduleInstances[normalizedName] = module;\n    },\n    get baseURL() {\n      return baseURL;\n    },\n    set baseURL(v) {\n      baseURL = String(v);\n    },\n    registerModule: function(name, deps, func) {\n      var normalizedName = ModuleStore.normalize(name);\n      if (moduleInstantiators[normalizedName])\n        throw new Error('duplicate module named ' + normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n    },\n    bundleStore: Object.create(null),\n    register: function(name, deps, func) {\n      if (!deps || !deps.length && !func.length) {\n        this.registerModule(name, deps, func);\n      } else {\n        this.bundleStore[name] = {\n          deps: deps,\n          execute: function() {\n            var $__0 = arguments;\n            var depMap = {};\n            deps.forEach((function(dep, index) {\n              return depMap[dep] = $__0[index];\n            }));\n            var registryEntry = func.call(this, depMap);\n            registryEntry.execute.call(this);\n            return registryEntry.exports;\n          }\n        };\n      }\n    },\n    getAnonymousModule: function(func) {\n      return new Module(func.call(global), liveModuleSentinel);\n    },\n    getForTesting: function(name) {\n      var $__0 = this;\n      if (!this.testingPrefix_) {\n        Object.keys(moduleInstances).some((function(key) {\n          var m = /(traceur@[^\\/]*\\/)/.exec(key);\n          if (m) {\n            $__0.testingPrefix_ = m[1];\n            return true;\n          }\n        }));\n      }\n      return this.get(this.testingPrefix_ + name);\n    }\n  };\n  var moduleStoreModule = new Module({ModuleStore: ModuleStore});\n  ModuleStore.set('@traceur/src/runtime/ModuleStore', moduleStoreModule);\n  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n  };\n  $traceurRuntime.ModuleStore = ModuleStore;\n  global.System = {\n    register: ModuleStore.register.bind(ModuleStore),\n    registerModule: ModuleStore.registerModule.bind(ModuleStore),\n    get: ModuleStore.get,\n    set: ModuleStore.set,\n    normalize: ModuleStore.normalize\n  };\n  $traceurRuntime.getModuleImpl = function(name) {\n    var instantiator = getUncoatedModuleInstantiator(name);\n    return instantiator && instantiator.getUncoatedModule();\n  };\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\";\n  var $ceil = Math.ceil;\n  var $floor = Math.floor;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $pow = Math.pow;\n  var $min = Math.min;\n  var toObject = $traceurRuntime.toObject;\n  function toUint32(x) {\n    return x >>> 0;\n  }\n  function isObject(x) {\n    return x && (typeof x === 'object' || typeof x === 'function');\n  }\n  function isCallable(x) {\n    return typeof x === 'function';\n  }\n  function isNumber(x) {\n    return typeof x === 'number';\n  }\n  function toInteger(x) {\n    x = +x;\n    if ($isNaN(x))\n      return 0;\n    if (x === 0 || !$isFinite(x))\n      return x;\n    return x > 0 ? $floor(x) : $ceil(x);\n  }\n  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;\n  function toLength(x) {\n    var len = toInteger(x);\n    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);\n  }\n  function checkIterable(x) {\n    return !isObject(x) ? undefined : x[Symbol.iterator];\n  }\n  function isConstructor(x) {\n    return isCallable(x);\n  }\n  function createIteratorResultObject(value, done) {\n    return {\n      value: value,\n      done: done\n    };\n  }\n  function maybeDefine(object, name, descr) {\n    if (!(name in object)) {\n      Object.defineProperty(object, name, descr);\n    }\n  }\n  function maybeDefineMethod(object, name, value) {\n    maybeDefine(object, name, {\n      value: value,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  function maybeDefineConst(object, name, value) {\n    maybeDefine(object, name, {\n      value: value,\n      configurable: false,\n      enumerable: false,\n      writable: false\n    });\n  }\n  function maybeAddFunctions(object, functions) {\n    for (var i = 0; i < functions.length; i += 2) {\n      var name = functions[i];\n      var value = functions[i + 1];\n      maybeDefineMethod(object, name, value);\n    }\n  }\n  function maybeAddConsts(object, consts) {\n    for (var i = 0; i < consts.length; i += 2) {\n      var name = consts[i];\n      var value = consts[i + 1];\n      maybeDefineConst(object, name, value);\n    }\n  }\n  function maybeAddIterator(object, func, Symbol) {\n    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])\n      return;\n    if (object['@@iterator'])\n      func = object['@@iterator'];\n    Object.defineProperty(object, Symbol.iterator, {\n      value: func,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  var polyfills = [];\n  function registerPolyfill(func) {\n    polyfills.push(func);\n  }\n  function polyfillAll(global) {\n    polyfills.forEach((function(f) {\n      return f(global);\n    }));\n  }\n  return {\n    get toObject() {\n      return toObject;\n    },\n    get toUint32() {\n      return toUint32;\n    },\n    get isObject() {\n      return isObject;\n    },\n    get isCallable() {\n      return isCallable;\n    },\n    get isNumber() {\n      return isNumber;\n    },\n    get toInteger() {\n      return toInteger;\n    },\n    get toLength() {\n      return toLength;\n    },\n    get checkIterable() {\n      return checkIterable;\n    },\n    get isConstructor() {\n      return isConstructor;\n    },\n    get createIteratorResultObject() {\n      return createIteratorResultObject;\n    },\n    get maybeDefine() {\n      return maybeDefine;\n    },\n    get maybeDefineMethod() {\n      return maybeDefineMethod;\n    },\n    get maybeDefineConst() {\n      return maybeDefineConst;\n    },\n    get maybeAddFunctions() {\n      return maybeAddFunctions;\n    },\n    get maybeAddConsts() {\n      return maybeAddConsts;\n    },\n    get maybeAddIterator() {\n      return maybeAddIterator;\n    },\n    get registerPolyfill() {\n      return registerPolyfill;\n    },\n    get polyfillAll() {\n      return polyfillAll;\n    }\n  };\n});\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/Map.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/Map.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      isObject = $__0.isObject,\n      maybeAddIterator = $__0.maybeAddIterator,\n      registerPolyfill = $__0.registerPolyfill;\n  var getOwnHashObject = $traceurRuntime.getOwnHashObject;\n  var $hasOwnProperty = Object.prototype.hasOwnProperty;\n  var deletedSentinel = {};\n  function lookupIndex(map, key) {\n    if (isObject(key)) {\n      var hashObject = getOwnHashObject(key);\n      return hashObject && map.objectIndex_[hashObject.hash];\n    }\n    if (typeof key === 'string')\n      return map.stringIndex_[key];\n    return map.primitiveIndex_[key];\n  }\n  function initMap(map) {\n    map.entries_ = [];\n    map.objectIndex_ = Object.create(null);\n    map.stringIndex_ = Object.create(null);\n    map.primitiveIndex_ = Object.create(null);\n    map.deletedCount_ = 0;\n  }\n  var Map = function Map() {\n    var iterable = arguments[0];\n    if (!isObject(this))\n      throw new TypeError('Map called on incompatible type');\n    if ($hasOwnProperty.call(this, 'entries_')) {\n      throw new TypeError('Map can not be reentrantly initialised');\n    }\n    initMap(this);\n    if (iterable !== null && iterable !== undefined) {\n      for (var $__2 = iterable[$traceurRuntime.toProperty(Symbol.iterator)](),\n          $__3; !($__3 = $__2.next()).done; ) {\n        var $__4 = $__3.value,\n            key = $__4[0],\n            value = $__4[1];\n        {\n          this.set(key, value);\n        }\n      }\n    }\n  };\n  ($traceurRuntime.createClass)(Map, {\n    get size() {\n      return this.entries_.length / 2 - this.deletedCount_;\n    },\n    get: function(key) {\n      var index = lookupIndex(this, key);\n      if (index !== undefined)\n        return this.entries_[index + 1];\n    },\n    set: function(key, value) {\n      var objectMode = isObject(key);\n      var stringMode = typeof key === 'string';\n      var index = lookupIndex(this, key);\n      if (index !== undefined) {\n        this.entries_[index + 1] = value;\n      } else {\n        index = this.entries_.length;\n        this.entries_[index] = key;\n        this.entries_[index + 1] = value;\n        if (objectMode) {\n          var hashObject = getOwnHashObject(key);\n          var hash = hashObject.hash;\n          this.objectIndex_[hash] = index;\n        } else if (stringMode) {\n          this.stringIndex_[key] = index;\n        } else {\n          this.primitiveIndex_[key] = index;\n        }\n      }\n      return this;\n    },\n    has: function(key) {\n      return lookupIndex(this, key) !== undefined;\n    },\n    delete: function(key) {\n      var objectMode = isObject(key);\n      var stringMode = typeof key === 'string';\n      var index;\n      var hash;\n      if (objectMode) {\n        var hashObject = getOwnHashObject(key);\n        if (hashObject) {\n          index = this.objectIndex_[hash = hashObject.hash];\n          delete this.objectIndex_[hash];\n        }\n      } else if (stringMode) {\n        index = this.stringIndex_[key];\n        delete this.stringIndex_[key];\n      } else {\n        index = this.primitiveIndex_[key];\n        delete this.primitiveIndex_[key];\n      }\n      if (index !== undefined) {\n        this.entries_[index] = deletedSentinel;\n        this.entries_[index + 1] = undefined;\n        this.deletedCount_++;\n        return true;\n      }\n      return false;\n    },\n    clear: function() {\n      initMap(this);\n    },\n    forEach: function(callbackFn) {\n      var thisArg = arguments[1];\n      for (var i = 0; i < this.entries_.length; i += 2) {\n        var key = this.entries_[i];\n        var value = this.entries_[i + 1];\n        if (key === deletedSentinel)\n          continue;\n        callbackFn.call(thisArg, value, key, this);\n      }\n    },\n    entries: $traceurRuntime.initGeneratorFunction(function $__5() {\n      var i,\n          key,\n          value;\n      return $traceurRuntime.createGeneratorInstance(function($ctx) {\n        while (true)\n          switch ($ctx.state) {\n            case 0:\n              i = 0;\n              $ctx.state = 12;\n              break;\n            case 12:\n              $ctx.state = (i < this.entries_.length) ? 8 : -2;\n              break;\n            case 4:\n              i += 2;\n              $ctx.state = 12;\n              break;\n            case 8:\n              key = this.entries_[i];\n              value = this.entries_[i + 1];\n              $ctx.state = 9;\n              break;\n            case 9:\n              $ctx.state = (key === deletedSentinel) ? 4 : 6;\n              break;\n            case 6:\n              $ctx.state = 2;\n              return [key, value];\n            case 2:\n              $ctx.maybeThrow();\n              $ctx.state = 4;\n              break;\n            default:\n              return $ctx.end();\n          }\n      }, $__5, this);\n    }),\n    keys: $traceurRuntime.initGeneratorFunction(function $__6() {\n      var i,\n          key,\n          value;\n      return $traceurRuntime.createGeneratorInstance(function($ctx) {\n        while (true)\n          switch ($ctx.state) {\n            case 0:\n              i = 0;\n              $ctx.state = 12;\n              break;\n            case 12:\n              $ctx.state = (i < this.entries_.length) ? 8 : -2;\n              break;\n            case 4:\n              i += 2;\n              $ctx.state = 12;\n              break;\n            case 8:\n              key = this.entries_[i];\n              value = this.entries_[i + 1];\n              $ctx.state = 9;\n              break;\n            case 9:\n              $ctx.state = (key === deletedSentinel) ? 4 : 6;\n              break;\n            case 6:\n              $ctx.state = 2;\n              return key;\n            case 2:\n              $ctx.maybeThrow();\n              $ctx.state = 4;\n              break;\n            default:\n              return $ctx.end();\n          }\n      }, $__6, this);\n    }),\n    values: $traceurRuntime.initGeneratorFunction(function $__7() {\n      var i,\n          key,\n          value;\n      return $traceurRuntime.createGeneratorInstance(function($ctx) {\n        while (true)\n          switch ($ctx.state) {\n            case 0:\n              i = 0;\n              $ctx.state = 12;\n              break;\n            case 12:\n              $ctx.state = (i < this.entries_.length) ? 8 : -2;\n              break;\n            case 4:\n              i += 2;\n              $ctx.state = 12;\n              break;\n            case 8:\n              key = this.entries_[i];\n              value = this.entries_[i + 1];\n              $ctx.state = 9;\n              break;\n            case 9:\n              $ctx.state = (key === deletedSentinel) ? 4 : 6;\n              break;\n            case 6:\n              $ctx.state = 2;\n              return value;\n            case 2:\n              $ctx.maybeThrow();\n              $ctx.state = 4;\n              break;\n            default:\n              return $ctx.end();\n          }\n      }, $__7, this);\n    })\n  }, {});\n  Object.defineProperty(Map.prototype, Symbol.iterator, {\n    configurable: true,\n    writable: true,\n    value: Map.prototype.entries\n  });\n  function polyfillMap(global) {\n    var $__4 = global,\n        Object = $__4.Object,\n        Symbol = $__4.Symbol;\n    if (!global.Map)\n      global.Map = Map;\n    var mapPrototype = global.Map.prototype;\n    if (mapPrototype.entries === undefined)\n      global.Map = Map;\n    if (mapPrototype.entries) {\n      maybeAddIterator(mapPrototype, mapPrototype.entries, Symbol);\n      maybeAddIterator(Object.getPrototypeOf(new global.Map().entries()), function() {\n        return this;\n      }, Symbol);\n    }\n  }\n  registerPolyfill(polyfillMap);\n  return {\n    get Map() {\n      return Map;\n    },\n    get polyfillMap() {\n      return polyfillMap;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Map.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/Set.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/Set.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      isObject = $__0.isObject,\n      maybeAddIterator = $__0.maybeAddIterator,\n      registerPolyfill = $__0.registerPolyfill;\n  var Map = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Map.js\").Map;\n  var getOwnHashObject = $traceurRuntime.getOwnHashObject;\n  var $hasOwnProperty = Object.prototype.hasOwnProperty;\n  function initSet(set) {\n    set.map_ = new Map();\n  }\n  var Set = function Set() {\n    var iterable = arguments[0];\n    if (!isObject(this))\n      throw new TypeError('Set called on incompatible type');\n    if ($hasOwnProperty.call(this, 'map_')) {\n      throw new TypeError('Set can not be reentrantly initialised');\n    }\n    initSet(this);\n    if (iterable !== null && iterable !== undefined) {\n      for (var $__4 = iterable[$traceurRuntime.toProperty(Symbol.iterator)](),\n          $__5; !($__5 = $__4.next()).done; ) {\n        var item = $__5.value;\n        {\n          this.add(item);\n        }\n      }\n    }\n  };\n  ($traceurRuntime.createClass)(Set, {\n    get size() {\n      return this.map_.size;\n    },\n    has: function(key) {\n      return this.map_.has(key);\n    },\n    add: function(key) {\n      this.map_.set(key, key);\n      return this;\n    },\n    delete: function(key) {\n      return this.map_.delete(key);\n    },\n    clear: function() {\n      return this.map_.clear();\n    },\n    forEach: function(callbackFn) {\n      var thisArg = arguments[1];\n      var $__2 = this;\n      return this.map_.forEach((function(value, key) {\n        callbackFn.call(thisArg, key, key, $__2);\n      }));\n    },\n    values: $traceurRuntime.initGeneratorFunction(function $__7() {\n      var $__8,\n          $__9;\n      return $traceurRuntime.createGeneratorInstance(function($ctx) {\n        while (true)\n          switch ($ctx.state) {\n            case 0:\n              $__8 = this.map_.keys()[Symbol.iterator]();\n              $ctx.sent = void 0;\n              $ctx.action = 'next';\n              $ctx.state = 12;\n              break;\n            case 12:\n              $__9 = $__8[$ctx.action]($ctx.sentIgnoreThrow);\n              $ctx.state = 9;\n              break;\n            case 9:\n              $ctx.state = ($__9.done) ? 3 : 2;\n              break;\n            case 3:\n              $ctx.sent = $__9.value;\n              $ctx.state = -2;\n              break;\n            case 2:\n              $ctx.state = 12;\n              return $__9.value;\n            default:\n              return $ctx.end();\n          }\n      }, $__7, this);\n    }),\n    entries: $traceurRuntime.initGeneratorFunction(function $__10() {\n      var $__11,\n          $__12;\n      return $traceurRuntime.createGeneratorInstance(function($ctx) {\n        while (true)\n          switch ($ctx.state) {\n            case 0:\n              $__11 = this.map_.entries()[Symbol.iterator]();\n              $ctx.sent = void 0;\n              $ctx.action = 'next';\n              $ctx.state = 12;\n              break;\n            case 12:\n              $__12 = $__11[$ctx.action]($ctx.sentIgnoreThrow);\n              $ctx.state = 9;\n              break;\n            case 9:\n              $ctx.state = ($__12.done) ? 3 : 2;\n              break;\n            case 3:\n              $ctx.sent = $__12.value;\n              $ctx.state = -2;\n              break;\n            case 2:\n              $ctx.state = 12;\n              return $__12.value;\n            default:\n              return $ctx.end();\n          }\n      }, $__10, this);\n    })\n  }, {});\n  Object.defineProperty(Set.prototype, Symbol.iterator, {\n    configurable: true,\n    writable: true,\n    value: Set.prototype.values\n  });\n  Object.defineProperty(Set.prototype, 'keys', {\n    configurable: true,\n    writable: true,\n    value: Set.prototype.values\n  });\n  function polyfillSet(global) {\n    var $__6 = global,\n        Object = $__6.Object,\n        Symbol = $__6.Symbol;\n    if (!global.Set)\n      global.Set = Set;\n    var setPrototype = global.Set.prototype;\n    if (setPrototype.values) {\n      maybeAddIterator(setPrototype, setPrototype.values, Symbol);\n      maybeAddIterator(Object.getPrototypeOf(new global.Set().values()), function() {\n        return this;\n      }, Symbol);\n    }\n  }\n  registerPolyfill(polyfillSet);\n  return {\n    get Set() {\n      return Set;\n    },\n    get polyfillSet() {\n      return polyfillSet;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Set.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/node_modules/rsvp/lib/rsvp/asap.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/node_modules/rsvp/lib/rsvp/asap.js\";\n  var len = 0;\n  function asap(callback, arg) {\n    queue[len] = callback;\n    queue[len + 1] = arg;\n    len += 2;\n    if (len === 2) {\n      scheduleFlush();\n    }\n  }\n  var $__default = asap;\n  var browserGlobal = (typeof window !== 'undefined') ? window : {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n  function useNextTick() {\n    return function() {\n      process.nextTick(flush);\n    };\n  }\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode('');\n    observer.observe(node, {characterData: true});\n    return function() {\n      node.data = (iterations = ++iterations % 2);\n    };\n  }\n  function useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    return function() {\n      channel.port2.postMessage(0);\n    };\n  }\n  function useSetTimeout() {\n    return function() {\n      setTimeout(flush, 1);\n    };\n  }\n  var queue = new Array(1000);\n  function flush() {\n    for (var i = 0; i < len; i += 2) {\n      var callback = queue[i];\n      var arg = queue[i + 1];\n      callback(arg);\n      queue[i] = undefined;\n      queue[i + 1] = undefined;\n    }\n    len = 0;\n  }\n  var scheduleFlush;\n  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else if (isWorker) {\n    scheduleFlush = useMessageChannel();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n  return {get default() {\n      return $__default;\n    }};\n});\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/Promise.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/Promise.js\";\n  var async = System.get(\"traceur-runtime@0.0.79/node_modules/rsvp/lib/rsvp/asap.js\").default;\n  var registerPolyfill = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\").registerPolyfill;\n  var promiseRaw = {};\n  function isPromise(x) {\n    return x && typeof x === 'object' && x.status_ !== undefined;\n  }\n  function idResolveHandler(x) {\n    return x;\n  }\n  function idRejectHandler(x) {\n    throw x;\n  }\n  function chain(promise) {\n    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;\n    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;\n    var deferred = getDeferred(promise.constructor);\n    switch (promise.status_) {\n      case undefined:\n        throw TypeError;\n      case 0:\n        promise.onResolve_.push(onResolve, deferred);\n        promise.onReject_.push(onReject, deferred);\n        break;\n      case +1:\n        promiseEnqueue(promise.value_, [onResolve, deferred]);\n        break;\n      case -1:\n        promiseEnqueue(promise.value_, [onReject, deferred]);\n        break;\n    }\n    return deferred.promise;\n  }\n  function getDeferred(C) {\n    if (this === $Promise) {\n      var promise = promiseInit(new $Promise(promiseRaw));\n      return {\n        promise: promise,\n        resolve: (function(x) {\n          promiseResolve(promise, x);\n        }),\n        reject: (function(r) {\n          promiseReject(promise, r);\n        })\n      };\n    } else {\n      var result = {};\n      result.promise = new C((function(resolve, reject) {\n        result.resolve = resolve;\n        result.reject = reject;\n      }));\n      return result;\n    }\n  }\n  function promiseSet(promise, status, value, onResolve, onReject) {\n    promise.status_ = status;\n    promise.value_ = value;\n    promise.onResolve_ = onResolve;\n    promise.onReject_ = onReject;\n    return promise;\n  }\n  function promiseInit(promise) {\n    return promiseSet(promise, 0, undefined, [], []);\n  }\n  var Promise = function Promise(resolver) {\n    if (resolver === promiseRaw)\n      return;\n    if (typeof resolver !== 'function')\n      throw new TypeError;\n    var promise = promiseInit(this);\n    try {\n      resolver((function(x) {\n        promiseResolve(promise, x);\n      }), (function(r) {\n        promiseReject(promise, r);\n      }));\n    } catch (e) {\n      promiseReject(promise, e);\n    }\n  };\n  ($traceurRuntime.createClass)(Promise, {\n    catch: function(onReject) {\n      return this.then(undefined, onReject);\n    },\n    then: function(onResolve, onReject) {\n      if (typeof onResolve !== 'function')\n        onResolve = idResolveHandler;\n      if (typeof onReject !== 'function')\n        onReject = idRejectHandler;\n      var that = this;\n      var constructor = this.constructor;\n      return chain(this, function(x) {\n        x = promiseCoerce(constructor, x);\n        return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n      }, onReject);\n    }\n  }, {\n    resolve: function(x) {\n      if (this === $Promise) {\n        if (isPromise(x)) {\n          return x;\n        }\n        return promiseSet(new $Promise(promiseRaw), +1, x);\n      } else {\n        return new this(function(resolve, reject) {\n          resolve(x);\n        });\n      }\n    },\n    reject: function(r) {\n      if (this === $Promise) {\n        return promiseSet(new $Promise(promiseRaw), -1, r);\n      } else {\n        return new this((function(resolve, reject) {\n          reject(r);\n        }));\n      }\n    },\n    all: function(values) {\n      var deferred = getDeferred(this);\n      var resolutions = [];\n      try {\n        var count = values.length;\n        if (count === 0) {\n          deferred.resolve(resolutions);\n        } else {\n          for (var i = 0; i < values.length; i++) {\n            this.resolve(values[i]).then(function(i, x) {\n              resolutions[i] = x;\n              if (--count === 0)\n                deferred.resolve(resolutions);\n            }.bind(undefined, i), (function(r) {\n              deferred.reject(r);\n            }));\n          }\n        }\n      } catch (e) {\n        deferred.reject(e);\n      }\n      return deferred.promise;\n    },\n    race: function(values) {\n      var deferred = getDeferred(this);\n      try {\n        for (var i = 0; i < values.length; i++) {\n          this.resolve(values[i]).then((function(x) {\n            deferred.resolve(x);\n          }), (function(r) {\n            deferred.reject(r);\n          }));\n        }\n      } catch (e) {\n        deferred.reject(e);\n      }\n      return deferred.promise;\n    }\n  });\n  var $Promise = Promise;\n  var $PromiseReject = $Promise.reject;\n  function promiseResolve(promise, x) {\n    promiseDone(promise, +1, x, promise.onResolve_);\n  }\n  function promiseReject(promise, r) {\n    promiseDone(promise, -1, r, promise.onReject_);\n  }\n  function promiseDone(promise, status, value, reactions) {\n    if (promise.status_ !== 0)\n      return;\n    promiseEnqueue(value, reactions);\n    promiseSet(promise, status, value);\n  }\n  function promiseEnqueue(value, tasks) {\n    async((function() {\n      for (var i = 0; i < tasks.length; i += 2) {\n        promiseHandle(value, tasks[i], tasks[i + 1]);\n      }\n    }));\n  }\n  function promiseHandle(value, handler, deferred) {\n    try {\n      var result = handler(value);\n      if (result === deferred.promise)\n        throw new TypeError;\n      else if (isPromise(result))\n        chain(result, deferred.resolve, deferred.reject);\n      else\n        deferred.resolve(result);\n    } catch (e) {\n      try {\n        deferred.reject(e);\n      } catch (e) {}\n    }\n  }\n  var thenableSymbol = '@@thenable';\n  function isObject(x) {\n    return x && (typeof x === 'object' || typeof x === 'function');\n  }\n  function promiseCoerce(constructor, x) {\n    if (!isPromise(x) && isObject(x)) {\n      var then;\n      try {\n        then = x.then;\n      } catch (r) {\n        var promise = $PromiseReject.call(constructor, r);\n        x[thenableSymbol] = promise;\n        return promise;\n      }\n      if (typeof then === 'function') {\n        var p = x[thenableSymbol];\n        if (p) {\n          return p;\n        } else {\n          var deferred = getDeferred(constructor);\n          x[thenableSymbol] = deferred.promise;\n          try {\n            then.call(x, deferred.resolve, deferred.reject);\n          } catch (r) {\n            deferred.reject(r);\n          }\n          return deferred.promise;\n        }\n      }\n    }\n    return x;\n  }\n  function polyfillPromise(global) {\n    if (!global.Promise)\n      global.Promise = Promise;\n  }\n  registerPolyfill(polyfillPromise);\n  return {\n    get Promise() {\n      return Promise;\n    },\n    get polyfillPromise() {\n      return polyfillPromise;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Promise.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/StringIterator.js\", [], function() {\n  \"use strict\";\n  var $__2;\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/StringIterator.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      createIteratorResultObject = $__0.createIteratorResultObject,\n      isObject = $__0.isObject;\n  var toProperty = $traceurRuntime.toProperty;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var iteratedString = Symbol('iteratedString');\n  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');\n  var StringIterator = function StringIterator() {};\n  ($traceurRuntime.createClass)(StringIterator, ($__2 = {}, Object.defineProperty($__2, \"next\", {\n    value: function() {\n      var o = this;\n      if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {\n        throw new TypeError('this must be a StringIterator object');\n      }\n      var s = o[toProperty(iteratedString)];\n      if (s === undefined) {\n        return createIteratorResultObject(undefined, true);\n      }\n      var position = o[toProperty(stringIteratorNextIndex)];\n      var len = s.length;\n      if (position >= len) {\n        o[toProperty(iteratedString)] = undefined;\n        return createIteratorResultObject(undefined, true);\n      }\n      var first = s.charCodeAt(position);\n      var resultString;\n      if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {\n        resultString = String.fromCharCode(first);\n      } else {\n        var second = s.charCodeAt(position + 1);\n        if (second < 0xDC00 || second > 0xDFFF) {\n          resultString = String.fromCharCode(first);\n        } else {\n          resultString = String.fromCharCode(first) + String.fromCharCode(second);\n        }\n      }\n      o[toProperty(stringIteratorNextIndex)] = position + resultString.length;\n      return createIteratorResultObject(resultString, false);\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), Object.defineProperty($__2, Symbol.iterator, {\n    value: function() {\n      return this;\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), $__2), {});\n  function createStringIterator(string) {\n    var s = String(string);\n    var iterator = Object.create(StringIterator.prototype);\n    iterator[toProperty(iteratedString)] = s;\n    iterator[toProperty(stringIteratorNextIndex)] = 0;\n    return iterator;\n  }\n  return {get createStringIterator() {\n      return createStringIterator;\n    }};\n});\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/String.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/String.js\";\n  var createStringIterator = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/StringIterator.js\").createStringIterator;\n  var $__1 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      maybeAddFunctions = $__1.maybeAddFunctions,\n      maybeAddIterator = $__1.maybeAddIterator,\n      registerPolyfill = $__1.registerPolyfill;\n  var $toString = Object.prototype.toString;\n  var $indexOf = String.prototype.indexOf;\n  var $lastIndexOf = String.prototype.lastIndexOf;\n  function startsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) == start;\n  }\n  function endsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var pos = stringLength;\n    if (arguments.length > 1) {\n      var position = arguments[1];\n      if (position !== undefined) {\n        pos = position ? Number(position) : 0;\n        if (isNaN(pos)) {\n          pos = 0;\n        }\n      }\n    }\n    var end = Math.min(Math.max(pos, 0), stringLength);\n    var start = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return $lastIndexOf.call(string, searchString, start) == start;\n  }\n  function includes(search) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    if (search && $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (pos != pos) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    if (searchLength + start > stringLength) {\n      return false;\n    }\n    return $indexOf.call(string, searchString, pos) != -1;\n  }\n  function repeat(count) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var n = count ? Number(count) : 0;\n    if (isNaN(n)) {\n      n = 0;\n    }\n    if (n < 0 || n == Infinity) {\n      throw RangeError();\n    }\n    if (n == 0) {\n      return '';\n    }\n    var result = '';\n    while (n--) {\n      result += string;\n    }\n    return result;\n  }\n  function codePointAt(position) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var size = string.length;\n    var index = position ? Number(position) : 0;\n    if (isNaN(index)) {\n      index = 0;\n    }\n    if (index < 0 || index >= size) {\n      return undefined;\n    }\n    var first = string.charCodeAt(index);\n    var second;\n    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n      second = string.charCodeAt(index + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n  function raw(callsite) {\n    var raw = callsite.raw;\n    var len = raw.length >>> 0;\n    if (len === 0)\n      return '';\n    var s = '';\n    var i = 0;\n    while (true) {\n      s += raw[i];\n      if (i + 1 === len)\n        return s;\n      s += arguments[++i];\n    }\n  }\n  function fromCodePoint() {\n    var codeUnits = [];\n    var floor = Math.floor;\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return '';\n    }\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        codeUnits.push(codePoint);\n      } else {\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n    }\n    return String.fromCharCode.apply(null, codeUnits);\n  }\n  function stringPrototypeIterator() {\n    var o = $traceurRuntime.checkObjectCoercible(this);\n    var s = String(o);\n    return createStringIterator(s);\n  }\n  function polyfillString(global) {\n    var String = global.String;\n    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);\n    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);\n    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);\n  }\n  registerPolyfill(polyfillString);\n  return {\n    get startsWith() {\n      return startsWith;\n    },\n    get endsWith() {\n      return endsWith;\n    },\n    get includes() {\n      return includes;\n    },\n    get repeat() {\n      return repeat;\n    },\n    get codePointAt() {\n      return codePointAt;\n    },\n    get raw() {\n      return raw;\n    },\n    get fromCodePoint() {\n      return fromCodePoint;\n    },\n    get stringPrototypeIterator() {\n      return stringPrototypeIterator;\n    },\n    get polyfillString() {\n      return polyfillString;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/String.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/ArrayIterator.js\", [], function() {\n  \"use strict\";\n  var $__2;\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/ArrayIterator.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      toObject = $__0.toObject,\n      toUint32 = $__0.toUint32,\n      createIteratorResultObject = $__0.createIteratorResultObject;\n  var ARRAY_ITERATOR_KIND_KEYS = 1;\n  var ARRAY_ITERATOR_KIND_VALUES = 2;\n  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n  var ArrayIterator = function ArrayIterator() {};\n  ($traceurRuntime.createClass)(ArrayIterator, ($__2 = {}, Object.defineProperty($__2, \"next\", {\n    value: function() {\n      var iterator = toObject(this);\n      var array = iterator.iteratorObject_;\n      if (!array) {\n        throw new TypeError('Object is not an ArrayIterator');\n      }\n      var index = iterator.arrayIteratorNextIndex_;\n      var itemKind = iterator.arrayIterationKind_;\n      var length = toUint32(array.length);\n      if (index >= length) {\n        iterator.arrayIteratorNextIndex_ = Infinity;\n        return createIteratorResultObject(undefined, true);\n      }\n      iterator.arrayIteratorNextIndex_ = index + 1;\n      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n        return createIteratorResultObject(array[index], false);\n      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n        return createIteratorResultObject([index, array[index]], false);\n      return createIteratorResultObject(index, false);\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), Object.defineProperty($__2, Symbol.iterator, {\n    value: function() {\n      return this;\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), $__2), {});\n  function createArrayIterator(array, kind) {\n    var object = toObject(array);\n    var iterator = new ArrayIterator;\n    iterator.iteratorObject_ = object;\n    iterator.arrayIteratorNextIndex_ = 0;\n    iterator.arrayIterationKind_ = kind;\n    return iterator;\n  }\n  function entries() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n  }\n  function keys() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n  }\n  function values() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n  }\n  return {\n    get entries() {\n      return entries;\n    },\n    get keys() {\n      return keys;\n    },\n    get values() {\n      return values;\n    }\n  };\n});\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/Array.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/Array.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/ArrayIterator.js\"),\n      entries = $__0.entries,\n      keys = $__0.keys,\n      values = $__0.values;\n  var $__1 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      checkIterable = $__1.checkIterable,\n      isCallable = $__1.isCallable,\n      isConstructor = $__1.isConstructor,\n      maybeAddFunctions = $__1.maybeAddFunctions,\n      maybeAddIterator = $__1.maybeAddIterator,\n      registerPolyfill = $__1.registerPolyfill,\n      toInteger = $__1.toInteger,\n      toLength = $__1.toLength,\n      toObject = $__1.toObject;\n  function from(arrLike) {\n    var mapFn = arguments[1];\n    var thisArg = arguments[2];\n    var C = this;\n    var items = toObject(arrLike);\n    var mapping = mapFn !== undefined;\n    var k = 0;\n    var arr,\n        len;\n    if (mapping && !isCallable(mapFn)) {\n      throw TypeError();\n    }\n    if (checkIterable(items)) {\n      arr = isConstructor(C) ? new C() : [];\n      for (var $__2 = items[$traceurRuntime.toProperty(Symbol.iterator)](),\n          $__3; !($__3 = $__2.next()).done; ) {\n        var item = $__3.value;\n        {\n          if (mapping) {\n            arr[k] = mapFn.call(thisArg, item, k);\n          } else {\n            arr[k] = item;\n          }\n          k++;\n        }\n      }\n      arr.length = k;\n      return arr;\n    }\n    len = toLength(items.length);\n    arr = isConstructor(C) ? new C(len) : new Array(len);\n    for (; k < len; k++) {\n      if (mapping) {\n        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);\n      } else {\n        arr[k] = items[k];\n      }\n    }\n    arr.length = len;\n    return arr;\n  }\n  function of() {\n    for (var items = [],\n        $__4 = 0; $__4 < arguments.length; $__4++)\n      items[$__4] = arguments[$__4];\n    var C = this;\n    var len = items.length;\n    var arr = isConstructor(C) ? new C(len) : new Array(len);\n    for (var k = 0; k < len; k++) {\n      arr[k] = items[k];\n    }\n    arr.length = len;\n    return arr;\n  }\n  function fill(value) {\n    var start = arguments[1] !== (void 0) ? arguments[1] : 0;\n    var end = arguments[2];\n    var object = toObject(this);\n    var len = toLength(object.length);\n    var fillStart = toInteger(start);\n    var fillEnd = end !== undefined ? toInteger(end) : len;\n    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);\n    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);\n    while (fillStart < fillEnd) {\n      object[fillStart] = value;\n      fillStart++;\n    }\n    return object;\n  }\n  function find(predicate) {\n    var thisArg = arguments[1];\n    return findHelper(this, predicate, thisArg);\n  }\n  function findIndex(predicate) {\n    var thisArg = arguments[1];\n    return findHelper(this, predicate, thisArg, true);\n  }\n  function findHelper(self, predicate) {\n    var thisArg = arguments[2];\n    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;\n    var object = toObject(self);\n    var len = toLength(object.length);\n    if (!isCallable(predicate)) {\n      throw TypeError();\n    }\n    for (var i = 0; i < len; i++) {\n      var value = object[i];\n      if (predicate.call(thisArg, value, i, object)) {\n        return returnIndex ? i : value;\n      }\n    }\n    return returnIndex ? -1 : undefined;\n  }\n  function polyfillArray(global) {\n    var $__5 = global,\n        Array = $__5.Array,\n        Object = $__5.Object,\n        Symbol = $__5.Symbol;\n    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);\n    maybeAddFunctions(Array, ['from', from, 'of', of]);\n    maybeAddIterator(Array.prototype, values, Symbol);\n    maybeAddIterator(Object.getPrototypeOf([].values()), function() {\n      return this;\n    }, Symbol);\n  }\n  registerPolyfill(polyfillArray);\n  return {\n    get from() {\n      return from;\n    },\n    get of() {\n      return of;\n    },\n    get fill() {\n      return fill;\n    },\n    get find() {\n      return find;\n    },\n    get findIndex() {\n      return findIndex;\n    },\n    get polyfillArray() {\n      return polyfillArray;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Array.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/Object.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/Object.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      maybeAddFunctions = $__0.maybeAddFunctions,\n      registerPolyfill = $__0.registerPolyfill;\n  var $__1 = $traceurRuntime,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,\n      getOwnPropertyNames = $__1.getOwnPropertyNames,\n      isPrivateName = $__1.isPrivateName,\n      keys = $__1.keys;\n  function is(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    return left !== left && right !== right;\n  }\n  function assign(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      var props = source == null ? [] : keys(source);\n      var p,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        var name = props[p];\n        if (isPrivateName(name))\n          continue;\n        target[name] = source[name];\n      }\n    }\n    return target;\n  }\n  function mixin(target, source) {\n    var props = getOwnPropertyNames(source);\n    var p,\n        descriptor,\n        length = props.length;\n    for (p = 0; p < length; p++) {\n      var name = props[p];\n      if (isPrivateName(name))\n        continue;\n      descriptor = getOwnPropertyDescriptor(source, props[p]);\n      defineProperty(target, props[p], descriptor);\n    }\n    return target;\n  }\n  function polyfillObject(global) {\n    var Object = global.Object;\n    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);\n  }\n  registerPolyfill(polyfillObject);\n  return {\n    get is() {\n      return is;\n    },\n    get assign() {\n      return assign;\n    },\n    get mixin() {\n      return mixin;\n    },\n    get polyfillObject() {\n      return polyfillObject;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Object.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/Number.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/Number.js\";\n  var $__0 = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\"),\n      isNumber = $__0.isNumber,\n      maybeAddConsts = $__0.maybeAddConsts,\n      maybeAddFunctions = $__0.maybeAddFunctions,\n      registerPolyfill = $__0.registerPolyfill,\n      toInteger = $__0.toInteger;\n  var $abs = Math.abs;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;\n  var EPSILON = Math.pow(2, -52);\n  function NumberIsFinite(number) {\n    return isNumber(number) && $isFinite(number);\n  }\n  ;\n  function isInteger(number) {\n    return NumberIsFinite(number) && toInteger(number) === number;\n  }\n  function NumberIsNaN(number) {\n    return isNumber(number) && $isNaN(number);\n  }\n  ;\n  function isSafeInteger(number) {\n    if (NumberIsFinite(number)) {\n      var integral = toInteger(number);\n      if (integral === number)\n        return $abs(integral) <= MAX_SAFE_INTEGER;\n    }\n    return false;\n  }\n  function polyfillNumber(global) {\n    var Number = global.Number;\n    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);\n    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);\n  }\n  registerPolyfill(polyfillNumber);\n  return {\n    get MAX_SAFE_INTEGER() {\n      return MAX_SAFE_INTEGER;\n    },\n    get MIN_SAFE_INTEGER() {\n      return MIN_SAFE_INTEGER;\n    },\n    get EPSILON() {\n      return EPSILON;\n    },\n    get isFinite() {\n      return NumberIsFinite;\n    },\n    get isInteger() {\n      return isInteger;\n    },\n    get isNaN() {\n      return NumberIsNaN;\n    },\n    get isSafeInteger() {\n      return isSafeInteger;\n    },\n    get polyfillNumber() {\n      return polyfillNumber;\n    }\n  };\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/Number.js\" + '');\nSystem.registerModule(\"traceur-runtime@0.0.79/src/runtime/polyfills/polyfills.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.79/src/runtime/polyfills/polyfills.js\";\n  var polyfillAll = System.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/utils.js\").polyfillAll;\n  polyfillAll(Reflect.global);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n    polyfillAll(global);\n  };\n  return {};\n});\nSystem.get(\"traceur-runtime@0.0.79/src/runtime/polyfills/polyfills.js\" + '');\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"_process\":119,\"path\":118}],136:[function(require,module,exports){\n\"use strict\";\n\"use strict\";\nrequire(\"./home\");\nrequire(\"./templates\");\nrequire(\"angular\").module(\"app\", [\"home\", \"templateCache\"]);\n\n\n//# sourceURL=F:/nodeTemplate/src/angular-pages/app.js\n},{\"./home\":137,\"./templates\":138,\"angular\":3}],137:[function(require,module,exports){\n\"use strict\";\n\"use strict\";\nrequire(\"angular\").module(\"home\", []).directive(\"home\", function() {\n  return {templateUrl: \"fragment.html\"};\n});\n\n\n//# sourceURL=F:/nodeTemplate/src/angular-pages/home.js\n},{\"angular\":3}],138:[function(require,module,exports){\n\"use strict\";\nvar angular = require(\"angular\");\nangular.module(\"templateCache\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"fragment.html\", \"<span>text</span>\\r\\n\");\n}]);\n\n\n//# sourceURL=F:/nodeTemplate/src/angular-pages/templates.js\n},{\"angular\":3}],\"fs\":[function(require,module,exports){\n\"use strict\";\nvar leveljs = require('level-js');\nvar levelup = require('levelup');\nvar fs = require('level-filesystem');\nvar db = levelup('level-filesystem', {db: leveljs});\nmodule.exports = fs(db);\n\n\n//# sourceURL=F:/nodeTemplate/node_modules/browserify-fs/index.js\n},{\"level-filesystem\":5,\"level-js\":68,\"levelup\":86}]},{},[1,135]);\n"],"file":"src/main.js","sourceRoot":"/source/"}